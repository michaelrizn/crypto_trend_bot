Project Tree Structure:
‚îú‚îÄ‚îÄ crypto_trend_bot/
‚îÇ   ‚îú‚îÄ‚îÄ config.py
‚îÇ   ‚îú‚îÄ‚îÄ requirements.txt
‚îÇ   ‚îú‚îÄ‚îÄ Dockerfile
‚îÇ   ‚îú‚îÄ‚îÄ main.py
‚îÇ   ‚îú‚îÄ‚îÄ bot/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __pycache__/
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ scheduler.cpython-311.pyc
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ handlers/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __pycache__/
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __init__.cpython-311.pyc
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ commands.cpython-311.pyc
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ periodic_tasks.cpython-311.pyc
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ signals.cpython-311.pyc
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ utils.cpython-311.pyc
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ commands.py
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ periodic_tasks.py
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ signals.py
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ utils.py
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ scheduler.py
‚îÇ   ‚îú‚îÄ‚îÄ database/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __pycache__/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ db_handler.cpython-311.pyc
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ models.cpython-311.pyc
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ db_handler.py
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ models.py
‚îÇ   ‚îú‚îÄ‚îÄ services/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __pycache__/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ crypto_api.cpython-311.pyc
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ signal_manager.cpython-311.pyc
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ trend_analyzer.cpython-311.pyc
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ crypto_api.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ signal_manager.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ tinyml_analyzer.py
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ trend_analyzer.py
‚îÇ   ‚îú‚îÄ‚îÄ utils/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __pycache__/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ chart_generator.cpython-311.pyc
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ logger.cpython-311.pyc
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ message_formatter.cpython-311.pyc
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ time_utils.cpython-311.pyc
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ chart_generator.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ logger.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ message_formatter.py
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ time_utils.py

================================================================================

Path: /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/config.py
File Name: config.py
Code:
# –¢–æ–∫–µ–Ω –≤–∞—à–µ–≥–æ –±–æ—Ç–∞
BOT_TOKEN = "7317150884:AAENXygTDLy3KGvLIh5CgxfqRRS69Rd2I1U"

# ID –∫–∞–Ω–∞–ª–∞ Telegram, –∫—É–¥–∞ –±–æ—Ç –±—É–¥–µ—Ç –æ—Ç–ø—Ä–∞–≤–ª—è—Ç—å —Å–æ–æ–±—â–µ–Ω–∏—è
CHANNEL_ID = "7317150884"

# –°–ø–∏—Å–æ–∫ –ø—Ä–æ–≤–µ—Ä—è–µ–º—ã—Ö –ø–∞—Ä
CRYPTO_PAIRS = ["BTC/USDT", "ETH/USDT", "ADA/USDT", "TON/USDT"]

# –ù–∞—Å—Ç—Ä–æ–π–∫–∏ API –±–∏—Ä–∂–∏
EXCHANGE_API_KEY = "MWpeIx2bRxJW9igMlA4LDb6i7JovQLM9CYYS5AfbD803JyQhWbPAgi2m9LsBE58k"
EXCHANGE_SECRET = "nxQoPTFVJeR1U6etHoKXtIFbvV5s3nSDOY5579PKVTeHZQcHJw5VZDtJ60JslMBh"

# –ù–∞—Å—Ç—Ä–æ–π–∫–∏ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö
DB_NAME = "price_trend_db.sqlite"

# –ù–∞—Å—Ç—Ä–æ–π–∫–∏ –ø–ª–∞–Ω–∏—Ä–æ–≤—â–∏–∫–∞
CHECK_INTERVAL = 1 * 60  # 15 –º–∏–Ω—É—Ç –≤ —Å–µ–∫—É–Ω–¥–∞—Ö

# –ß–∞—Å–æ–≤–æ–π –ø–æ—è—Å
TIMEZONE = "Europe/Moscow"
--------------------------------------------------------------------------------
Path: /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/requirements.txt
File Name: requirements.txt
Code:
pyTelegramBotAPI==4.14.0
ccxt==4.0.80
numpy==1.25.2
APScheduler==3.10.4
matplotlib==3.7.2
pytz==2023.3
tabulate==0.9.0
tensorflow==2.13.0
--------------------------------------------------------------------------------
Path: /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/Dockerfile
File Name: Dockerfile
Code:
FROM python:3.11-slim

WORKDIR /app

COPY requirements.txt .

RUN pip install --no-cache-dir -r requirements.txt

COPY . .

ENV PYTHONDONTWRITEBYTECODE=1
ENV PYTHONUNBUFFERED=1

CMD ["python", "main.py"]
--------------------------------------------------------------------------------
Path: /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/main.py
File Name: main.py
Code:
import logging
import asyncio
from bot.handlers import setup_bot
from database.db_handler import init_db

# –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è
logging.basicConfig(level=logging.INFO, format='%(asctime)s [%(levelname)s] %(message)s', handlers=[logging.StreamHandler()])

async def main():
    while True:
        try:
            # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö
            logging.info("–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö.")
            init_db()

            # –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –∏ –∑–∞–ø—É—Å–∫ –±–æ—Ç–∞
            bot = await setup_bot()
            logging.info("–ë–æ—Ç –Ω–∞—Å—Ç—Ä–æ–µ–Ω –∏ –≥–æ—Ç–æ–≤ –∫ –∑–∞–ø—É—Å–∫—É.")

            # –ó–∞–ø—É—Å–∫ –±–æ—Ç–∞
            await bot.infinity_polling()
        except Exception as e:
            logging.error(f"–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞: {e}")
            logging.info("–ü–µ—Ä–µ–∑–∞–ø—É—Å–∫ –±–æ—Ç–∞ —á–µ—Ä–µ–∑ 5 —Å–µ–∫—É–Ω–¥...")
            await asyncio.sleep(5)

if __name__ == "__main__":
    logging.info("–ó–∞–ø—É—Å–∫ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è.")
    asyncio.run(main())
--------------------------------------------------------------------------------
Path: /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/bot/scheduler.py
File Name: scheduler.py
Code:
from apscheduler.schedulers.asyncio import AsyncIOScheduler
import logging
import asyncio

scheduler = AsyncIOScheduler()

async def start_scheduler(job_func, chat_id):
    logging.info("–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –∏ –∑–∞–ø—É—Å–∫ –ø–ª–∞–Ω–∏—Ä–æ–≤—â–∏–∫–∞.")
    scheduler.add_job(lambda: asyncio.create_task(job_func(chat_id)), 'interval', seconds=60)
    scheduler.start()
    logging.info("–ü–ª–∞–Ω–∏—Ä–æ–≤—â–∏–∫ –∑–∞–ø—É—â–µ–Ω.")
    return scheduler

def update_scheduler_interval(new_interval, job_func, chat_id):
    global scheduler
    logging.info(f"–û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∏–Ω—Ç–µ—Ä–≤–∞–ª–∞ –ø–ª–∞–Ω–∏—Ä–æ–≤—â–∏–∫–∞ –Ω–∞ {new_interval} —Å–µ–∫—É–Ω–¥.")
    scheduler.remove_all_jobs()
    scheduler.add_job(lambda: asyncio.create_task(job_func(chat_id)), 'interval', seconds=new_interval)
    logging.info(f"–ò–Ω—Ç–µ—Ä–≤–∞–ª –ø–ª–∞–Ω–∏—Ä–æ–≤—â–∏–∫–∞ –æ–±–Ω–æ–≤–ª–µ–Ω –Ω–∞ {new_interval} —Å–µ–∫—É–Ω–¥.")

def stop_scheduler():
    global scheduler
    if scheduler.running:
        scheduler.shutdown()
        logging.info("–ü–ª–∞–Ω–∏—Ä–æ–≤—â–∏–∫ –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω.")
--------------------------------------------------------------------------------
Error reading /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/bot/__pycache__/scheduler.cpython-311.pyc: 'utf-8' codec can't decode byte 0xa7 in position 0: invalid start byte
Path: /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/bot/handlers/signals.py
File Name: signals.py
Code:
import logging
from telebot.async_telebot import AsyncTeleBot
from database.db_handler import get_active_signals, get_closed_signals, mark_signal_as_reported, get_signals_count
from utils.message_formatter import format_new_signal_message, format_closed_signal_message
from config import BOT_TOKEN
from .utils import send_signal_messages

bot = AsyncTeleBot(BOT_TOKEN)

@bot.message_handler(commands=['show'])
async def show_signals(message):
    logging.info("–ó–∞–ø—É—â–µ–Ω–∞ –∫–æ–º–∞–Ω–¥–∞ /show.")
    active_signals = get_active_signals()
    if not active_signals:
        logging.info("–ù–µ—Ç –∞–∫—Ç–∏–≤–Ω—ã—Ö —Å–∏–≥–Ω–∞–ª–æ–≤.")
        await bot.reply_to(message, "–í –¥–∞–Ω–Ω—ã–π –º–æ–º–µ–Ω—Ç –Ω–µ—Ç –∞–∫—Ç–∏–≤–Ω—ã—Ö —Å–∏–≥–Ω–∞–ª–æ–≤.")
    else:
        logging.info(f"–û—Ç–æ–±—Ä–∞–∂–µ–Ω–∏–µ {len(active_signals)} –∞–∫—Ç–∏–≤–Ω—ã—Ö —Å–∏–≥–Ω–∞–ª–æ–≤.")
        await send_signal_messages(bot, message.chat.id, active_signals, format_new_signal_message)

    closed_signals = get_closed_signals()
    if closed_signals:
        logging.info(f"–û—Ç–æ–±—Ä–∞–∂–µ–Ω–∏–µ {len(closed_signals)} –∑–∞–∫—Ä—ã—Ç—ã—Ö —Å–∏–≥–Ω–∞–ª–æ–≤.")
        await send_signal_messages(bot, message.chat.id, closed_signals, format_closed_signal_message)
        for signal in closed_signals:
            mark_signal_as_reported(signal[0])
        logging.info("–ó–∞–∫—Ä—ã—Ç—ã–µ —Å–∏–≥–Ω–∞–ª—ã –æ–±—Ä–∞–±–æ—Ç–∞–Ω—ã –∏ –æ—Ç–º–µ—á–µ–Ω—ã –∫–∞–∫ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–Ω—ã–µ.")
    else:
        logging.info("–ù–µ—Ç –∑–∞–∫—Ä—ã—Ç—ã—Ö —Å–∏–≥–Ω–∞–ª–æ–≤.")
        await bot.reply_to(message, "–í –¥–∞–Ω–Ω—ã–π –º–æ–º–µ–Ω—Ç –Ω–µ—Ç –∑–∞–∫—Ä—ã—Ç—ã—Ö —Å–∏–≥–Ω–∞–ª–æ–≤.")

@bot.message_handler(commands=['count'])
async def count_signals(message):
    logging.info("–ó–∞–ø—É—â–µ–Ω–∞ –∫–æ–º–∞–Ω–¥–∞ /count.")
    active_count, closed_count = get_signals_count()
    logging.info(f"–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –æ—Ç–∫—Ä—ã—Ç—ã—Ö —Å–∏–≥–Ω–∞–ª–æ–≤: {active_count}, –∑–∞–∫—Ä—ã—Ç—ã—Ö —Å–∏–≥–Ω–∞–ª–æ–≤: {closed_count}")
    await bot.reply_to(message, f"–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –æ—Ç–∫—Ä—ã—Ç—ã—Ö —Å–∏–≥–Ω–∞–ª–æ–≤: {active_count}\n–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –∑–∞–∫—Ä—ã—Ç—ã—Ö —Å–∏–≥–Ω–∞–ª–æ–≤: {closed_count}")
--------------------------------------------------------------------------------
Path: /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/bot/handlers/__init__.py
File Name: __init__.py
Code:
from .commands import bot

async def setup_bot():
    return bot
--------------------------------------------------------------------------------
Path: /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/bot/handlers/utils.py
File Name: utils.py
Code:
import io
import asyncio
from telebot.async_telebot import AsyncTeleBot
from database.models import Signal
from services.crypto_api import get_ohlcv
from utils.chart_generator import generate_chart
from database.db_handler import increment_count_sends
import logging

async def send_signal_messages(bot: AsyncTeleBot, chat_id, signals, format_message_func):
    logging.info(f"–ù–∞—á–∞—Ç–∞ –æ—Ç–ø—Ä–∞–≤–∫–∞ —Å–æ–æ–±—â–µ–Ω–∏–π –ø–æ {len(signals)} —Å–∏–≥–Ω–∞–ª–∞–º.")
    for signal_tuple in signals:
        signal = Signal(*signal_tuple)
        message_text = format_message_func(signal)
        try:
            ohlcv_data = get_ohlcv(signal.name)
            chart_buffer = generate_chart(ohlcv_data, signal.trend, signal.date_start, signal.date_end)
            chart_bytes = chart_buffer.getvalue()
            logging.info(f"–ì—Ä–∞—Ñ–∏–∫ –¥–ª—è {signal.name} —É—Å–ø–µ—à–Ω–æ —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω.")
        except Exception as e:
            logging.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –≥—Ä–∞—Ñ–∏–∫–∞ –¥–ª—è {signal.name}: {e}")
            chart_bytes = None

        for attempt in range(3):
            try:
                await asyncio.sleep(1)
                if chart_bytes:
                    sent_message = await bot.send_photo(chat_id, chart_bytes, caption=message_text)
                    logging.info(f"–°–æ–æ–±—â–µ–Ω–∏–µ —Å –≥—Ä–∞—Ñ–∏–∫–æ–º —É—Å–ø–µ—à–Ω–æ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ –≤ —á–∞—Ç {chat_id}: {sent_message.message_id}")
                else:
                    sent_message = await bot.send_message(chat_id, message_text)
                    logging.info(f"–¢–µ–∫—Å—Ç–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ –≤ —á–∞—Ç {chat_id}: {sent_message.message_id}")
                increment_count_sends(signal.name)
                break
            except Exception as e:
                logging.error(f"–û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ —Å–æ–æ–±—â–µ–Ω–∏—è –¥–ª—è —Å–∏–≥–Ω–∞–ª–∞ {signal.name} –Ω–∞ –ø–æ–ø—ã—Ç–∫–µ {attempt + 1}: {e}")
                if attempt < 2:
                    await asyncio.sleep(5)
                else:
                    logging.error(f"–ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å —Å–æ–æ–±—â–µ–Ω–∏–µ –¥–ª—è —Å–∏–≥–Ω–∞–ª–∞ {signal.name} –ø–æ—Å–ª–µ 3 –ø–æ–ø—ã—Ç–æ–∫.")
                    try:
                        sent_message = await bot.send_message(chat_id, message_text)
                        logging.info(f"–û—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ —Ç–µ–∫—Å—Ç–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –±–µ–∑ –≥—Ä–∞—Ñ–∏–∫–∞: {sent_message.message_id}")
                    except Exception as text_error:
                        logging.error(f"–ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å –¥–∞–∂–µ —Ç–µ–∫—Å—Ç–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ: {text_error}")
--------------------------------------------------------------------------------
Path: /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/bot/handlers/commands.py
File Name: commands.py
Code:
import logging
import asyncio
import os
from telebot.async_telebot import AsyncTeleBot
from config import BOT_TOKEN, CHECK_INTERVAL as CONFIG_CHECK_INTERVAL, CRYPTO_PAIRS
from database.db_handler import (
    delete_all_tables, get_signals_count, get_active_signals,
    get_closed_signals, mark_signal_as_reported, move_old_signals_to_history,
    fetch_all_signals, init_db
)
from utils.message_formatter import (
    format_new_signal_message, format_closed_signal_message,
    format_signals_table, add_timestamp_and_separator
)
from services.signal_manager import check_and_create_signals
from .utils import send_signal_messages
from utils.logger import setup_logging
from pathlib import Path

# –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –ª–æ–≥–≥–µ—Ä–æ–≤
general_logger, analyze_logger = setup_logging()

bot = AsyncTeleBot(BOT_TOKEN)
CHECK_INTERVAL = CONFIG_CHECK_INTERVAL
actual_send_enabled = True
check_task = None


async def perform_check(chat_id=None):
    try:
        analyze_logger.info("–ù–∞—á–∞–ª–æ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è perform_check().")
        new_signals, updated_signals, closed_signals = check_and_create_signals(CRYPTO_PAIRS)

        if chat_id:
            if actual_send_enabled:
                if new_signals:
                    analyze_logger.info(f"–ü–æ–ª—É—á–µ–Ω–æ {len(new_signals)} –Ω–æ–≤—ã—Ö —Å–∏–≥–Ω–∞–ª–æ–≤.")
                    await send_signal_messages(bot, chat_id, new_signals, format_new_signal_message,
                                               is_new=True)

                if closed_signals:
                    analyze_logger.info(f"–ü–æ–ª—É—á–µ–Ω–æ {len(closed_signals)} –∑–∞–∫—Ä—ã—Ç—ã—Ö —Å–∏–≥–Ω–∞–ª–æ–≤.")
                    await send_signal_messages(bot, chat_id, closed_signals,
                                               format_closed_signal_message)
                    for signal in closed_signals:
                        mark_signal_as_reported(signal[0])
                    analyze_logger.info("–û–±—Ä–∞–±–æ—Ç–∞–Ω—ã –∑–∞–∫—Ä—ã—Ç—ã–µ —Å–∏–≥–Ω–∞–ª—ã.")

            if updated_signals and not actual_send_enabled:
                analyze_logger.info(f"–û–±–Ω–æ–≤–ª–µ–Ω–æ {len(updated_signals)} –∞–∫—Ç–∏–≤–Ω—ã—Ö —Å–∏–≥–Ω–∞–ª–æ–≤.")

        move_old_signals_to_history()
        analyze_logger.info("–ó–∞–≤–µ—Ä—à–µ–Ω–æ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏–µ perform_check().")
    except Exception as e:
        general_logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏–∏ perform_check: {e}")


async def start_scheduler(interval, chat_id):
    while True:
        await perform_check(chat_id)
        await asyncio.sleep(interval)


@bot.message_handler(commands=['delete_tables'])
async def delete_tables(message):
    general_logger.info("–ó–∞–ø—É—â–µ–Ω–∞ –∫–æ–º–∞–Ω–¥–∞ /delete_tables.")
    delete_all_tables()
    init_db()
    await bot.reply_to(message, "–í—Å–µ —Ç–∞–±–ª–∏—Ü—ã –±—ã–ª–∏ —É–¥–∞–ª–µ–Ω—ã –∏ –∑–∞–Ω–æ–≤–æ —Å–æ–∑–¥–∞–Ω—ã.")
    general_logger.info("–í—Å–µ —Ç–∞–±–ª–∏—Ü—ã —É–¥–∞–ª–µ–Ω—ã –∏ –∑–∞–Ω–æ–≤–æ —Å–æ–∑–¥–∞–Ω—ã.")


@bot.message_handler(commands=['count'])
async def count_signals(message):
    general_logger.info("–ó–∞–ø—É—â–µ–Ω–∞ –∫–æ–º–∞–Ω–¥–∞ /count.")
    active_count, closed_count = get_signals_count()
    await bot.reply_to(message,
                       f"–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –æ—Ç–∫—Ä—ã—Ç—ã—Ö —Å–∏–≥–Ω–∞–ª–æ–≤: {active_count}\n"
                       f"–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –∑–∞–∫—Ä—ã—Ç—ã—Ö —Å–∏–≥–Ω–∞–ª–æ–≤: {closed_count}")
    general_logger.info(
        f"–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –æ—Ç–∫—Ä—ã—Ç—ã—Ö —Å–∏–≥–Ω–∞–ª–æ–≤: {active_count}, –∑–∞–∫—Ä—ã—Ç—ã—Ö —Å–∏–≥–Ω–∞–ª–æ–≤: {closed_count}")


@bot.message_handler(commands=['show'])
async def show_signals(message):
    general_logger.info("–ó–∞–ø—É—â–µ–Ω–∞ –∫–æ–º–∞–Ω–¥–∞ /show.")
    active_signals = get_active_signals()
    if not active_signals:
        general_logger.info("–ù–µ—Ç –∞–∫—Ç–∏–≤–Ω—ã—Ö —Å–∏–≥–Ω–∞–ª–æ–≤.")
        await bot.reply_to(message, "–í –¥–∞–Ω–Ω—ã–π –º–æ–º–µ–Ω—Ç –Ω–µ—Ç –∞–∫—Ç–∏–≤–Ω—ã—Ö —Å–∏–≥–Ω–∞–ª–æ–≤.")
    else:
        await send_signal_messages(bot, message.chat.id, active_signals, format_new_signal_message)

    closed_signals = get_closed_signals()
    if closed_signals:
        await send_signal_messages(bot, message.chat.id, closed_signals,
                                   format_closed_signal_message)
        for signal in closed_signals:
            mark_signal_as_reported(signal[0])
        general_logger.info("–ó–∞–∫—Ä—ã—Ç—ã–µ —Å–∏–≥–Ω–∞–ª—ã –æ–±—Ä–∞–±–æ—Ç–∞–Ω—ã –∏ –æ—Ç–º–µ—á–µ–Ω—ã –∫–∞–∫ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–Ω—ã–µ.")
    else:
        general_logger.info("–ù–µ—Ç –∑–∞–∫—Ä—ã—Ç—ã—Ö —Å–∏–≥–Ω–∞–ª–æ–≤.")
        await bot.reply_to(message, "–í –¥–∞–Ω–Ω—ã–π –º–æ–º–µ–Ω—Ç –Ω–µ—Ç –∑–∞–∫—Ä—ã—Ç—ã—Ö —Å–∏–≥–Ω–∞–ª–æ–≤.")


@bot.message_handler(commands=['table_signals'])
async def table_signals(message):
    general_logger.info("–ó–∞–ø—É—â–µ–Ω–∞ –∫–æ–º–∞–Ω–¥–∞ /table_signals.")
    signals = fetch_all_signals()
    if not signals:
        await bot.reply_to(message, "–¢–∞–±–ª–∏—Ü–∞ `signals` –ø—É—Å—Ç–∞.")
        general_logger.info("–¢–∞–±–ª–∏—Ü–∞ `signals` –ø—É—Å—Ç–∞.")
    else:
        table_message = format_signals_table(signals)
        table_message = add_timestamp_and_separator(table_message)
        await bot.reply_to(message, table_message)
        general_logger.info("–¢–∞–±–ª–∏—Ü–∞ `signals` –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–∞.")


@bot.message_handler(commands=['actual_send'])
async def toggle_actual_send(message):
    global actual_send_enabled
    actual_send_enabled = not actual_send_enabled
    status = "–≤–∫–ª—é—á–µ–Ω–∞" if actual_send_enabled else "–≤—ã–∫–ª—é—á–µ–Ω–∞"
    response = f"–û—Ç–ø—Ä–∞–≤–∫–∞ –Ω–æ–≤—ã—Ö –∏ –∑–∞–∫—Ä—ã—Ç—ã—Ö —Å–∏–≥–Ω–∞–ª–æ–≤ {status}. –ê–∫—Ç—É–∞–ª—å–Ω—ã–µ —Å–∏–≥–Ω–∞–ª—ã –Ω–µ –±—É–¥—É—Ç –æ—Ç–ø—Ä–∞–≤–ª—è—Ç—å—Å—è."
    response = add_timestamp_and_separator(response)
    await bot.reply_to(message, response)
    general_logger.info(f"–û—Ç–ø—Ä–∞–≤–∫–∞ –Ω–æ–≤—ã—Ö –∏ –∑–∞–∫—Ä—ã—Ç—ã—Ö —Å–∏–≥–Ω–∞–ª–æ–≤ {status}.")


@bot.message_handler(commands=['interval'])
async def change_interval(message):
    global CHECK_INTERVAL, check_task
    args = message.text.split()
    if len(args) == 1:
        minutes = CHECK_INTERVAL // 60
        response = f"–¢–µ–∫—É—â–∏–π –∏–Ω—Ç–µ—Ä–≤–∞–ª –ø—Ä–æ–≤–µ—Ä–∫–∏: {minutes} –º–∏–Ω—É—Ç. –ß—Ç–æ–±—ã –∏–∑–º–µ–Ω–∏—Ç—å, –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ /interval <—á–∏—Å–ª–æ –º–∏–Ω—É—Ç>"
        response = add_timestamp_and_separator(response)
        await bot.reply_to(message, response)
        general_logger.info(f"–°–æ–æ–±—â–µ–Ω–∏–µ –æ —Ç–µ–∫—É—â–µ–º –∏–Ω—Ç–µ—Ä–≤–∞–ª–µ –ø—Ä–æ–≤–µ—Ä–∫–∏ ({minutes} –º–∏–Ω—É—Ç) –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ.")
    elif len(args) == 2:
        try:
            new_interval_minutes = int(args[1])
            if new_interval_minutes < 1:
                await bot.reply_to(message, "–ò–Ω—Ç–µ—Ä–≤–∞–ª –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –º–µ–Ω—å—à–µ 1 –º–∏–Ω—É—Ç—ã")
                general_logger.info("–û—à–∏–±–∫–∞: –≤–≤–µ–¥–µ–Ω –∏–Ω—Ç–µ—Ä–≤–∞–ª –º–µ–Ω—å—à–µ 1 –º–∏–Ω—É—Ç—ã.")
            else:
                CHECK_INTERVAL = new_interval_minutes * 60
                response = f"–ò–Ω—Ç–µ—Ä–≤–∞–ª –ø—Ä–æ–≤–µ—Ä–∫–∏ –∏–∑–º–µ–Ω–µ–Ω –Ω–∞ {new_interval_minutes} –º–∏–Ω—É—Ç"
                response = add_timestamp_and_separator(response)
                await bot.reply_to(message, response)
                general_logger.info(f"–ò–Ω—Ç–µ—Ä–≤–∞–ª –ø—Ä–æ–≤–µ—Ä–∫–∏ –∏–∑–º–µ–Ω–µ–Ω –Ω–∞ {new_interval_minutes} –º–∏–Ω—É—Ç.")

                if check_task and not check_task.done():
                    check_task.cancel()
                    try:
                        await check_task
                    except asyncio.CancelledError:
                        pass

                check_task = asyncio.create_task(start_scheduler(CHECK_INTERVAL, message.chat.id))
                general_logger.info("–ó–∞–¥–∞—á–∞ —Å –æ–±–Ω–æ–≤–ª–µ–Ω–Ω—ã–º –∏–Ω—Ç–µ—Ä–≤–∞–ª–æ–º —É—Å–ø–µ—à–Ω–æ –∑–∞–ø—É—â–µ–Ω–∞.")
        except ValueError:
            await bot.reply_to(message, "–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–≤–µ–¥–∏—Ç–µ –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ–µ —á–∏—Å–ª–æ –º–∏–Ω—É—Ç")
            general_logger.info("–û—à–∏–±–∫–∞: –≤–≤–µ–¥–µ–Ω–æ –Ω–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –∏–Ω—Ç–µ—Ä–≤–∞–ª–∞.")


@bot.message_handler(commands=['start'])
async def start_bot(message):
    global check_task
    if check_task is None or check_task.done():
        general_logger.info("–ó–∞–ø—É—Å–∫ –±–æ—Ç–∞.")
        response = "–ó–∞–ø—É—Å–∫ –±–æ—Ç–∞..."
        response = add_timestamp_and_separator(response)
        await bot.reply_to(message, response)
        check_task = asyncio.create_task(start_scheduler(CHECK_INTERVAL, message.chat.id))
        general_logger.info("–ü–µ—Ä–∏–æ–¥–∏—á–µ—Å–∫–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ –∑–∞–ø—É—â–µ–Ω–∞.")
    else:
        general_logger.info("–ë–æ—Ç —É–∂–µ –∑–∞–ø—É—â–µ–Ω.")
        response = "–ë–æ—Ç —É–∂–µ –∑–∞–ø—É—â–µ–Ω."
        response = add_timestamp_and_separator(response)
        await bot.reply_to(message, response)


@bot.message_handler(commands=['stop'])
async def stop_bot(message):
    global check_task
    if check_task and not check_task.done():
        check_task.cancel()
        try:
            await check_task
        except asyncio.CancelledError:
            pass
        check_task = None
        general_logger.info("–ë–æ—Ç –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω. –ü–µ—Ä–∏–æ–¥–∏—á–µ—Å–∫–∏–µ –ø—Ä–æ–≤–µ—Ä–∫–∏ –¥–µ–∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω—ã.")
        response = "–ë–æ—Ç –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω. –ü–µ—Ä–∏–æ–¥–∏—á–µ—Å–∫–∏–µ –ø—Ä–æ–≤–µ—Ä–∫–∏ –¥–µ–∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω—ã."
        response = add_timestamp_and_separator(response)
        await bot.reply_to(message, response)
    else:
        general_logger.info("–ë–æ—Ç –Ω–µ –∑–∞–ø—É—â–µ–Ω.")
        response = "–ë–æ—Ç –Ω–µ –∑–∞–ø—É—â–µ–Ω."
        response = add_timestamp_and_separator(response)
        await bot.reply_to(message, response)


@bot.message_handler(commands=['help'])
async def send_help(message):
    general_logger.info("–û—Ç–ø—Ä–∞–≤–∫–∞ —Å–ø—Ä–∞–≤–æ—á–Ω–æ–π –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏.")
    help_text = """
    –î–æ—Å—Ç—É–ø–Ω—ã–µ –∫–æ–º–∞–Ω–¥—ã:
    /start - –ó–∞–ø—É—Å—Ç–∏—Ç—å –±–æ—Ç–∞ –∏ –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞—Ç—å –ø–µ—Ä–∏–æ–¥–∏—á–µ—Å–∫–∏–µ –ø—Ä–æ–≤–µ—Ä–∫–∏
    /stop - –û—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –±–æ—Ç–∞ –∏ –¥–µ–∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞—Ç—å –ø–µ—Ä–∏–æ–¥–∏—á–µ—Å–∫–∏–µ –ø—Ä–æ–≤–µ—Ä–∫–∏
    /show - –ü–æ–∫–∞–∑–∞—Ç—å —Ç–µ–∫—É—â–∏–µ –∞–∫—Ç–∏–≤–Ω—ã–µ –∏ –∑–∞–∫—Ä—ã—Ç—ã–µ —Å–∏–≥–Ω–∞–ª—ã
    /count - –ü–æ–∫–∞–∑–∞—Ç—å –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –æ—Ç–∫—Ä—ã—Ç—ã—Ö –∏ –∑–∞–∫—Ä—ã—Ç—ã—Ö —Å–∏–≥–Ω–∞–ª–æ–≤
    /delete_tables - –£–¥–∞–ª–∏—Ç—å –≤—Å–µ —Ç–∞–±–ª–∏—Ü—ã –≤ –±–∞–∑–µ –¥–∞–Ω–Ω—ã—Ö (–∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ —Å –æ—Å—Ç–æ—Ä–æ–∂–Ω–æ—Å—Ç—å—é!)
    /table_signals - –ü–æ–∫–∞–∑–∞—Ç—å —Å–æ–¥–µ—Ä–∂–∏–º–æ–µ —Ç–∞–±–ª–∏—Ü—ã `signals`
    /help - –ü–æ–∫–∞–∑–∞—Ç—å —ç—Ç–æ —Å–æ–æ–±—â–µ–Ω–∏–µ –ø–æ–º–æ—â–∏
    /interval - –ò–∑–º–µ–Ω–∏—Ç—å –∏–Ω—Ç–µ—Ä–≤–∞–ª –ø—Ä–æ–≤–µ—Ä–∫–∏ –∏–ª–∏ –ø–æ–∫–∞–∑–∞—Ç—å —Ç–µ–∫—É—â–∏–π –∏–Ω—Ç–µ—Ä–≤–∞–ª
    /actual_send - –í–∫–ª—é—á–∏—Ç—å/–≤—ã–∫–ª—é—á–∏—Ç—å –æ—Ç–ø—Ä–∞–≤–∫—É –∞–∫—Ç—É–∞–ª—å–Ω—ã—Ö —Å–∏–≥–Ω–∞–ª–æ–≤
    /logs - –ü–æ–∫–∞–∑–∞—Ç—å —Ñ–∞–π–ª—ã –ª–æ–≥–æ–≤
    /delete_logs - –£–¥–∞–ª–∏—Ç—å –≤—Å–µ —Ñ–∞–π–ª—ã –ª–æ–≥–æ–≤ (–∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ —Å –æ—Å—Ç–æ—Ä–æ–∂–Ω–æ—Å—Ç—å—é!)
    """
    help_text = add_timestamp_and_separator(help_text)
    await bot.reply_to(message, help_text)
    general_logger.info("–°–ø—Ä–∞–≤–æ—á–Ω–∞—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–∞.")


@bot.message_handler(commands=['logs'])
async def send_logs(message):
    general_logger.info("–ó–∞–ø—Ä–æ—Å –ª–æ–≥–æ–≤ —á–µ—Ä–µ–∑ –∫–æ–º–∞–Ω–¥—É /logs")
    try:
        log_dir = Path(__file__).parents[2] / 'logs'
        with open(log_dir / 'general.log', 'rb') as general_log, open(log_dir / 'analyze.log',
                                                                      'rb') as analyze_log:
            await bot.send_document(message.chat.id, general_log, caption="–û–±—â–∏–π –ª–æ–≥")
            await bot.send_document(message.chat.id, analyze_log, caption="–õ–æ–≥ –∞–Ω–∞–ª–∏–∑–∞")
    except Exception as e:
        general_logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–ø—Ä–∞–≤–∫–µ –ª–æ–≥–æ–≤: {e}")
        response = "–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–ø—Ä–∞–≤–∫–µ –ª–æ–≥–æ–≤."
        response = add_timestamp_and_separator(response)
        await bot.reply_to(message, response)


@bot.message_handler(commands=['delete_logs'])
async def delete_logs(message):
    general_logger.info("–ó–∞–ø—É—â–µ–Ω–∞ –∫–æ–º–∞–Ω–¥–∞ /delete_logs")
    try:
        log_dir = Path(__file__).parents[2] / 'logs'
        deleted_files = 0
        for file in os.listdir(log_dir):
            if file.endswith(".log"):
                os.remove(os.path.join(log_dir, file))
                deleted_files += 1

        # –°–æ–∑–¥–∞–µ–º –Ω–æ–≤—ã–µ –ø—É—Å—Ç—ã–µ —Ñ–∞–π–ª—ã –ª–æ–≥–æ–≤
        open(log_dir / 'general.log', 'w').close()
        open(log_dir / 'analyze.log', 'w').close()

        # –ü–µ—Ä–µ–∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º –ª–æ–≥–≥–µ—Ä—ã
        new_general_logger, new_analyze_logger = setup_logging()

        # –û–±–Ω–æ–≤–ª—è–µ–º –≥–ª–æ–±–∞–ª—å–Ω—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –≤ –º–æ–¥—É–ª–µ utils.logger
        import utils.logger
        utils.logger.general_logger = new_general_logger
        utils.logger.analyze_logger = new_analyze_logger

        response = f"–£–¥–∞–ª–µ–Ω–æ —Ñ–∞–π–ª–æ–≤ –ª–æ–≥–æ–≤: {deleted_files}. –°–æ–∑–¥–∞–Ω—ã –Ω–æ–≤—ã–µ –ø—É—Å—Ç—ã–µ —Ñ–∞–π–ª—ã –ª–æ–≥–æ–≤."
        response = add_timestamp_and_separator(response)
        await bot.reply_to(message, response)
        new_general_logger.info(
            f"–£–¥–∞–ª–µ–Ω–æ {deleted_files} —Ñ–∞–π–ª–æ–≤ –ª–æ–≥–æ–≤. –°–æ–∑–¥–∞–Ω—ã –Ω–æ–≤—ã–µ –ø—É—Å—Ç—ã–µ —Ñ–∞–π–ª—ã.")
    except Exception as e:
        general_logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ —É–¥–∞–ª–µ–Ω–∏–∏ –ª–æ–≥–æ–≤: {e}")
        response = "–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ —É–¥–∞–ª–µ–Ω–∏–∏ –ª–æ–≥–æ–≤."
        response = add_timestamp_and_separator(response)
        await bot.reply_to(message, response)
--------------------------------------------------------------------------------
Path: /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/bot/handlers/periodic_tasks.py
File Name: periodic_tasks.py
Code:
from datetime import datetime
from pytz import timezone
from config import CRYPTO_PAIRS, TIMEZONE
from services.signal_manager import check_and_create_signals
from utils.message_formatter import format_new_signal_message, format_closed_signal_message
from database.db_handler import mark_signal_as_reported
from utils.logger import analyze_logger, general_logger
from bot.handlers.commands import actual_send_enabled, bot
from .utils import send_signal_messages

async def perform_check(chat_id=None):
    try:
        analyze_logger.info("–ù–∞—á–∞–ª–æ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è perform_check().")
        new_signals, updated_signals, closed_signals = check_and_create_signals(CRYPTO_PAIRS)

        if chat_id:
            current_time = datetime.now(timezone(TIMEZONE)).strftime("%Y-%m-%d %H:%M")
            separator = "-" * 40
            await bot.send_message(chat_id, f"{current_time}\n{separator}")

            if actual_send_enabled:
                if new_signals:
                    analyze_logger.info(f"–ü–æ–ª—É—á–µ–Ω–æ {len(new_signals)} –Ω–æ–≤—ã—Ö —Å–∏–≥–Ω–∞–ª–æ–≤.")
                    await send_signal_messages(bot, chat_id, new_signals, format_new_signal_message)

                if closed_signals:
                    analyze_logger.info(f"–ü–æ–ª—É—á–µ–Ω–æ {len(closed_signals)} –∑–∞–∫—Ä—ã—Ç—ã—Ö —Å–∏–≥–Ω–∞–ª–æ–≤.")
                    await send_signal_messages(bot, chat_id, closed_signals, format_closed_signal_message)
                    for signal in closed_signals:
                        mark_signal_as_reported(signal[0])
                    analyze_logger.info("–û–±—Ä–∞–±–æ—Ç–∞–Ω—ã –∑–∞–∫—Ä—ã—Ç—ã–µ —Å–∏–≥–Ω–∞–ª—ã.")

            if updated_signals and not actual_send_enabled:
                analyze_logger.info(f"–û–±–Ω–æ–≤–ª–µ–Ω–æ {len(updated_signals)} –∞–∫—Ç–∏–≤–Ω—ã—Ö —Å–∏–≥–Ω–∞–ª–æ–≤.")

        analyze_logger.info("–ó–∞–≤–µ—Ä—à–µ–Ω–æ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏–µ perform_check().")
    except Exception as e:
        general_logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏–∏ perform_check: {e}")
--------------------------------------------------------------------------------
Error reading /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/bot/handlers/__pycache__/signals.cpython-311.pyc: 'utf-8' codec can't decode byte 0xa7 in position 0: invalid start byte
Error reading /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/bot/handlers/__pycache__/utils.cpython-311.pyc: 'utf-8' codec can't decode byte 0xa7 in position 0: invalid start byte
Error reading /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/bot/handlers/__pycache__/commands.cpython-311.pyc: 'utf-8' codec can't decode byte 0xa7 in position 0: invalid start byte
Error reading /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/bot/handlers/__pycache__/__init__.cpython-311.pyc: 'utf-8' codec can't decode byte 0xa7 in position 0: invalid start byte
Error reading /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/bot/handlers/__pycache__/periodic_tasks.cpython-311.pyc: 'utf-8' codec can't decode byte 0xa7 in position 0: invalid start byte
Path: /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/database/models.py
File Name: models.py
Code:
from dataclasses import dataclass

@dataclass
class Signal:
    id: int
    name: str
    trend: str
    date_start: str
    date_last: str
    accuracy: float
    date_end: str
    price_start: float
    price_last: float
    price_end: float
    count_sends: int
    reported: int
--------------------------------------------------------------------------------
Path: /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/database/db_handler.py
File Name: db_handler.py
Code:
import sqlite3
from config import DB_NAME

def init_db():
    conn = sqlite3.connect(DB_NAME)
    c = conn.cursor()

    c.execute('''CREATE TABLE IF NOT EXISTS signals
                 (id INTEGER PRIMARY KEY AUTOINCREMENT,
                  name TEXT,
                  trend TEXT,
                  date_start TEXT,
                  date_last TEXT,
                  accuracy INTEGER CHECK(accuracy >= 1 AND accuracy <= 100),
                  date_end TEXT,
                  price_start REAL,
                  price_last REAL,
                  price_end REAL,
                  count_sends INTEGER,
                  reported INTEGER DEFAULT 0)''')

    c.execute('''CREATE TABLE IF NOT EXISTS history
                 (id INTEGER PRIMARY KEY AUTOINCREMENT,
                  name TEXT,
                  trend TEXT,
                  date_start TEXT,
                  date_last TEXT,
                  accuracy INTEGER CHECK(accuracy >= 1 AND accuracy <= 100),
                  date_end TEXT,
                  price_start REAL,
                  price_last REAL,
                  price_end REAL,
                  count_sends INTEGER,
                  reported INTEGER)''')

    conn.commit()
    conn.close()

def delete_all_tables():
    conn = sqlite3.connect(DB_NAME)
    c = conn.cursor()

    c.execute("DROP TABLE IF EXISTS signals")
    c.execute("DROP TABLE IF EXISTS history")

    conn.commit()
    conn.close()

def insert_signal(name, trend, date_start, price_start, accuracy):
    conn = sqlite3.connect(DB_NAME)
    c = conn.cursor()

    c.execute('''SELECT * FROM signals 
                 WHERE name = ? AND date_end IS NULL''', (name,))
    existing_signal = c.fetchone()

    if not existing_signal:
        accuracy = max(1, min(100, int(accuracy)))
        c.execute('''INSERT INTO signals 
                     (name, trend, date_start, date_last, accuracy, price_start, price_last, count_sends)
                     VALUES (?, ?, ?, ?, ?, ?, ?, ?)''',
                  (name, trend, date_start, date_start, accuracy, price_start, price_start, 0))

    conn.commit()
    conn.close()

def update_signal(name, date_last, price_last, accuracy):
    conn = sqlite3.connect(DB_NAME)
    c = conn.cursor()
    accuracy = max(1, min(100, int(accuracy)))
    c.execute('''UPDATE signals
                 SET date_last = ?, price_last = ?, accuracy = ?
                 WHERE name = ? AND date_end IS NULL''',
              (date_last, price_last, accuracy, name))
    conn.commit()
    conn.close()

def increment_count_sends(name):
    conn = sqlite3.connect(DB_NAME)
    c = conn.cursor()
    c.execute('''UPDATE signals
                 SET count_sends = CASE
                     WHEN count_sends IS NULL THEN 1
                     ELSE count_sends + 1
                 END
                 WHERE name = ? AND date_end IS NULL''', (name,))
    conn.commit()
    conn.close()

def get_active_signals():
    conn = sqlite3.connect(DB_NAME)
    c = conn.cursor()
    c.execute('''SELECT id, name, trend, date_start, date_last, accuracy, date_end, 
                 price_start, price_last, price_end, count_sends, reported 
                 FROM signals WHERE date_end IS NULL''')
    signals = c.fetchall()
    conn.close()
    return signals

def get_closed_signals():
    conn = sqlite3.connect(DB_NAME)
    c = conn.cursor()
    c.execute('''SELECT id, name, trend, date_start, date_last, accuracy, date_end, 
                 price_start, price_last, price_end, count_sends, reported 
                 FROM signals 
                 WHERE date_end IS NOT NULL 
                 AND reported = 0''')
    signals = c.fetchall()
    conn.close()
    return signals

def close_signal(name, date_end, price_end):
    conn = sqlite3.connect(DB_NAME)
    c = conn.cursor()
    c.execute('''UPDATE signals
                 SET date_end = ?, price_end = ?
                 WHERE name = ? AND date_end IS NULL''',
              (date_end, price_end, name))
    conn.commit()
    conn.close()

def mark_signal_as_reported(signal_id):
    conn = sqlite3.connect(DB_NAME)
    c = conn.cursor()
    c.execute('''UPDATE signals
                 SET reported = 1
                 WHERE id = ?''', (signal_id,))
    conn.commit()
    conn.close()

def move_old_signals_to_history():
    conn = sqlite3.connect(DB_NAME)
    c = conn.cursor()
    c.execute('''INSERT INTO history
                 SELECT * FROM signals
                 WHERE date_end IS NOT NULL 
                 AND reported = 1''')
    c.execute('''DELETE FROM signals
                 WHERE date_end IS NOT NULL 
                 AND reported = 1''')
    conn.commit()
    conn.close()

def get_signals_count():
    conn = sqlite3.connect(DB_NAME)
    c = conn.cursor()
    c.execute("SELECT COUNT(*) FROM signals WHERE date_end IS NULL")
    active_count = c.fetchone()[0]
    c.execute("SELECT COUNT(*) FROM signals WHERE date_end IS NOT NULL")
    closed_count = c.fetchone()[0]
    conn.close()
    return active_count, closed_count

def fetch_all_signals():
    conn = sqlite3.connect(DB_NAME)
    c = conn.cursor()
    c.execute("SELECT * FROM signals")
    signals = c.fetchall()
    conn.close()
    return signals
--------------------------------------------------------------------------------
Error reading /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/database/__pycache__/models.cpython-311.pyc: 'utf-8' codec can't decode byte 0xa7 in position 0: invalid start byte
Error reading /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/database/__pycache__/db_handler.cpython-311.pyc: 'utf-8' codec can't decode byte 0xa7 in position 0: invalid start byte
Path: /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/services/crypto_api.py
File Name: crypto_api.py
Code:
import ccxt
from config import EXCHANGE_API_KEY, EXCHANGE_SECRET

exchange = ccxt.binance({
    'apiKey': EXCHANGE_API_KEY,
    'secret': EXCHANGE_SECRET,
})

def get_ohlcv(symbol, timeframe='1h', limit=48):
    try:
        ohlcv = exchange.fetch_ohlcv(symbol, timeframe, limit=limit)
        return ohlcv
    except Exception as e:
        print(f"Error fetching OHLCV data: {e}")
        return None

def get_current_price(symbol):
    try:
        ticker = exchange.fetch_ticker(symbol)
        return ticker['last']
    except Exception as e:
        print(f"Error fetching current price: {e}")
        return None
--------------------------------------------------------------------------------
Path: /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/services/signal_manager.py
File Name: signal_manager.py
Code:
from database.db_handler import insert_signal, update_signal, close_signal, get_active_signals
from services.crypto_api import get_ohlcv, get_current_price
from services.trend_analyzer import analyze_trend, is_trend_still_valid
from utils.time_utils import get_current_time
import logging


def check_and_create_signals(crypto_pairs):
    logging.info("–ü—Ä–æ–≤–µ—Ä–∫–∞ –∏ —Å–æ–∑–¥–∞–Ω–∏–µ –Ω–æ–≤—ã—Ö —Å–∏–≥–Ω–∞–ª–æ–≤.")
    new_signals = []
    updated_signals = []
    closed_signals = []

    for pair in crypto_pairs:
        logging.info(f"–ü—Ä–æ–≤–µ—Ä–∫–∞ –ø–∞—Ä—ã: {pair}")
        ohlcv = get_ohlcv(pair)
        if ohlcv:
            trend, accuracy = analyze_trend(ohlcv)
            if trend:
                logging.info(f"–û–±–Ω–∞—Ä—É–∂–µ–Ω –Ω–æ–≤—ã–π —Ç—Ä–µ–Ω–¥ –¥–ª—è –ø–∞—Ä—ã {pair}: {trend} —Å —Ç–æ—á–Ω–æ—Å—Ç—å—é {accuracy}.")
                current_price = get_current_price(pair)
                current_time = get_current_time()
                insert_signal(pair, trend, current_time, current_price, accuracy)
                new_signals.append((pair, trend, accuracy))
        else:
            logging.warning(f"–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –¥–∞–Ω–Ω—ã–µ OHLCV –¥–ª—è –ø–∞—Ä—ã {pair}. –ü—Ä–æ–ø—É—Å–∫.")

    return new_signals, updated_signals, closed_signals

def update_active_signals():
    logging.info("–û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∞–∫—Ç–∏–≤–Ω—ã—Ö —Å–∏–≥–Ω–∞–ª–æ–≤.")
    active_signals = get_active_signals()
    for signal in active_signals:
        pair = signal[1]
        logging.info(f"–ê–∫—Ç—É–∞–ª–∏–∑–∞—Ü–∏—è —Å–∏–≥–Ω–∞–ª–∞ –¥–ª—è –ø–∞—Ä—ã: {pair}")
        ohlcv = get_ohlcv(pair)
        if ohlcv:
            if is_trend_still_valid(ohlcv, signal[2]):
                logging.info(f"–°–∏–≥–Ω–∞–ª –¥–ª—è –ø–∞—Ä—ã {pair} –≤—Å—ë –µ—â—ë –∞–∫—Ç—É–∞–ª–µ–Ω.")
                current_price = get_current_price(pair)
                current_time = get_current_time()
                _, accuracy = analyze_trend(ohlcv)
                update_signal(pair, current_time, current_price, accuracy)
            else:
                logging.info(f"–°–∏–≥–Ω–∞–ª –¥–ª—è –ø–∞—Ä—ã {pair} –±–æ–ª—å—à–µ –Ω–µ –∞–∫—Ç—É–∞–ª–µ–Ω.")
                current_price = get_current_price(pair)
                current_time = get_current_time()
                close_signal(pair, current_time, current_price)
        else:
            logging.warning(f"–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –¥–∞–Ω–Ω—ã–µ OHLCV –¥–ª—è –ø–∞—Ä—ã {pair}. –ü—Ä–æ–ø—É—Å–∫.")
--------------------------------------------------------------------------------
Path: /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/services/trend_analyzer.py
File Name: trend_analyzer.py
Code:
import numpy as np

def analyze_trend(ohlcv_data):
    if not ohlcv_data:
        return None, 0

    closes = np.array([x[4] for x in ohlcv_data])
    ma_short = np.mean(closes[-12:])  # 12-hour moving average
    ma_long = np.mean(closes)  # 48-hour moving average

    if ma_short > ma_long:
        trend = "long"
    elif ma_short < ma_long:
        trend = "short"
    else:
        trend = None

    # –†–∞—Å—á–µ—Ç accuracy
    diff = abs(ma_short - ma_long)
    max_diff = max(closes) - min(closes)
    accuracy = int((1 - diff / max_diff) * 100) if max_diff != 0 else 50
    accuracy = max(1, min(100, accuracy))  # –£–±–µ–¥–∏–º—Å—è, —á—Ç–æ accuracy –≤ –ø—Ä–µ–¥–µ–ª–∞—Ö –æ—Ç 1 –¥–æ 100

    return trend, accuracy

def is_trend_still_valid(ohlcv_data, current_trend):
    new_trend, _ = analyze_trend(ohlcv_data)
    return new_trend == current_trend
--------------------------------------------------------------------------------
Path: /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/services/tinyml_analyzer.py
File Name: tinyml_analyzer.py
Code:
import tensorflow as tf

# –ó–∞–≥—Ä—É–∑–∫–∞ –º–æ–¥–µ–ª–∏ TinyML
model = tf.lite.Interpreter(model_path="path/to/your/tinyml_model.tflite")
model.allocate_tensors()

def analyze_with_tinyml(data):
    input_details = model.get_input_details()
    output_details = model.get_output_details()

    model.set_tensor(input_details[0]['index'], data)
    model.invoke()
    output = model.get_tensor(output_details[0]['index'])

    return output

# –§—É–Ω–∫—Ü–∏–∏ –¥–ª—è –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏–∏ TinyML –≤ —Å—É—â–µ—Å—Ç–≤—É—é—â—É—é –ª–æ–≥–∏–∫—É –∞–Ω–∞–ª–∏–∑–∞
def should_open_signal(ohlcv_data):
    # –ü–æ–¥–≥–æ—Ç–æ–≤–∫–∞ –¥–∞–Ω–Ω—ã—Ö –¥–ª—è TinyML
    prepared_data = prepare_data_for_tinyml(ohlcv_data)
    result = analyze_with_tinyml(prepared_data)
    # –ò–Ω—Ç–µ—Ä–ø—Ä–µ—Ç–∞—Ü–∏—è —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞
    return interpret_open_signal_result(result)

def should_close_signal(ohlcv_data, current_trend):
    # –ü–æ–¥–≥–æ—Ç–æ–≤–∫–∞ –¥–∞–Ω–Ω—ã—Ö –¥–ª—è TinyML
    prepared_data = prepare_data_for_tinyml(ohlcv_data, current_trend)
    result = analyze_with_tinyml(prepared_data)
    # –ò–Ω—Ç–µ—Ä–ø—Ä–µ—Ç–∞—Ü–∏—è —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞
    return interpret_close_signal_result(result)

# –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏
def prepare_data_for_tinyml(ohlcv_data, current_trend=None):
    # –õ–æ–≥–∏–∫–∞ –ø–æ–¥–≥–æ—Ç–æ–≤–∫–∏ –¥–∞–Ω–Ω—ã—Ö –¥–ª—è –º–æ–¥–µ–ª–∏ TinyML
    pass

def interpret_open_signal_result(result):
    # –õ–æ–≥–∏–∫–∞ –∏–Ω—Ç–µ—Ä–ø—Ä–µ—Ç–∞—Ü–∏–∏ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞ –¥–ª—è –æ—Ç–∫—Ä—ã—Ç–∏—è —Å–∏–≥–Ω–∞–ª–∞
    pass

def interpret_close_signal_result(result):
    # –õ–æ–≥–∏–∫–∞ –∏–Ω—Ç–µ—Ä–ø—Ä–µ—Ç–∞—Ü–∏–∏ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞ –¥–ª—è –∑–∞–∫—Ä—ã—Ç–∏—è —Å–∏–≥–Ω–∞–ª–∞
    pass
--------------------------------------------------------------------------------
Error reading /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/services/__pycache__/crypto_api.cpython-311.pyc: 'utf-8' codec can't decode byte 0xa7 in position 0: invalid start byte
Error reading /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/services/__pycache__/trend_analyzer.cpython-311.pyc: 'utf-8' codec can't decode byte 0xa7 in position 0: invalid start byte
Error reading /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/services/__pycache__/signal_manager.cpython-311.pyc: 'utf-8' codec can't decode byte 0xa7 in position 0: invalid start byte
Path: /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/utils/time_utils.py
File Name: time_utils.py
Code:
from datetime import datetime
from pytz import timezone
from config import TIMEZONE

def get_current_time():
    return datetime.now(timezone(TIMEZONE)).isoformat()

def format_date(date_string):
    date = datetime.fromisoformat(date_string)
    if date.tzinfo is None:
        date = date.replace(tzinfo=timezone(TIMEZONE))
    return date.astimezone(timezone(TIMEZONE)).strftime("%Y-%m-%d %H:%M")

def calculate_time_difference(start_time, end_time):
    start = datetime.fromisoformat(start_time)
    end = datetime.fromisoformat(end_time)
    if start.tzinfo is None:
        start = start.replace(tzinfo=timezone(TIMEZONE))
    if end.tzinfo is None:
        end = end.replace(tzinfo=timezone(TIMEZONE))
    diff = end - start
    days = diff.days
    hours = diff.seconds // 3600
    return f"{days} –¥–Ω–µ–π –∏ {hours} —á–∞—Å–æ–≤"
--------------------------------------------------------------------------------
Path: /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/utils/logger.py
File Name: logger.py
Code:
import logging
from logging.handlers import TimedRotatingFileHandler
import os
from pathlib import Path

def setup_logging():
    # –°–æ–∑–¥–∞–µ–º –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—é logs –≤ –∫–æ—Ä–Ω–µ –ø—Ä–æ–µ–∫—Ç–∞
    log_dir = Path(__file__).parents[1] / 'logs'
    log_dir.mkdir(exist_ok=True)

    # –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –æ–±—â–µ–≥–æ –ª–æ–≥–∞
    general_log_handler = TimedRotatingFileHandler(
        log_dir / 'general.log',
        when="D",
        interval=1,
        backupCount=1
    )
    general_log_handler.setFormatter(logging.Formatter('%(asctime)s - %(levelname)s - %(message)s'))

    # –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –ª–æ–≥–∞ –∞–Ω–∞–ª–∏–∑–∞
    analyze_log_handler = TimedRotatingFileHandler(
        log_dir / 'analyze.log',
        when="D",
        interval=7,
        backupCount=1
    )
    analyze_log_handler.setFormatter(logging.Formatter('%(asctime)s - %(levelname)s - %(message)s'))

    # –ó–∞–∫—Ä—ã—Ç–∏–µ –ø—Ä–µ–¥—ã–¥—É—â–∏—Ö –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–æ–≤ (–µ—Å–ª–∏ –æ–Ω–∏ –±—ã–ª–∏ –Ω–∞—Å—Ç—Ä–æ–µ–Ω—ã)
    if logging.getLogger('general').hasHandlers():
        logging.getLogger('general').handlers.clear()

    if logging.getLogger('analyze').hasHandlers():
        logging.getLogger('analyze').handlers.clear()

    # –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –æ–±—â–µ–≥–æ –ª–æ–≥–≥–µ—Ä–∞
    general_logger = logging.getLogger('general')
    general_logger.setLevel(logging.INFO)
    general_logger.addHandler(general_log_handler)

    # –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –ª–æ–≥–≥–µ—Ä–∞ –∞–Ω–∞–ª–∏–∑–∞
    analyze_logger = logging.getLogger('analyze')
    analyze_logger.setLevel(logging.INFO)
    analyze_logger.addHandler(analyze_log_handler)

    return general_logger, analyze_logger

general_logger, analyze_logger = setup_logging()

__all__ = ['setup_logging', 'general_logger', 'analyze_logger']
--------------------------------------------------------------------------------
Path: /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/utils/message_formatter.py
File Name: message_formatter.py
Code:
from datetime import datetime
from utils.time_utils import format_date, calculate_time_difference
from datetime import datetime
from config import TIMEZONE
from pytz import timezone

def add_timestamp_and_separator(message):
    current_time = datetime.now(timezone(TIMEZONE)).strftime("%Y-%m-%d %H:%M")
    separator = "-" * 40
    return f"{current_time}\n{separator}\n{message}"

def format_new_signal_message(signal, is_new=False):
    status = "–ù–æ–≤—ã–π —Å–∏–≥–Ω–∞–ª" if is_new else "–ê–∫—Ç—É–∞–ª—å–Ω–æ"
    trend_emoji = "üü¢" if signal.trend.lower() == "long" else "üî¥"
    return f"‚úÖ{status}: {signal.name} {trend_emoji} {signal.trend.upper()} –¢–æ—á–Ω–æ—Å—Ç—å: {signal.accuracy}\n" \
           f"–ù–∞—á–∞–ª–æ: {format_date(signal.date_start)} –¶–µ–Ω–∞: {signal.price_start}\n" \
           f"–ê–∫—Ç—É–∞–ª—å–Ω–æ –Ω–∞: {format_date(signal.date_last)} –¶–µ–Ω–∞: {signal.price_last}"

def format_closed_signal_message(signal):
    trend_emoji = "üü¢" if signal.trend.lower() == "long" else "üî¥"
    price_change = ((signal.price_end - signal.price_start) / signal.price_start) * 100
    price_change_sign = "+" if (signal.trend.lower() == "long" and price_change > 0) or (signal.trend.lower() == "short" and price_change < 0) else "-"
    price_change_str = f"{price_change_sign}{abs(price_change):.2f}%"

    return f"‚ùå–°–∏–≥–Ω–∞–ª –∑–∞–∫—Ä—ã—Ç: {signal.name} {trend_emoji} {signal.trend.upper()}\n" \
           f"–ù–∞—á–∞–ª–æ: {format_date(signal.date_start)} –¶–µ–Ω–∞: {signal.price_start}\n" \
           f"–ö–æ–Ω–µ—Ü: {format_date(signal.date_end)} –¶–µ–Ω–∞: {signal.price_end}\n" \
           f"–ò–∑–º–µ–Ω–µ–Ω–∏–µ —Ü–µ–Ω—ã: {price_change_str}\n" \
           f"–û–±—â–∞—è –¥–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å: {calculate_time_difference(signal.date_start, signal.date_end)}"

def format_signals_table(signals):
    formatted_signals = []

    for signal in signals:
        formatted_signal = (
            f"ID: {signal[0]}\n"
            f"Name: {signal[1]}\n"
            f"Trend: {signal[2]}\n"
            f"Start Date: {signal[3]}\n"
            f"Last Date: {signal[4]}\n"
            f"Accuracy: {signal[5]}\n"
            f"End Date: {signal[6]}\n"
            f"Start Price: {signal[7]}\n"
            f"Last Price: {signal[8]}\n"
            f"End Price: {signal[9]}\n"
            f"Count Sends: {signal[10]}\n"
            f"Reported: {signal[11]}\n"
            "----------------------"
        )
        formatted_signals.append(formatted_signal)

    return "\n".join(formatted_signals)
--------------------------------------------------------------------------------
Path: /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/utils/chart_generator.py
File Name: chart_generator.py
Code:
import matplotlib.pyplot as plt
import matplotlib.dates as mdates
from matplotlib.patches import Arrow
import numpy as np
from datetime import datetime
import io
import logging
from pytz import UTC

def generate_chart(ohlcv_data, trend, signal_start_date=None, signal_end_date=None):
    dates = [datetime.fromtimestamp(x[0] / 1000, tz=UTC) for x in ohlcv_data]
    closes = [x[4] for x in ohlcv_data]

    fig, ax = plt.subplots(figsize=(10, 6))
    ax.plot(dates, closes, label='–¶–µ–Ω–∞ –∑–∞–∫—Ä—ã—Ç–∏—è')

    ax.set_title(f'–¢—Ä–µ–Ω–¥: {trend.capitalize()}')
    ax.set_xlabel('–í—Ä–µ–º—è')
    ax.set_ylabel('–¶–µ–Ω–∞')
    ax.legend()

    # –§–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –æ—Å–∏ X –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è –¥–∞—Ç
    ax.xaxis.set_major_formatter(mdates.DateFormatter('%Y-%m-%d %H:%M', tz=UTC))
    plt.xticks(rotation=45)

    # –û—Ç–º–µ—Ç–∫–∞ –Ω–∞—á–∞–ª–∞ —Å–∏–≥–Ω–∞–ª–∞
    if signal_start_date:
        signal_start = datetime.fromisoformat(signal_start_date).replace(tzinfo=UTC)
        start_index = dates.index(min(dates, key=lambda d: abs(d - signal_start)))
        ax.axvline(x=dates[start_index], color='g' if trend.lower() == 'long' else 'r', linestyle='--', label='–ù–∞—á–∞–ª–æ —Å–∏–≥–Ω–∞–ª–∞')

    # –û—Ç–º–µ—Ç–∫–∞ –∫–æ–Ω—Ü–∞ —Å–∏–≥–Ω–∞–ª–∞, –µ—Å–ª–∏ –µ—Å—Ç—å
    if signal_end_date:
        signal_end = datetime.fromisoformat(signal_end_date).replace(tzinfo=UTC)
        end_index = dates.index(min(dates, key=lambda d: abs(d - signal_end)))
        ax.axvline(x=dates[end_index], color='black', linestyle='--', label='–ö–æ–Ω–µ—Ü —Å–∏–≥–Ω–∞–ª–∞')

    plt.tight_layout()

    # –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –≥—Ä–∞—Ñ–∏–∫–∞ –≤ –±–∞–π—Ç–æ–≤—ã–π –ø–æ—Ç–æ–∫
    buf = io.BytesIO()
    plt.savefig(buf, format='png')
    buf.seek(0)
    plt.close(fig)

    return buf
--------------------------------------------------------------------------------
Error reading /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/utils/__pycache__/message_formatter.cpython-311.pyc: 'utf-8' codec can't decode byte 0xa7 in position 0: invalid start byte
Error reading /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/utils/__pycache__/logger.cpython-311.pyc: 'utf-8' codec can't decode byte 0xa7 in position 0: invalid start byte
Error reading /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/utils/__pycache__/time_utils.cpython-311.pyc: 'utf-8' codec can't decode byte 0xa7 in position 0: invalid start byte
Error reading /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/utils/__pycache__/chart_generator.cpython-311.pyc: 'utf-8' codec can't decode byte 0xa7 in position 0: invalid start byte