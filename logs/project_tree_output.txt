Project Tree Structure:
â”œâ”€â”€ crypto_trend_bot/
â”‚   â”œâ”€â”€ config.py
â”‚   â”œâ”€â”€ requirements.txt
â”‚   â”œâ”€â”€ Dockerfile
â”‚   â”œâ”€â”€ check_errors.py
â”‚   â”œâ”€â”€ main.py
â”‚   â”œâ”€â”€ bot/
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ __pycache__/
â”‚   â”‚   â”‚   â”œâ”€â”€ __init__.cpython-311.pyc
â”‚   â”‚   â”‚   â””â”€â”€ scheduler.cpython-311.pyc
â”‚   â”‚   â”œâ”€â”€ handlers/
â”‚   â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”‚   â”œâ”€â”€ __pycache__/
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ __init__.cpython-311.pyc
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ periodic_tasks.cpython-311.pyc
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ signals.cpython-311.pyc
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ utils.cpython-311.pyc
â”‚   â”‚   â”‚   â”œâ”€â”€ commands/
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ __pycache__/
â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ __init__.cpython-311.pyc
â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ actual_send.cpython-311.pyc
â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ count_signals.cpython-311.pyc
â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ delete_logs.cpython-311.pyc
â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ delete_tables.cpython-311.pyc
â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ help.cpython-311.pyc
â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ interval.cpython-311.pyc
â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ logs.cpython-311.pyc
â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ menu_handlers.cpython-311.pyc
â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ scheduler_command.cpython-311.pyc
â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ show_signals.cpython-311.pyc
â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ start.cpython-311.pyc
â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ stop.cpython-311.pyc
â”‚   â”‚   â”‚   â”‚   â”‚   â””â”€â”€ table_signals.cpython-311.pyc
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ actual_send.py
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ count_signals.py
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ delete_logs.py
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ delete_tables.py
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ help.py
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ interval.py
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ logs.py
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ menu_handlers.py
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ scheduler_command.py
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ show_signals.py
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ start.py
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ stop.py
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ table_signals.py
â”‚   â”‚   â”‚   â”œâ”€â”€ periodic_tasks.py
â”‚   â”‚   â”‚   â”œâ”€â”€ signals.py
â”‚   â”‚   â”‚   â””â”€â”€ utils.py
â”‚   â”‚   â””â”€â”€ scheduler.py
â”‚   â”œâ”€â”€ database/
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ __pycache__/
â”‚   â”‚   â”‚   â”œâ”€â”€ __init__.cpython-311.pyc
â”‚   â”‚   â”‚   â”œâ”€â”€ db_handler.cpython-311.pyc
â”‚   â”‚   â”‚   â””â”€â”€ models.cpython-311.pyc
â”‚   â”‚   â”œâ”€â”€ db_handler.py
â”‚   â”‚   â””â”€â”€ models.py
â”‚   â”œâ”€â”€ services/
â”‚   â”‚   â”œâ”€â”€ __pycache__/
â”‚   â”‚   â”‚   â”œâ”€â”€ crypto_api.cpython-311.pyc
â”‚   â”‚   â”‚   â”œâ”€â”€ signal_manager.cpython-311.pyc
â”‚   â”‚   â”‚   â””â”€â”€ trend_analyzer.cpython-311.pyc
â”‚   â”‚   â”œâ”€â”€ crypto_api.py
â”‚   â”‚   â”œâ”€â”€ signal_manager.py
â”‚   â”‚   â”œâ”€â”€ tinyml_analyzer.py
â”‚   â”‚   â””â”€â”€ trend_analyzer.py
â”‚   â”œâ”€â”€ utils/
â”‚   â”‚   â”œâ”€â”€ __pycache__/
â”‚   â”‚   â”‚   â”œâ”€â”€ chart_generator.cpython-311.pyc
â”‚   â”‚   â”‚   â”œâ”€â”€ logger.cpython-311.pyc
â”‚   â”‚   â”‚   â”œâ”€â”€ message_formatter.cpython-311.pyc
â”‚   â”‚   â”‚   â””â”€â”€ time_utils.cpython-311.pyc
â”‚   â”‚   â”œâ”€â”€ chart_generator.py
â”‚   â”‚   â”œâ”€â”€ logger.py
â”‚   â”‚   â”œâ”€â”€ message_formatter.py
â”‚   â”‚   â””â”€â”€ time_utils.py

================================================================================

Path: /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/config.py
File Name: config.py
Code:
# Ğ¢Ğ¾ĞºĞµĞ½ Ğ²Ğ°ÑˆĞµĞ³Ğ¾ Ğ±Ğ¾Ñ‚Ğ°
BOT_TOKEN = "7317150884:AAENXygTDLy3KGvLIh5CgxfqRRS69Rd2I1U"

# ID ĞºĞ°Ğ½Ğ°Ğ»Ğ° Telegram, ĞºÑƒĞ´Ğ° Ğ±Ğ¾Ñ‚ Ğ±ÑƒĞ´ĞµÑ‚ Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²Ğ»ÑÑ‚ÑŒ ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ñ
CHANNEL_ID = "7317150884"

# Ğ¡Ğ¿Ğ¸ÑĞ¾Ğº Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼Ñ‹Ñ… Ğ¿Ğ°Ñ€
CRYPTO_PAIRS = ["BTC/USDT", "ETH/USDT", "ADA/USDT", "TON/USDT"]

# ĞĞ°ÑÑ‚Ñ€Ğ¾Ğ¹ĞºĞ¸ API Ğ±Ğ¸Ñ€Ğ¶Ğ¸
EXCHANGE_API_KEY = "MWpeIx2bRxJW9igMlA4LDb6i7JovQLM9CYYS5AfbD803JyQhWbPAgi2m9LsBE58k"
EXCHANGE_SECRET = "nxQoPTFVJeR1U6etHoKXtIFbvV5s3nSDOY5579PKVTeHZQcHJw5VZDtJ60JslMBh"

# ĞĞ°ÑÑ‚Ñ€Ğ¾Ğ¹ĞºĞ¸ Ğ±Ğ°Ğ·Ñ‹ Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ…
DB_NAME = "price_trend_db.sqlite"

# ĞĞ°ÑÑ‚Ñ€Ğ¾Ğ¹ĞºĞ¸ Ğ¿Ğ»Ğ°Ğ½Ğ¸Ñ€Ğ¾Ğ²Ñ‰Ğ¸ĞºĞ°
CHECK_INTERVAL = 1 * 60  # 1 Ğ¼Ğ¸Ğ½ÑƒÑ‚Ğ° Ğ² ÑĞµĞºÑƒĞ½Ğ´Ğ°Ñ…

# Ğ§Ğ°ÑĞ¾Ğ²Ğ¾Ğ¹ Ğ¿Ğ¾ÑÑ
TIMEZONE = "Europe/Samara"

_SEND_ACTUAL_SIGNALS = True

def toggle_actual_signals():
    global _SEND_ACTUAL_SIGNALS
    _SEND_ACTUAL_SIGNALS = not _SEND_ACTUAL_SIGNALS
    return _SEND_ACTUAL_SIGNALS

def get_actual_signals_status():
    return _SEND_ACTUAL_SIGNALS
--------------------------------------------------------------------------------
Path: /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/requirements.txt
File Name: requirements.txt
Code:
pyTelegramBotAPI==4.14.0
ccxt==4.0.80
numpy==1.24.3
APScheduler==3.10.4
matplotlib==3.7.2
pytz==2023.3
tabulate==0.9.0
tensorflow==2.13.0
pandas==1.5.3
mplfinance==0.12.9b7
sqlalchemy
flake8
--------------------------------------------------------------------------------
Path: /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/Dockerfile
File Name: Dockerfile
Code:
FROM python:3.11-slim

WORKDIR /app

COPY requirements.txt .

RUN pip install --no-cache-dir -r requirements.txt

COPY . .

ENV PYTHONDONTWRITEBYTECODE=1
ENV PYTHONUNBUFFERED=1

CMD ["python", "main.py"]
--------------------------------------------------------------------------------
Path: /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/check_errors.py
File Name: check_errors.py
Code:
import subprocess
import os


def run_flake8_and_save_output():
    # ĞĞ¿Ñ€ĞµĞ´ĞµĞ»ÑĞµĞ¼ Ğ¿ÑƒÑ‚ÑŒ Ğº Ñ„Ğ°Ğ¹Ğ»Ñƒ Ğ´Ğ»Ñ ÑĞ¾Ñ…Ñ€Ğ°Ğ½ĞµĞ½Ğ¸Ñ Ñ€ĞµĞ·ÑƒĞ»ÑŒÑ‚Ğ°Ñ‚Ğ¾Ğ²
    log_dir = os.path.join(os.path.dirname(__file__), 'logs')
    os.makedirs(log_dir, exist_ok=True)
    output_file = os.path.join(log_dir, 'check_errors.txt')

    try:
        # Ğ—Ğ°Ğ¿ÑƒÑĞºĞ°ĞµĞ¼ flake8 Ñ Ñ„Ğ¸Ğ»ÑŒÑ‚Ñ€Ğ¾Ğ¼ Ğ¿Ğ¾ ĞºÑ€Ğ¸Ñ‚Ğ¸Ñ‡Ğ½Ñ‹Ğ¼ Ğ¾ÑˆĞ¸Ğ±ĞºĞ°Ğ¼
        result = subprocess.run(['flake8', '--select=E,F'], stdout=subprocess.PIPE,
                                stderr=subprocess.STDOUT, text=True)

        # ĞÑ‚Ñ„Ğ¸Ğ»ÑŒÑ‚Ñ€Ğ¾Ğ²Ñ‹Ğ²Ğ°ĞµĞ¼ Ğ²ÑĞµ ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ñ, Ğ½Ğ°Ñ‡Ğ¸Ğ½Ğ°ÑÑ‰Ğ¸ĞµÑÑ Ğ½Ğ° E
        filtered_output = "\n".join(
            line for line in result.stdout.splitlines() if not line.startswith('E')
        )

        # Ğ—Ğ°Ğ¿Ğ¸ÑÑ‹Ğ²Ğ°ĞµĞ¼ Ñ€ĞµĞ·ÑƒĞ»ÑŒÑ‚Ğ°Ñ‚ Ğ² Ñ„Ğ°Ğ¹Ğ» Ñ‚Ğ¾Ğ»ÑŒĞºĞ¾ ĞµÑĞ»Ğ¸ ĞµÑÑ‚ÑŒ Ğ´Ñ€ÑƒĞ³Ğ¸Ğµ ĞºÑ€Ğ¸Ñ‚Ğ¸Ñ‡Ğ½Ñ‹Ğµ Ğ¾ÑˆĞ¸Ğ±ĞºĞ¸
        if filtered_output.strip():
            with open(output_file, 'w') as file:
                file.write(filtered_output)
            print(f"Ğ ĞµĞ·ÑƒĞ»ÑŒÑ‚Ğ°Ñ‚Ñ‹ Ğ°Ğ½Ğ°Ğ»Ğ¸Ğ·Ğ° ÑĞ¾Ñ…Ñ€Ğ°Ğ½ĞµĞ½Ñ‹ Ğ² {output_file}")
        else:
            print("ĞšÑ€Ğ¸Ñ‚Ğ¸Ñ‡Ğ½Ñ‹Ñ… Ğ¾ÑˆĞ¸Ğ±Ğ¾Ğº, Ğ½Ğ°Ñ‡Ğ¸Ğ½Ğ°ÑÑ‰Ğ¸Ñ…ÑÑ Ñ 'E', Ğ½Ğµ Ğ¾Ğ±Ğ½Ğ°Ñ€ÑƒĞ¶ĞµĞ½Ğ¾.")

    except subprocess.CalledProcessError as e:
        print(f"Ğ’Ğ¾Ğ·Ğ½Ğ¸ĞºĞ»Ğ° Ğ¾ÑˆĞ¸Ğ±ĞºĞ° Ğ¿Ñ€Ğ¸ Ğ²Ñ‹Ğ¿Ğ¾Ğ»Ğ½ĞµĞ½Ğ¸Ğ¸ flake8: {e}")
    except Exception as e:
        print(f"Ğ’Ğ¾Ğ·Ğ½Ğ¸ĞºĞ»Ğ° Ğ½ĞµĞ¿Ñ€ĞµĞ´Ğ²Ğ¸Ğ´ĞµĞ½Ğ½Ğ°Ñ Ğ¾ÑˆĞ¸Ğ±ĞºĞ°: {e}")


if __name__ == "__main__":
    print("Ğ—Ğ°Ğ¿ÑƒÑĞº flake8 Ğ´Ğ»Ñ Ğ°Ğ½Ğ°Ğ»Ğ¸Ğ·Ğ° ĞºĞ¾Ğ´Ğ° Ğ¸ ÑĞ¾Ñ…Ñ€Ğ°Ğ½ĞµĞ½Ğ¸Ñ Ñ€ĞµĞ·ÑƒĞ»ÑŒÑ‚Ğ°Ñ‚Ğ¾Ğ²...")
    run_flake8_and_save_output()
--------------------------------------------------------------------------------
Path: /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/main.py
File Name: main.py
Code:
import logging
import asyncio
from telebot.async_telebot import AsyncTeleBot
from bot.handlers import setup_bot
from database.db_handler import init_db
from config import BOT_TOKEN
from bot.scheduler import start_scheduler

# ĞĞ°ÑÑ‚Ñ€Ğ¾Ğ¹ĞºĞ° Ğ»Ğ¾Ğ³Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ñ
logging.basicConfig(level=logging.INFO, format='%(asctime)s [%(levelname)s] %(message)s', handlers=[logging.StreamHandler()])

async def main():
    bot = AsyncTeleBot(BOT_TOKEN)  # Ğ˜Ğ½Ğ¸Ñ†Ğ¸Ğ°Ğ»Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ Ğ±Ğ¾Ñ‚Ğ°

    while True:
        try:
            # Ğ˜Ğ½Ğ¸Ñ†Ğ¸Ğ°Ğ»Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ Ğ±Ğ°Ğ·Ñ‹ Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ…
            logging.info("Ğ˜Ğ½Ğ¸Ñ†Ğ¸Ğ°Ğ»Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ Ğ±Ğ°Ğ·Ñ‹ Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ….")
            init_db()

            # ĞĞ°ÑÑ‚Ñ€Ğ¾Ğ¹ĞºĞ° Ğ¸ Ğ·Ğ°Ğ¿ÑƒÑĞº Ğ±Ğ¾Ñ‚Ğ°
            await setup_bot(bot)
            logging.info("Ğ‘Ğ¾Ñ‚ Ğ½Ğ°ÑÑ‚Ñ€Ğ¾ĞµĞ½ Ğ¸ Ğ³Ğ¾Ñ‚Ğ¾Ğ² Ğº Ğ·Ğ°Ğ¿ÑƒÑĞºÑƒ.")

            # ĞĞ±Ñ€Ğ°Ğ±Ğ¾Ñ‚Ñ‡Ğ¸Ğº ĞºĞ¾Ğ¼Ğ°Ğ½Ğ´Ñ‹ /start Ğ´Ğ»Ñ Ğ¿Ğ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ¸Ñ chat_id Ğ¸ Ğ·Ğ°Ğ¿ÑƒÑĞºĞ° Ğ¿Ğ»Ğ°Ğ½Ğ¸Ñ€Ğ¾Ğ²Ñ‰Ğ¸ĞºĞ°
            @bot.message_handler(commands=['start'])
            async def start_command(message):
                chat_id = message.chat.id
                await bot.send_message(chat_id, "ĞŸĞ»Ğ°Ğ½Ğ¸Ñ€Ğ¾Ğ²Ñ‰Ğ¸Ğº Ğ·Ğ°Ğ¿ÑƒÑ‰ĞµĞ½ Ñ Ğ¸Ğ½Ñ‚ĞµÑ€Ğ²Ğ°Ğ»Ğ¾Ğ¼ 60 ÑĞµĞºÑƒĞ½Ğ´.")
                await start_scheduler(60, bot, chat_id)  # ĞŸĞµÑ€ĞµĞ´Ğ°ĞµĞ¼ chat_id Ğ² start_scheduler

            # Ğ—Ğ°Ğ¿ÑƒÑĞº Ğ±Ğ¾Ñ‚Ğ°
            await bot.infinity_polling()
        except Exception as e:
            logging.error(f"ĞŸÑ€Ğ¾Ğ¸Ğ·Ğ¾ÑˆĞ»Ğ° Ğ¾ÑˆĞ¸Ğ±ĞºĞ°: {e}")
            logging.info("ĞŸĞµÑ€ĞµĞ·Ğ°Ğ¿ÑƒÑĞº Ğ±Ğ¾Ñ‚Ğ° Ñ‡ĞµÑ€ĞµĞ· 5 ÑĞµĞºÑƒĞ½Ğ´...")
            await asyncio.sleep(5)

if __name__ == "__main__":
    logging.info("Ğ—Ğ°Ğ¿ÑƒÑĞº Ğ¿Ñ€Ğ¸Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ñ.")
    asyncio.run(main())
--------------------------------------------------------------------------------
Path: /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/bot/__init__.py
File Name: __init__.py
Code:
import asyncio
from .handlers.commands import *
from bot.handlers.commands.menu_handlers import actual_send_button, get_main_menu_markup

async def setup_bot(bot):
    main_menu_markup = get_main_menu_markup()

    bot.message_handler(commands=['start'])(lambda message: asyncio.create_task(start_bot(message, bot)))
    bot.message_handler(commands=['stop'])(lambda message: asyncio.create_task(stop_bot(message, bot)))
    bot.message_handler(commands=['show'])(lambda message: asyncio.create_task(show_signals(message, bot)))
    bot.message_handler(commands=['count'])(lambda message: asyncio.create_task(count_signals(message, bot)))
    bot.message_handler(commands=['delete_tables'])(lambda message: asyncio.create_task(delete_tables(message, bot)))
    bot.message_handler(commands=['table_signals'])(lambda message: asyncio.create_task(table_signals(message, bot)))
    bot.message_handler(commands=['actual_send'])(lambda message: asyncio.create_task(toggle_actual_send(message, bot)))
    bot.message_handler(commands=['interval'])(lambda message: asyncio.create_task(change_interval(message, bot)))
    bot.message_handler(commands=['help'])(lambda message: asyncio.create_task(send_help(message, bot)))
    bot.message_handler(commands=['logs'])(lambda message: asyncio.create_task(send_logs(message, bot)))
    bot.message_handler(commands=['delete_logs'])(lambda message: asyncio.create_task(delete_logs(message, bot)))

    bot.message_handler(func=lambda message: message.text == "ğŸ“Š ĞŸĞ¾ĞºĞ°Ğ·Ğ°Ñ‚ÑŒ ÑĞ¸Ğ³Ğ½Ğ°Ğ»Ñ‹")(lambda message: asyncio.create_task(show_signals_button(message, bot)))
    bot.message_handler(func=lambda message: message.text == "ğŸ”¢ ĞšĞ¾Ğ»Ğ¸Ñ‡ĞµÑÑ‚Ğ²Ğ¾ ÑĞ¸Ğ³Ğ½Ğ°Ğ»Ğ¾Ğ²")(lambda message: asyncio.create_task(count_signals_button(message, bot)))
    bot.message_handler(func=lambda message: message.text == "â–¶ï¸ Ğ¡Ñ‚Ğ°Ñ€Ñ‚")(lambda message: asyncio.create_task(start_bot_button(message, bot)))
    bot.message_handler(func=lambda message: message.text == "â¹ Ğ¡Ñ‚Ğ¾Ğ¿")(lambda message: asyncio.create_task(stop_bot_button(message, bot)))
    bot.message_handler(func=lambda message: message.text == "ĞĞºÑ‚ÑƒĞ°Ğ»ÑŒĞ½Ğ°Ñ Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²ĞºĞ°")(lambda message: asyncio.create_task(actual_send_button(message, bot)))
    bot.message_handler(func=lambda message: message.text == "â“ ĞŸĞ¾Ğ¼Ğ¾Ñ‰ÑŒ")(lambda message: asyncio.create_task(help_button(message, bot)))

    @bot.message_handler(func=lambda message: True)
    async def send_welcome(message):
        await bot.reply_to(message, "Ğ’Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ ĞºĞ¾Ğ¼Ğ°Ğ½Ğ´Ñƒ:", reply_markup=main_menu_markup)

    return bot
--------------------------------------------------------------------------------
Path: /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/bot/scheduler.py
File Name: scheduler.py
Code:
import logging
from apscheduler.schedulers.asyncio import AsyncIOScheduler
from apscheduler.triggers.interval import IntervalTrigger
from services.signal_manager import check_and_create_signals
from bot.handlers.commands.show_signals import send_pending_signals
from database.db_handler import store_signals_for_sending
from config import CRYPTO_PAIRS  # Ğ˜Ğ¼Ğ¿Ğ¾Ñ€Ñ‚Ğ¸Ñ€ÑƒĞµĞ¼ ÑĞ¿Ğ¸ÑĞ¾Ğº ĞºÑ€Ğ¸Ğ¿Ñ‚Ğ¾Ğ²Ğ°Ğ»ÑÑ‚Ğ½Ñ‹Ñ… Ğ¿Ğ°Ñ€

scheduler = AsyncIOScheduler()
job = None
current_interval = None
user_chat_id = None  # Ğ“Ğ»Ğ¾Ğ±Ğ°Ğ»ÑŒĞ½Ğ°Ñ Ğ¿ĞµÑ€ĞµĞ¼ĞµĞ½Ğ½Ğ°Ñ Ğ´Ğ»Ñ Ñ…Ñ€Ğ°Ğ½ĞµĞ½Ğ¸Ñ chat_id

async def start_scheduler(check_interval, bot, chat_id):
    global job, current_interval, scheduler, user_chat_id
    logging.info("Ğ˜Ğ½Ğ¸Ñ†Ğ¸Ğ°Ğ»Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ Ğ¸ Ğ·Ğ°Ğ¿ÑƒÑĞº Ğ¿Ğ»Ğ°Ğ½Ğ¸Ñ€Ğ¾Ğ²Ñ‰Ğ¸ĞºĞ°.")

    user_chat_id = chat_id  # Ğ¡Ğ¾Ñ…Ñ€Ğ°Ğ½ÑĞµĞ¼ chat_id Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ

    if scheduler.running:
        scheduler.shutdown()

    scheduler = AsyncIOScheduler()
    current_interval = check_interval
    job = scheduler.add_job(
        process_signals_func,
        trigger=IntervalTrigger(seconds=check_interval),
        args=[bot],
        id='process_signals'
    )
    scheduler.start()
    logging.info(f"ĞŸĞ»Ğ°Ğ½Ğ¸Ñ€Ğ¾Ğ²Ñ‰Ğ¸Ğº Ğ·Ğ°Ğ¿ÑƒÑ‰ĞµĞ½ Ñ Ğ¸Ğ½Ñ‚ĞµÑ€Ğ²Ğ°Ğ»Ğ¾Ğ¼ {check_interval} ÑĞµĞºÑƒĞ½Ğ´.")

def stop_scheduler():
    global job, current_interval, scheduler
    if scheduler.running:
        scheduler.shutdown()
        job = None
        current_interval = None
        logging.info("ĞŸĞ»Ğ°Ğ½Ğ¸Ñ€Ğ¾Ğ²Ñ‰Ğ¸Ğº Ğ¾ÑÑ‚Ğ°Ğ½Ğ¾Ğ²Ğ»ĞµĞ½.")
    else:
        logging.info("ĞŸĞ»Ğ°Ğ½Ğ¸Ñ€Ğ¾Ğ²Ñ‰Ğ¸Ğº ÑƒĞ¶Ğµ Ğ¾ÑÑ‚Ğ°Ğ½Ğ¾Ğ²Ğ»ĞµĞ½.")

def get_current_interval():
    global current_interval
    return current_interval

def update_scheduler_interval(new_interval):
    global job, current_interval, scheduler
    if scheduler.running and job:
        scheduler.reschedule_job(
            'process_signals', trigger=IntervalTrigger(seconds=new_interval)
        )
        current_interval = new_interval
        logging.info(f"Ğ˜Ğ½Ñ‚ĞµÑ€Ğ²Ğ°Ğ» Ñ€Ğ°Ğ±Ğ¾Ñ‚Ñ‹ Ğ¿Ğ»Ğ°Ğ½Ğ¸Ñ€Ğ¾Ğ²Ñ‰Ğ¸ĞºĞ° Ğ¾Ğ±Ğ½Ğ¾Ğ²Ğ»ĞµĞ½ Ğ´Ğ¾ {new_interval} ÑĞµĞºÑƒĞ½Ğ´.")
    else:
        logging.warning("ĞŸĞ»Ğ°Ğ½Ğ¸Ñ€Ğ¾Ğ²Ñ‰Ğ¸Ğº Ğ½Ğµ Ğ·Ğ°Ğ¿ÑƒÑ‰ĞµĞ½, Ğ¾Ğ±Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ¸Ğµ Ğ¸Ğ½Ñ‚ĞµÑ€Ğ²Ğ°Ğ»Ğ° Ğ½ĞµĞ²Ğ¾Ğ·Ğ¼Ğ¾Ğ¶Ğ½Ğ¾.")

async def process_signals_func(bot):
    global user_chat_id
    logging.info("ĞĞ°Ñ‡Ğ°Ğ»Ğ¾ Ğ²Ñ‹Ğ¿Ğ¾Ğ»Ğ½ĞµĞ½Ğ¸Ñ Ğ¿ĞµÑ€Ğ¸Ğ¾Ğ´Ğ¸Ñ‡ĞµÑĞºĞ¾Ğ¹ Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ĞºĞ¸ ÑĞ¸Ğ³Ğ½Ğ°Ğ»Ğ¾Ğ².")
    try:
        chat_id = user_chat_id  # Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞµĞ¼ ÑĞ¾Ñ…Ñ€Ğ°Ğ½ĞµĞ½Ğ½Ñ‹Ğ¹ chat_id
        if chat_id is None:
            logging.error("Chat ID Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ Ğ½Ğµ ÑƒÑÑ‚Ğ°Ğ½Ğ¾Ğ²Ğ»ĞµĞ½.")
            return

        # Ğ’Ñ‹Ğ·Ğ¾Ğ² Ñ„ÑƒĞ½ĞºÑ†Ğ¸Ğ¸ Ñ Ğ¿ĞµÑ€ĞµĞ´Ğ°Ñ‡ĞµĞ¹ CRYPTO_PAIRS
        new_signals, updated_signals, closed_signals = await check_and_create_signals(CRYPTO_PAIRS)

        logging.info(
            f"ĞŸĞ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ¾ Ğ½Ğ¾Ğ²Ñ‹Ñ… ÑĞ¸Ğ³Ğ½Ğ°Ğ»Ğ¾Ğ²: {len(new_signals)}, Ğ¾Ğ±Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ½Ñ‹Ñ…: {len(updated_signals)}, Ğ·Ğ°ĞºÑ€Ñ‹Ñ‚Ñ‹Ñ…: {len(closed_signals)}"
        )

        # Ğ¡Ğ¾Ñ…Ñ€Ğ°Ğ½ÑĞµĞ¼ ÑĞ¸Ğ³Ğ½Ğ°Ğ»Ñ‹ Ğ´Ğ»Ñ Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²ĞºĞ¸
        store_signals_for_sending(new_signals, updated_signals, closed_signals)

        # ĞÑ‚Ğ¿Ñ€Ğ°Ğ²Ğ»ÑĞµĞ¼ ÑĞ¾Ñ…Ñ€Ğ°Ğ½ĞµĞ½Ğ½Ñ‹Ğµ ÑĞ¸Ğ³Ğ½Ğ°Ğ»Ñ‹
        await send_pending_signals(bot, chat_id)

        logging.info("ĞŸĞµÑ€Ğ¸Ğ¾Ğ´Ğ¸Ñ‡ĞµÑĞºĞ°Ñ Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ĞºĞ° ÑĞ¸Ğ³Ğ½Ğ°Ğ»Ğ¾Ğ² Ğ·Ğ°Ğ²ĞµÑ€ÑˆĞµĞ½Ğ° ÑƒÑĞ¿ĞµÑˆĞ½Ğ¾.")
    except Exception as e:
        logging.error(f"ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¿Ñ€Ğ¸ Ğ²Ñ‹Ğ¿Ğ¾Ğ»Ğ½ĞµĞ½Ğ¸Ğ¸ Ğ¿ĞµÑ€Ğ¸Ğ¾Ğ´Ğ¸Ñ‡ĞµÑĞºĞ¾Ğ¹ Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ĞºĞ¸ ÑĞ¸Ğ³Ğ½Ğ°Ğ»Ğ¾Ğ²: {e}")
        import traceback
        logging.error(traceback.format_exc())
--------------------------------------------------------------------------------
Error reading /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/bot/__pycache__/scheduler.cpython-311.pyc: 'utf-8' codec can't decode byte 0xa7 in position 0: invalid start byte
Error reading /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/bot/__pycache__/__init__.cpython-311.pyc: 'utf-8' codec can't decode byte 0xa7 in position 0: invalid start byte
Path: /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/bot/handlers/signals.py
File Name: signals.py
Code:
import logging
from telebot.async_telebot import AsyncTeleBot
from database.db_handler import get_active_signals, get_closed_signals, mark_signal_as_reported, get_signals_count
from utils.message_formatter import format_new_signal_message, format_closed_signal_message
from config import BOT_TOKEN
from .utils import send_signal_messages

bot = AsyncTeleBot(BOT_TOKEN)

@bot.message_handler(commands=['show'])
async def show_signals(message):
    logging.info("Ğ—Ğ°Ğ¿ÑƒÑ‰ĞµĞ½Ğ° ĞºĞ¾Ğ¼Ğ°Ğ½Ğ´Ğ° /show.")
    active_signals = get_active_signals()
    if not active_signals:
        logging.info("ĞĞµÑ‚ Ğ°ĞºÑ‚Ğ¸Ğ²Ğ½Ñ‹Ñ… ÑĞ¸Ğ³Ğ½Ğ°Ğ»Ğ¾Ğ².")
        await bot.reply_to(message, "Ğ’ Ğ´Ğ°Ğ½Ğ½Ñ‹Ğ¹ Ğ¼Ğ¾Ğ¼ĞµĞ½Ñ‚ Ğ½ĞµÑ‚ Ğ°ĞºÑ‚Ğ¸Ğ²Ğ½Ñ‹Ñ… ÑĞ¸Ğ³Ğ½Ğ°Ğ»Ğ¾Ğ².")
    else:
        logging.info(f"ĞÑ‚Ğ¾Ğ±Ñ€Ğ°Ğ¶ĞµĞ½Ğ¸Ğµ {len(active_signals)} Ğ°ĞºÑ‚Ğ¸Ğ²Ğ½Ñ‹Ñ… ÑĞ¸Ğ³Ğ½Ğ°Ğ»Ğ¾Ğ².")
        await send_signal_messages(bot, message.chat.id, active_signals, format_new_signal_message)

    closed_signals = get_closed_signals()
    if closed_signals:
        logging.info(f"ĞÑ‚Ğ¾Ğ±Ñ€Ğ°Ğ¶ĞµĞ½Ğ¸Ğµ {len(closed_signals)} Ğ·Ğ°ĞºÑ€Ñ‹Ñ‚Ñ‹Ñ… ÑĞ¸Ğ³Ğ½Ğ°Ğ»Ğ¾Ğ².")
        await send_signal_messages(bot, message.chat.id, closed_signals, format_closed_signal_message)
        for signal in closed_signals:
            mark_signal_as_reported(signal[0])
        logging.info("Ğ—Ğ°ĞºÑ€Ñ‹Ñ‚Ñ‹Ğµ ÑĞ¸Ğ³Ğ½Ğ°Ğ»Ñ‹ Ğ¾Ğ±Ñ€Ğ°Ğ±Ğ¾Ñ‚Ğ°Ğ½Ñ‹ Ğ¸ Ğ¾Ñ‚Ğ¼ĞµÑ‡ĞµĞ½Ñ‹ ĞºĞ°Ğº Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ½Ñ‹Ğµ.")
    else:
        logging.info("ĞĞµÑ‚ Ğ·Ğ°ĞºÑ€Ñ‹Ñ‚Ñ‹Ñ… ÑĞ¸Ğ³Ğ½Ğ°Ğ»Ğ¾Ğ².")
        await bot.reply_to(message, "Ğ’ Ğ´Ğ°Ğ½Ğ½Ñ‹Ğ¹ Ğ¼Ğ¾Ğ¼ĞµĞ½Ñ‚ Ğ½ĞµÑ‚ Ğ·Ğ°ĞºÑ€Ñ‹Ñ‚Ñ‹Ñ… ÑĞ¸Ğ³Ğ½Ğ°Ğ»Ğ¾Ğ².")

@bot.message_handler(commands=['count'])
async def count_signals(message):
    logging.info("Ğ—Ğ°Ğ¿ÑƒÑ‰ĞµĞ½Ğ° ĞºĞ¾Ğ¼Ğ°Ğ½Ğ´Ğ° /count.")
    active_count, closed_count = get_signals_count()
    logging.info(f"ĞšĞ¾Ğ»Ğ¸Ñ‡ĞµÑÑ‚Ğ²Ğ¾ Ğ¾Ñ‚ĞºÑ€Ñ‹Ñ‚Ñ‹Ñ… ÑĞ¸Ğ³Ğ½Ğ°Ğ»Ğ¾Ğ²: {active_count}, Ğ·Ğ°ĞºÑ€Ñ‹Ñ‚Ñ‹Ñ… ÑĞ¸Ğ³Ğ½Ğ°Ğ»Ğ¾Ğ²: {closed_count}")
    await bot.reply_to(message, f"ĞšĞ¾Ğ»Ğ¸Ñ‡ĞµÑÑ‚Ğ²Ğ¾ Ğ¾Ñ‚ĞºÑ€Ñ‹Ñ‚Ñ‹Ñ… ÑĞ¸Ğ³Ğ½Ğ°Ğ»Ğ¾Ğ²: {active_count}\nĞšĞ¾Ğ»Ğ¸Ñ‡ĞµÑÑ‚Ğ²Ğ¾ Ğ·Ğ°ĞºÑ€Ñ‹Ñ‚Ñ‹Ñ… ÑĞ¸Ğ³Ğ½Ğ°Ğ»Ğ¾Ğ²: {closed_count}")
--------------------------------------------------------------------------------
Path: /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/bot/handlers/__init__.py
File Name: __init__.py
Code:
from .commands import (
    start_bot,
    start_scheduler_command,
    stop_bot,
    show_signals,
    count_signals,
    delete_tables,
    table_signals,
    toggle_actual_send,
    change_interval,
    send_help,
    send_logs,
    delete_logs,
    send_pending_signals
)
from .commands.menu_handlers import (
    get_main_menu_markup,
    show_signals_button,
    count_signals_button,
    start_bot_button,
    stop_bot_button,
    help_button
)


async def setup_bot(bot):
    bot.message_handler(commands=['start'])(
        lambda message: start_bot(message, bot)
    )
    bot.message_handler(commands=['scheduler_start'])(
        lambda message: start_scheduler_command(message, bot)
    )
    bot.message_handler(commands=['stop'])(
        lambda message: stop_bot(message, bot)
    )
    bot.message_handler(commands=['show'])(
        lambda message: show_signals(message, bot)
    )
    bot.message_handler(commands=['count'])(
        lambda message: count_signals(message, bot)
    )
    bot.message_handler(commands=['delete_tables'])(
        lambda message: delete_tables(message, bot)
    )
    bot.message_handler(commands=['table_signals'])(
        lambda message: table_signals(message, bot)
    )
    bot.message_handler(commands=['actual_send'])(
        lambda message: toggle_actual_send(message, bot)
    )
    bot.message_handler(commands=['interval'])(
        lambda message: change_interval(message, bot)
    )
    bot.message_handler(commands=['help'])(
        lambda message: send_help(message, bot)
    )
    bot.message_handler(commands=['logs'])(
        lambda message: send_logs(message, bot)
    )
    bot.message_handler(commands=['delete_logs'])(
        lambda message: delete_logs(message, bot)
    )
    bot.message_handler(commands=['send_signals'])(
        lambda message: send_pending_signals(message, bot)
    )

    bot.message_handler(func=lambda message: message.text == "ğŸ“Š ĞŸĞ¾ĞºĞ°Ğ·Ğ°Ñ‚ÑŒ ÑĞ¸Ğ³Ğ½Ğ°Ğ»Ñ‹")(
        lambda message: show_signals_button(message, bot)
    )
    bot.message_handler(func=lambda message: message.text == "ğŸ”¢ ĞšĞ¾Ğ»Ğ¸Ñ‡ĞµÑÑ‚Ğ²Ğ¾ ÑĞ¸Ğ³Ğ½Ğ°Ğ»Ğ¾Ğ²")(
        lambda message: count_signals_button(message, bot)
    )
    bot.message_handler(func=lambda message: message.text == "â–¶ï¸ Ğ¡Ñ‚Ğ°Ñ€Ñ‚")(
        lambda message: start_bot_button(message, bot)
    )
    bot.message_handler(func=lambda message: message.text == "â¹ Ğ¡Ñ‚Ğ¾Ğ¿")(
        lambda message: stop_bot_button(message, bot)
    )
    bot.message_handler(func=lambda message: message.text == "â“ ĞŸĞ¾Ğ¼Ğ¾Ñ‰ÑŒ")(
        lambda message: help_button(message, bot)
    )

    return bot
--------------------------------------------------------------------------------
Path: /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/bot/handlers/utils.py
File Name: utils.py
Code:
import io
import asyncio
from telebot.async_telebot import AsyncTeleBot
from database.models import Signal
from services.crypto_api import get_ohlcv
from utils.chart_generator import generate_chart
from database.db_handler import increment_count_sends, store_signals_for_sending
import logging
from datetime import datetime
from pytz import timezone
from config import TIMEZONE, BOT_TOKEN
from utils.logger import general_logger

bot = AsyncTeleBot(BOT_TOKEN)

async def process_and_store_signals(new_signals, updated_signals, closed_signals):
    store_signals_for_sending(new_signals, updated_signals, closed_signals)
    logging.info(f"Stored for sending: {len(new_signals)} new, {len(updated_signals)} updated, {len(closed_signals)} closed signals.")

async def send_signal_messages(chat_id, signals, format_message_func, is_new=False, send_timestamp=True):
    general_logger.info(f"Started sending messages for {len(signals)} signals.")

    if signals and send_timestamp:
        current_time = datetime.now(timezone(TIMEZONE)).strftime("%Y-%m-%d %H:%M")
        separator = "-" * 40
        header_message = f"{current_time}\n{separator}"
        try:
            await bot.send_message(chat_id, header_message)
            general_logger.info(f"Sent message with timestamp and separator: {header_message}")
        except Exception as e:
            general_logger.error(f"Error sending header: {e}")
            return

    for signal in signals:
        try:
            message_text = format_message_func(signal, is_new=is_new)

            ohlcv_data = await get_ohlcv(signal.name)
            chart_buffer = generate_chart(ohlcv_data, signal.trend, signal.date_start, signal.date_last)
            chart_bytes = chart_buffer.getvalue()
            general_logger.info(f"Chart for {signal.name} generated successfully.")

            for attempt in range(3):
                try:
                    await asyncio.sleep(1)
                    if chart_bytes:
                        sent_message = await bot.send_photo(chat_id, chart_bytes, caption=message_text)
                        general_logger.info(f"Message with chart sent successfully to chat {chat_id}: {sent_message.message_id}")
                    else:
                        sent_message = await bot.send_message(chat_id, message_text)
                        general_logger.info(f"Text message sent to chat {chat_id}: {sent_message.message_id}")
                    break
                except Exception as e:
                    general_logger.error(f"Error sending message for signal {signal.name} on attempt {attempt + 1}: {e}")
                    if attempt < 2:
                        await asyncio.sleep(5)
                    else:
                        general_logger.error(f"Failed to send message for signal {signal.name} after 3 attempts.")
        except Exception as e:
            general_logger.error(f"Error processing signal {signal.name}: {e}")
--------------------------------------------------------------------------------
Path: /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/bot/handlers/periodic_tasks.py
File Name: periodic_tasks.py
Code:
import logging
from services.signal_manager import check_and_create_signals
from config import CRYPTO_PAIRS


async def perform_check(chat_id, bot):
    logging.info("Ğ’Ñ‹Ğ¿Ğ¾Ğ»Ğ½ĞµĞ½Ğ¸Ğµ Ğ¿ĞµÑ€Ğ¸Ğ¾Ğ´Ğ¸Ñ‡ĞµÑĞºĞ¾Ğ¹ Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ĞºĞ¸.")
    try:
        new_signals, updated_signals, closed_signals = check_and_create_signals(CRYPTO_PAIRS)

        # Ğ—Ğ´ĞµÑÑŒ Ğ´Ğ¾Ğ»Ğ¶Ğ½Ğ° Ğ±Ñ‹Ñ‚ÑŒ Ğ»Ğ¾Ğ³Ğ¸ĞºĞ° Ğ¾Ğ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ¸ Ğ¸ Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²ĞºĞ¸ ÑĞ¸Ğ³Ğ½Ğ°Ğ»Ğ¾Ğ²
        # ĞĞ°Ğ¿Ñ€Ğ¸Ğ¼ĞµÑ€:
        if new_signals:
            await bot.send_message(chat_id, f"ĞĞ±Ğ½Ğ°Ñ€ÑƒĞ¶ĞµĞ½Ğ¾ {len(new_signals)} Ğ½Ğ¾Ğ²Ñ‹Ñ… ÑĞ¸Ğ³Ğ½Ğ°Ğ»Ğ¾Ğ².")
        if closed_signals:
            await bot.send_message(chat_id, f"Ğ—Ğ°ĞºÑ€Ñ‹Ñ‚Ğ¾ {len(closed_signals)} ÑĞ¸Ğ³Ğ½Ğ°Ğ»Ğ¾Ğ².")

    except Exception as e:
        logging.error(f"ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¿Ñ€Ğ¸ Ğ²Ñ‹Ğ¿Ğ¾Ğ»Ğ½ĞµĞ½Ğ¸Ğ¸ Ğ¿ĞµÑ€Ğ¸Ğ¾Ğ´Ğ¸Ñ‡ĞµÑĞºĞ¾Ğ¹ Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ĞºĞ¸: {e}")
--------------------------------------------------------------------------------
Error reading /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/bot/handlers/__pycache__/signals.cpython-311.pyc: 'utf-8' codec can't decode byte 0xa7 in position 0: invalid start byte
Error reading /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/bot/handlers/__pycache__/utils.cpython-311.pyc: 'utf-8' codec can't decode byte 0xa7 in position 0: invalid start byte
Error reading /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/bot/handlers/__pycache__/__init__.cpython-311.pyc: 'utf-8' codec can't decode byte 0xa7 in position 0: invalid start byte
Error reading /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/bot/handlers/__pycache__/periodic_tasks.cpython-311.pyc: 'utf-8' codec can't decode byte 0xa7 in position 0: invalid start byte
Path: /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/bot/handlers/commands/delete_logs.py
File Name: delete_logs.py
Code:
import os
from pathlib import Path
from telebot.async_telebot import AsyncTeleBot
from utils.logger import general_logger, setup_logging

async def delete_logs(message, bot: AsyncTeleBot):
    general_logger.info("Ğ—Ğ°Ğ¿ÑƒÑ‰ĞµĞ½Ğ° ĞºĞ¾Ğ¼Ğ°Ğ½Ğ´Ğ° /delete_logs")
    try:
        log_dir = Path(__file__).parents[3] / 'logs'
        deleted_files = 0
        for file in os.listdir(log_dir):
            if file.endswith(".log"):
                os.remove(os.path.join(log_dir, file))
                deleted_files += 1

        # Ğ¡Ğ¾Ğ·Ğ´Ğ°ĞµĞ¼ Ğ½Ğ¾Ğ²Ñ‹Ğµ Ğ¿ÑƒÑÑ‚Ñ‹Ğµ Ñ„Ğ°Ğ¹Ğ»Ñ‹ Ğ»Ğ¾Ğ³Ğ¾Ğ²
        open(log_dir / 'general.log', 'w').close()
        open(log_dir / 'analyze.log', 'w').close()

        # ĞŸĞµÑ€ĞµĞ¸Ğ½Ğ¸Ñ†Ğ¸Ğ°Ğ»Ğ¸Ğ·Ğ¸Ñ€ÑƒĞµĞ¼ Ğ»Ğ¾Ğ³Ğ³ĞµÑ€Ñ‹
        new_general_logger, new_analyze_logger = setup_logging()

        # ĞĞ±Ğ½Ğ¾Ğ²Ğ»ÑĞµĞ¼ Ğ³Ğ»Ğ¾Ğ±Ğ°Ğ»ÑŒĞ½Ñ‹Ğµ Ğ¿ĞµÑ€ĞµĞ¼ĞµĞ½Ğ½Ñ‹Ğµ Ğ² Ğ¼Ğ¾Ğ´ÑƒĞ»Ğµ utils.logger
        import utils.logger
        utils.logger.general_logger = new_general_logger
        utils.logger.analyze_logger = new_analyze_logger

        response = f"Ğ£Ğ´Ğ°Ğ»ĞµĞ½Ğ¾ Ñ„Ğ°Ğ¹Ğ»Ğ¾Ğ² Ğ»Ğ¾Ğ³Ğ¾Ğ²: {deleted_files}. Ğ¡Ğ¾Ğ·Ğ´Ğ°Ğ½Ñ‹ Ğ½Ğ¾Ğ²Ñ‹Ğµ Ğ¿ÑƒÑÑ‚Ñ‹Ğµ Ñ„Ğ°Ğ¹Ğ»Ñ‹ Ğ»Ğ¾Ğ³Ğ¾Ğ²."
        await bot.reply_to(message, response)
        new_general_logger.info(
            f"Ğ£Ğ´Ğ°Ğ»ĞµĞ½Ğ¾ {deleted_files} Ñ„Ğ°Ğ¹Ğ»Ğ¾Ğ² Ğ»Ğ¾Ğ³Ğ¾Ğ². Ğ¡Ğ¾Ğ·Ğ´Ğ°Ğ½Ñ‹ Ğ½Ğ¾Ğ²Ñ‹Ğµ Ğ¿ÑƒÑÑ‚Ñ‹Ğµ Ñ„Ğ°Ğ¹Ğ»Ñ‹.")
    except Exception as e:
        general_logger.error(f"ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¿Ñ€Ğ¸ ÑƒĞ´Ğ°Ğ»ĞµĞ½Ğ¸Ğ¸ Ğ»Ğ¾Ğ³Ğ¾Ğ²: {e}")
        response = "ĞŸÑ€Ğ¾Ğ¸Ğ·Ğ¾ÑˆĞ»Ğ° Ğ¾ÑˆĞ¸Ğ±ĞºĞ° Ğ¿Ñ€Ğ¸ ÑƒĞ´Ğ°Ğ»ĞµĞ½Ğ¸Ğ¸ Ğ»Ğ¾Ğ³Ğ¾Ğ²."
        await bot.reply_to(message, response)
--------------------------------------------------------------------------------
Path: /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/bot/handlers/commands/count_signals.py
File Name: count_signals.py
Code:
from telebot.async_telebot import AsyncTeleBot
from database.db_handler import get_signals_count
from utils.logger import general_logger

async def count_signals(message, bot: AsyncTeleBot):
    general_logger.info("Ğ—Ğ°Ğ¿ÑƒÑ‰ĞµĞ½Ğ° ĞºĞ¾Ğ¼Ğ°Ğ½Ğ´Ğ° /count.")
    active_count, closed_count = get_signals_count()
    await bot.reply_to(
        message,
        f"ĞšĞ¾Ğ»Ğ¸Ñ‡ĞµÑÑ‚Ğ²Ğ¾ Ğ¾Ñ‚ĞºÑ€Ñ‹Ñ‚Ñ‹Ñ… ÑĞ¸Ğ³Ğ½Ğ°Ğ»Ğ¾Ğ²: {active_count}\nĞšĞ¾Ğ»Ğ¸Ñ‡ĞµÑÑ‚Ğ²Ğ¾ Ğ·Ğ°ĞºÑ€Ñ‹Ñ‚Ñ‹Ñ… ÑĞ¸Ğ³Ğ½Ğ°Ğ»Ğ¾Ğ²: {closed_count}"
    )
    general_logger.info(
        f"ĞšĞ¾Ğ»Ğ¸Ñ‡ĞµÑÑ‚Ğ²Ğ¾ Ğ¾Ñ‚ĞºÑ€Ñ‹Ñ‚Ñ‹Ñ… ÑĞ¸Ğ³Ğ½Ğ°Ğ»Ğ¾Ğ²: {active_count}, Ğ·Ğ°ĞºÑ€Ñ‹Ñ‚Ñ‹Ñ… ÑĞ¸Ğ³Ğ½Ğ°Ğ»Ğ¾Ğ²: {closed_count}"
    )
--------------------------------------------------------------------------------
Path: /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/bot/handlers/commands/interval.py
File Name: interval.py
Code:
from bot.scheduler import update_scheduler_interval, get_current_interval, start_scheduler
from config import CHANNEL_ID

async def change_interval(message, bot):
    command_parts = message.text.split()

    if len(command_parts) == 1:
        # Ğ•ÑĞ»Ğ¸ ĞºĞ¾Ğ¼Ğ°Ğ½Ğ´Ğ° Ğ±ĞµĞ· Ğ°Ñ€Ğ³ÑƒĞ¼ĞµĞ½Ñ‚Ğ¾Ğ², Ğ¿Ğ¾ĞºĞ°Ğ·Ñ‹Ğ²Ğ°ĞµĞ¼ Ñ‚ĞµĞºÑƒÑ‰Ğ¸Ğ¹ Ğ¸Ğ½Ñ‚ĞµÑ€Ğ²Ğ°Ğ»
        current_interval = get_current_interval()
        if current_interval:
            await bot.send_message(message.chat.id,
                                   f"Ğ¢ĞµĞºÑƒÑ‰Ğ¸Ğ¹ Ğ¸Ğ½Ñ‚ĞµÑ€Ğ²Ğ°Ğ» Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ĞºĞ¸: {int(current_interval // 60)} Ğ¼Ğ¸Ğ½ÑƒÑ‚.")
        else:
            await bot.send_message(message.chat.id, "ĞŸĞ»Ğ°Ğ½Ğ¸Ñ€Ğ¾Ğ²Ñ‰Ğ¸Ğº Ğ½Ğµ Ğ·Ğ°Ğ¿ÑƒÑ‰ĞµĞ½.")
    elif len(command_parts) == 2:
        try:
            # ĞŸÑ‹Ñ‚Ğ°ĞµĞ¼ÑÑ Ğ¿Ñ€ĞµĞ¾Ğ±Ñ€Ğ°Ğ·Ğ¾Ğ²Ğ°Ñ‚ÑŒ Ğ°Ñ€Ğ³ÑƒĞ¼ĞµĞ½Ñ‚ Ğ² Ğ¼Ğ¸Ğ½ÑƒÑ‚Ñ‹
            new_interval_minutes = int(command_parts[1])
            if new_interval_minutes <= 0:
                raise ValueError("Ğ˜Ğ½Ñ‚ĞµÑ€Ğ²Ğ°Ğ» Ğ´Ğ¾Ğ»Ğ¶ĞµĞ½ Ğ±Ñ‹Ñ‚ÑŒ Ğ¿Ğ¾Ğ»Ğ¾Ğ¶Ğ¸Ñ‚ĞµĞ»ÑŒĞ½Ñ‹Ğ¼ Ñ‡Ğ¸ÑĞ»Ğ¾Ğ¼.")

            # ĞĞ±Ğ½Ğ¾Ğ²Ğ»ÑĞµĞ¼ Ğ¸Ğ½Ñ‚ĞµÑ€Ğ²Ğ°Ğ» (Ğ² ÑĞµĞºÑƒĞ½Ğ´Ğ°Ñ…)
            new_interval_seconds = new_interval_minutes * 60
            if get_current_interval() is None:
                # Ğ•ÑĞ»Ğ¸ Ğ¿Ğ»Ğ°Ğ½Ğ¸Ñ€Ğ¾Ğ²Ñ‰Ğ¸Ğº Ğ½Ğµ Ğ±Ñ‹Ğ» Ğ·Ğ°Ğ¿ÑƒÑ‰ĞµĞ½, Ğ·Ğ°Ğ¿ÑƒÑĞºĞ°ĞµĞ¼ ĞµĞ³Ğ¾
                await start_scheduler(new_interval_seconds, CHANNEL_ID, bot)
            else:
                update_scheduler_interval(new_interval_seconds)
            await bot.send_message(message.chat.id,
                                   f"Ğ˜Ğ½Ñ‚ĞµÑ€Ğ²Ğ°Ğ» Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ĞºĞ¸ Ğ¾Ğ±Ğ½Ğ¾Ğ²Ğ»ĞµĞ½ Ğ´Ğ¾ {new_interval_minutes} Ğ¼Ğ¸Ğ½ÑƒÑ‚.")
        except ValueError as e:
            await bot.send_message(message.chat.id,
                                   f"ĞÑˆĞ¸Ğ±ĞºĞ°: {str(e)}\nĞŸĞ¾Ğ¶Ğ°Ğ»ÑƒĞ¹ÑÑ‚Ğ°, ÑƒĞºĞ°Ğ¶Ğ¸Ñ‚Ğµ Ğ¿Ğ¾Ğ»Ğ¾Ğ¶Ğ¸Ñ‚ĞµĞ»ÑŒĞ½Ğ¾Ğµ Ñ†ĞµĞ»Ğ¾Ğµ Ñ‡Ğ¸ÑĞ»Ğ¾ Ğ¼Ğ¸Ğ½ÑƒÑ‚.")
    else:
        await bot.send_message(message.chat.id, "Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ: /interval [Ñ‡Ğ¸ÑĞ»Ğ¾_Ğ¼Ğ¸Ğ½ÑƒÑ‚]")
--------------------------------------------------------------------------------
Path: /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/bot/handlers/commands/stop.py
File Name: stop.py
Code:
import asyncio
from telebot.async_telebot import AsyncTeleBot
from utils.logger import general_logger
from bot.scheduler import stop_scheduler

check_task = None

async def stop_bot(message, bot: AsyncTeleBot):
    global check_task
    if check_task and not check_task.done():
        check_task.cancel()
        try:
            await check_task
        except asyncio.CancelledError:
            pass
        check_task = None
        stop_scheduler()  # ĞÑÑ‚Ğ°Ğ½Ğ°Ğ²Ğ»Ğ¸Ğ²Ğ°ĞµĞ¼ Ğ¿Ğ»Ğ°Ğ½Ğ¸Ñ€Ğ¾Ğ²Ñ‰Ğ¸Ğº
        general_logger.info("Ğ‘Ğ¾Ñ‚ Ğ¾ÑÑ‚Ğ°Ğ½Ğ¾Ğ²Ğ»ĞµĞ½. ĞŸĞµÑ€Ğ¸Ğ¾Ğ´Ğ¸Ñ‡ĞµÑĞºĞ¸Ğµ Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ĞºĞ¸ Ğ´ĞµĞ°ĞºÑ‚Ğ¸Ğ²Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ñ‹.")
        response = "Ğ‘Ğ¾Ñ‚ Ğ¾ÑÑ‚Ğ°Ğ½Ğ¾Ğ²Ğ»ĞµĞ½. ĞŸĞµÑ€Ğ¸Ğ¾Ğ´Ğ¸Ñ‡ĞµÑĞºĞ¸Ğµ Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ĞºĞ¸ Ğ´ĞµĞ°ĞºÑ‚Ğ¸Ğ²Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ñ‹."
        await bot.reply_to(message, response)
    else:
        general_logger.info("Ğ‘Ğ¾Ñ‚ Ğ½Ğµ Ğ·Ğ°Ğ¿ÑƒÑ‰ĞµĞ½.")
        response = "Ğ‘Ğ¾Ñ‚ Ğ½Ğµ Ğ·Ğ°Ğ¿ÑƒÑ‰ĞµĞ½."
        await bot.reply_to(message, response)
--------------------------------------------------------------------------------
Path: /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/bot/handlers/commands/__init__.py
File Name: __init__.py
Code:
from .stop import stop_bot
from .show_signals import show_signals, send_pending_signals
from .count_signals import count_signals
from .delete_tables import delete_tables
from .table_signals import table_signals
from .actual_send import toggle_actual_send
from .interval import change_interval
from .help import send_help
from .logs import send_logs
from .delete_logs import delete_logs
from .start import start_bot
from .menu_handlers import get_main_menu_markup, show_signals_button, count_signals_button, start_bot_button, stop_bot_button, help_button
from .scheduler_command import start_scheduler_command

__all__ = [
    'start_bot', 'stop_bot', 'show_signals', 'count_signals',
    'delete_tables', 'table_signals', 'toggle_actual_send',
    'change_interval', 'send_help', 'send_logs', 'delete_logs',
    'get_main_menu_markup', 'show_signals_button', 'count_signals_button',
    'start_bot_button', 'stop_bot_button', 'help_button', 'send_pending_signals',
    'start_scheduler_command'
]
--------------------------------------------------------------------------------
Path: /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/bot/handlers/commands/actual_send.py
File Name: actual_send.py
Code:
from config import toggle_actual_signals, get_actual_signals_status
from utils.logger import general_logger


async def toggle_actual_send(message, bot):
    new_status = toggle_actual_signals()
    status = "Ğ²ĞºĞ»ÑÑ‡ĞµĞ½Ğ°" if new_status else "Ğ¾Ñ‚ĞºĞ»ÑÑ‡ĞµĞ½Ğ°"
    response = f"ĞÑ‚Ğ¿Ñ€Ğ°Ğ²ĞºĞ° Ğ°ĞºÑ‚ÑƒĞ°Ğ»ÑŒĞ½Ñ‹Ñ… ÑĞ¸Ğ³Ğ½Ğ°Ğ»Ğ¾Ğ² {status}."
    await bot.send_message(message.chat.id, response)
    general_logger.info(response)

    if not new_status:
        additional_info = "ĞÑ‚Ğ¿Ñ€Ğ°Ğ²ĞºĞ° Ğ°ĞºÑ‚ÑƒĞ°Ğ»ÑŒĞ½Ñ‹Ñ… ÑĞ¸Ğ³Ğ½Ğ°Ğ»Ğ¾Ğ² Ğ¾Ñ‚ĞºĞ»ÑÑ‡ĞµĞ½Ğ°. ĞĞ¾Ğ²Ñ‹Ğµ Ğ¸ Ğ·Ğ°ĞºÑ€Ñ‹Ñ‚Ñ‹Ğµ ÑĞ¸Ğ³Ğ½Ğ°Ğ»Ñ‹ Ğ²ÑÑ‘ Ñ€Ğ°Ğ²Ğ½Ğ¾ Ğ±ÑƒĞ´ÑƒÑ‚ Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²Ğ»ÑÑ‚ÑŒÑÑ."
    else:
        additional_info = "ĞÑ‚Ğ¿Ñ€Ğ°Ğ²ĞºĞ° Ğ°ĞºÑ‚ÑƒĞ°Ğ»ÑŒĞ½Ñ‹Ñ… ÑĞ¸Ğ³Ğ½Ğ°Ğ»Ğ¾Ğ² Ğ²ĞºĞ»ÑÑ‡ĞµĞ½Ğ°."

    await bot.send_message(message.chat.id, additional_info)
    general_logger.info(additional_info)
--------------------------------------------------------------------------------
Path: /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/bot/handlers/commands/start.py
File Name: start.py
Code:
from telebot.async_telebot import AsyncTeleBot
from utils.logger import general_logger
from config import CHECK_INTERVAL, CRYPTO_PAIRS
from bot.scheduler import start_scheduler
from database.db_handler import get_active_signals, get_closed_signals, mark_signal_as_reported
from utils.message_formatter import format_new_signal_message, format_closed_signal_message
from .menu_handlers import get_main_menu_markup  # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑŒÑ‚Ğµ Ğ¿Ñ€Ğ°Ğ²Ğ¸Ğ»ÑŒĞ½Ğ¾ÑÑ‚ÑŒ Ğ¿ÑƒÑ‚Ğ¸ Ğ¸ Ğ¸Ğ¼ĞµĞ½Ğ¸ Ñ„Ğ°Ğ¹Ğ»Ğ°
from bot.handlers.utils import send_signal_messages
from services.signal_manager import check_and_create_signals

import asyncio

check_task = None

async def start_bot(message, bot: AsyncTeleBot):
    global check_task
    chat_id = message.chat.id  # ĞŸĞ¾Ğ»ÑƒÑ‡Ğ°ĞµĞ¼ chat_id Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ Ğ¸Ğ· ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ñ

    if check_task is None or check_task.done():
        general_logger.info("Ğ‘Ğ¾Ñ‚ Ğ·Ğ°Ğ¿ÑƒÑĞºĞ°ĞµÑ‚ÑÑ.")
        response = "Ğ‘Ğ¾Ñ‚ Ğ·Ğ°Ğ¿ÑƒÑ‰ĞµĞ½ Ğ¸ Ğ³Ğ¾Ñ‚Ğ¾Ğ² Ğº Ñ€Ğ°Ğ±Ğ¾Ñ‚Ğµ. Ğ’Ñ‹Ğ¿Ğ¾Ğ»Ğ½ÑĞµÑ‚ÑÑ Ğ½Ğ°Ñ‡Ğ°Ğ»ÑŒĞ½Ñ‹Ğ¹ Ğ°Ğ½Ğ°Ğ»Ğ¸Ğ·..."
        await bot.reply_to(message, response, reply_markup=get_main_menu_markup())

        # Ğ’Ñ‹Ğ¿Ğ¾Ğ»Ğ½Ğ¸Ñ‚ÑŒ Ğ½Ğ°Ñ‡Ğ°Ğ»ÑŒĞ½Ñ‹Ğ¹ Ğ°Ğ½Ğ°Ğ»Ğ¸Ğ· Ğ¸ Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²Ğ¸Ñ‚ÑŒ ÑĞ¸Ğ³Ğ½Ğ°Ğ»Ñ‹
        check_task = asyncio.create_task(process_and_send_signals(bot, chat_id))
        await check_task

        # Ğ—Ğ°Ğ¿ÑƒÑÑ‚Ğ¸Ñ‚ÑŒ Ğ¿Ğ»Ğ°Ğ½Ğ¸Ñ€Ğ¾Ğ²Ñ‰Ğ¸Ğº Ñ chat_id
        await start_scheduler(CHECK_INTERVAL, bot, chat_id)

        general_logger.info("ĞŸĞµÑ€Ğ¸Ğ¾Ğ´Ğ¸Ñ‡ĞµÑĞºĞ°Ñ Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ĞºĞ° ÑĞ¸Ğ³Ğ½Ğ°Ğ»Ğ¾Ğ² Ğ·Ğ°Ğ¿ÑƒÑ‰ĞµĞ½Ğ°.")
        await bot.send_message(chat_id, "ĞĞ°Ñ‡Ğ°Ğ»ÑŒĞ½Ñ‹Ğ¹ Ğ°Ğ½Ğ°Ğ»Ğ¸Ğ· Ğ·Ğ°Ğ²ĞµÑ€ÑˆĞµĞ½. Ğ‘Ğ¾Ñ‚ Ğ³Ğ¾Ñ‚Ğ¾Ğ² Ğº Ñ€Ğ°Ğ±Ğ¾Ñ‚Ğµ.")
    else:
        general_logger.info("Ğ‘Ğ¾Ñ‚ ÑƒĞ¶Ğµ Ñ€Ğ°Ğ±Ğ¾Ñ‚Ğ°ĞµÑ‚.")
        response = "Ğ‘Ğ¾Ñ‚ ÑƒĞ¶Ğµ Ñ€Ğ°Ğ±Ğ¾Ñ‚Ğ°ĞµÑ‚. Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞ¹Ñ‚Ğµ ĞºĞ½Ğ¾Ğ¿ĞºĞ¸ Ğ¼ĞµĞ½Ñ Ğ´Ğ»Ñ ÑƒĞ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ¸Ñ."
        await bot.reply_to(message, response, reply_markup=get_main_menu_markup())

async def process_and_send_signals(bot: AsyncTeleBot, chat_id):
    general_logger.info("Ğ’Ñ‹Ğ¿Ğ¾Ğ»Ğ½ĞµĞ½Ğ¸Ğµ Ğ½Ğ°Ñ‡Ğ°Ğ»ÑŒĞ½Ğ¾Ğ³Ğ¾ Ğ°Ğ½Ğ°Ğ»Ğ¸Ğ·Ğ° Ğ¸ Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²ĞºĞ° ÑĞ¸Ğ³Ğ½Ğ°Ğ»Ğ¾Ğ².")

    # Ğ’Ñ‹Ğ·Ğ¾Ğ² Ñ„ÑƒĞ½ĞºÑ†Ğ¸Ğ¸ Ğ´Ğ»Ñ Ğ°Ğ½Ğ°Ğ»Ğ¸Ğ·Ğ° ÑĞ¸Ğ³Ğ½Ğ°Ğ»Ğ¾Ğ²
    new_signals, updated_signals, closed_signals = await check_and_create_signals(CRYPTO_PAIRS)

    # ĞÑ‚Ğ¿Ñ€Ğ°Ğ²ĞºĞ° Ğ°ĞºÑ‚Ğ¸Ğ²Ğ½Ñ‹Ñ… ÑĞ¸Ğ³Ğ½Ğ°Ğ»Ğ¾Ğ²
    if new_signals or updated_signals:
        await bot.send_message(
            chat_id,
            f"ĞšĞ¾Ğ»Ğ¸Ñ‡ĞµÑÑ‚Ğ²Ğ¾ Ğ°ĞºÑ‚Ğ¸Ğ²Ğ½Ñ‹Ñ… ÑĞ¸Ğ³Ğ½Ğ°Ğ»Ğ¾Ğ²: {len(new_signals) + len(updated_signals)}"
        )
        await send_signal_messages(
            chat_id=chat_id,
            signals=new_signals + updated_signals,
            format_message_func=format_new_signal_message
        )

    # ĞÑ‚Ğ¿Ñ€Ğ°Ğ²ĞºĞ° Ğ·Ğ°ĞºÑ€Ñ‹Ñ‚Ñ‹Ñ… ÑĞ¸Ğ³Ğ½Ğ°Ğ»Ğ¾Ğ²
    if closed_signals:
        await bot.send_message(
            chat_id,
            f"ĞšĞ¾Ğ»Ğ¸Ñ‡ĞµÑÑ‚Ğ²Ğ¾ Ğ·Ğ°ĞºÑ€Ñ‹Ñ‚Ñ‹Ñ… ÑĞ¸Ğ³Ğ½Ğ°Ğ»Ğ¾Ğ²: {len(closed_signals)}"
        )
        await send_signal_messages(
            chat_id=chat_id,
            signals=closed_signals,
            format_message_func=format_closed_signal_message
        )
        for signal in closed_signals:
            mark_signal_as_reported(signal.id)
        general_logger.info("Ğ—Ğ°ĞºÑ€Ñ‹Ñ‚Ñ‹Ğµ ÑĞ¸Ğ³Ğ½Ğ°Ğ»Ñ‹ Ğ¾Ğ±Ñ€Ğ°Ğ±Ğ¾Ñ‚Ğ°Ğ½Ñ‹ Ğ¸ Ğ¾Ñ‚Ğ¼ĞµÑ‡ĞµĞ½Ñ‹ ĞºĞ°Ğº Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ½Ñ‹Ğµ.")
    else:
        await bot.send_message(chat_id, "Ğ’ Ğ´Ğ°Ğ½Ğ½Ñ‹Ğ¹ Ğ¼Ğ¾Ğ¼ĞµĞ½Ñ‚ Ğ½ĞµÑ‚ Ğ·Ğ°ĞºÑ€Ñ‹Ñ‚Ñ‹Ñ… ÑĞ¸Ğ³Ğ½Ğ°Ğ»Ğ¾Ğ².")
--------------------------------------------------------------------------------
Path: /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/bot/handlers/commands/delete_tables.py
File Name: delete_tables.py
Code:
from telebot.async_telebot import AsyncTeleBot
from database.db_handler import delete_all_tables, init_db
from utils.logger import general_logger

async def delete_tables(message, bot: AsyncTeleBot):
    general_logger.info("Ğ—Ğ°Ğ¿ÑƒÑ‰ĞµĞ½Ğ° ĞºĞ¾Ğ¼Ğ°Ğ½Ğ´Ğ° /delete_tables.")
    delete_all_tables()
    init_db()
    await bot.reply_to(message, "Ğ’ÑĞµ Ñ‚Ğ°Ğ±Ğ»Ğ¸Ñ†Ñ‹ Ğ±Ñ‹Ğ»Ğ¸ ÑƒĞ´Ğ°Ğ»ĞµĞ½Ñ‹ Ğ¸ Ğ·Ğ°Ğ½Ğ¾Ğ²Ğ¾ ÑĞ¾Ğ·Ğ´Ğ°Ğ½Ñ‹.")
    general_logger.info("Ğ’ÑĞµ Ñ‚Ğ°Ğ±Ğ»Ğ¸Ñ†Ñ‹ ÑƒĞ´Ğ°Ğ»ĞµĞ½Ñ‹ Ğ¸ Ğ·Ğ°Ğ½Ğ¾Ğ²Ğ¾ ÑĞ¾Ğ·Ğ´Ğ°Ğ½Ñ‹.")
--------------------------------------------------------------------------------
Path: /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/bot/handlers/commands/logs.py
File Name: logs.py
Code:
import logging
from pathlib import Path
from telebot.async_telebot import AsyncTeleBot
from utils.logger import general_logger

async def send_logs(message, bot: AsyncTeleBot):
    general_logger.info("Ğ—Ğ°Ğ¿Ñ€Ğ¾Ñ Ğ»Ğ¾Ğ³Ğ¾Ğ² Ñ‡ĞµÑ€ĞµĞ· ĞºĞ¾Ğ¼Ğ°Ğ½Ğ´Ñƒ /logs")
    log_dir = Path(__file__).parents[4] / 'crypto_trend_bot' / 'logs'

    try:
        files = list(log_dir.iterdir())  # ĞŸĞ¾Ğ»ÑƒÑ‡Ğ°ĞµĞ¼ Ğ²ÑĞµ Ñ„Ğ°Ğ¹Ğ»Ñ‹ Ğ² Ğ´Ğ¸Ñ€ĞµĞºÑ‚Ğ¾Ñ€Ğ¸Ğ¸
        if not files:
            await bot.send_message(message.chat.id, "ĞĞµÑ‚ Ğ´Ğ¾ÑÑ‚ÑƒĞ¿Ğ½Ñ‹Ñ… Ñ„Ğ°Ğ¹Ğ»Ğ¾Ğ² Ğ´Ğ»Ñ Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²ĞºĞ¸.")
            general_logger.info("ĞĞµÑ‚ Ğ´Ğ¾ÑÑ‚ÑƒĞ¿Ğ½Ñ‹Ñ… Ñ„Ğ°Ğ¹Ğ»Ğ¾Ğ² Ğ´Ğ»Ñ Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²ĞºĞ¸.")
            return

        for log_file in files:
            if log_file.is_file():  # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼, Ñ‡Ñ‚Ğ¾ ÑÑ‚Ğ¾ Ñ„Ğ°Ğ¹Ğ», Ğ° Ğ½Ğµ Ğ´Ğ¸Ñ€ĞµĞºÑ‚Ğ¾Ñ€Ğ¸Ñ
                if log_file.stat().st_size == 0:
                    logging.info(f"Ğ¤Ğ°Ğ¹Ğ» {log_file.name} Ğ¿ÑƒÑÑ‚Ğ¾Ğ¹, Ğ¿Ñ€Ğ¾Ğ¿ÑƒÑĞºĞ°ĞµĞ¼ ĞµĞ³Ğ¾ Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²ĞºÑƒ.")
                    await bot.send_message(message.chat.id,
                                           f"Ğ¤Ğ°Ğ¹Ğ» {log_file.name} Ğ¿ÑƒÑÑ‚Ğ¾Ğ¹ Ğ¸ Ğ½Ğµ Ğ±ÑƒĞ´ĞµÑ‚ Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½.")
                    continue

                with open(log_file, 'rb') as file:
                    await bot.send_document(message.chat.id, file, caption=f"Ğ¤Ğ°Ğ¹Ğ»: {log_file.name}")
                    general_logger.info(f"Ğ¤Ğ°Ğ¹Ğ» {log_file.name} Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½.")

    except Exception as e:
        general_logger.error(f"ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¿Ñ€Ğ¸ Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²ĞºĞµ Ñ„Ğ°Ğ¹Ğ»Ğ¾Ğ²: {e}")
        await bot.send_message(message.chat.id, "ĞŸÑ€Ğ¾Ğ¸Ğ·Ğ¾ÑˆĞ»Ğ° Ğ¾ÑˆĞ¸Ğ±ĞºĞ° Ğ¿Ñ€Ğ¸ Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²ĞºĞµ Ñ„Ğ°Ğ¹Ğ»Ğ¾Ğ².")
--------------------------------------------------------------------------------
Path: /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/bot/handlers/commands/scheduler_command.py
File Name: scheduler_command.py
Code:
import logging
from bot.scheduler import start_scheduler, get_current_interval
from config import CHECK_INTERVAL

async def start_scheduler_command(message, bot):
    try:
        # ĞŸĞ¾Ğ»ÑƒÑ‡Ğ°ĞµĞ¼ Ñ‚ĞµĞºÑƒÑ‰Ğ¸Ğ¹ Ğ¸Ğ½Ñ‚ĞµÑ€Ğ²Ğ°Ğ», ĞµÑĞ»Ğ¸ Ğ¿Ğ»Ğ°Ğ½Ğ¸Ñ€Ğ¾Ğ²Ñ‰Ğ¸Ğº ÑƒĞ¶Ğµ Ğ·Ğ°Ğ¿ÑƒÑ‰ĞµĞ½
        current_interval = get_current_interval()

        if current_interval is None:
            # Ğ•ÑĞ»Ğ¸ Ğ¿Ğ»Ğ°Ğ½Ğ¸Ñ€Ğ¾Ğ²Ñ‰Ğ¸Ğº Ğ½Ğµ Ğ·Ğ°Ğ¿ÑƒÑ‰ĞµĞ½, Ğ·Ğ°Ğ¿ÑƒÑĞºĞ°ĞµĞ¼ ĞµĞ³Ğ¾ Ñ Ğ¸Ğ½Ñ‚ĞµÑ€Ğ²Ğ°Ğ»Ğ¾Ğ¼ Ğ¸Ğ· ĞºĞ¾Ğ½Ñ„Ğ¸Ğ³ÑƒÑ€Ğ°Ñ†Ğ¸Ğ¸
            await start_scheduler(CHECK_INTERVAL, bot)
            await bot.reply_to(message, f"ĞŸĞ»Ğ°Ğ½Ğ¸Ñ€Ğ¾Ğ²Ñ‰Ğ¸Ğº ÑƒÑĞ¿ĞµÑˆĞ½Ğ¾ Ğ·Ğ°Ğ¿ÑƒÑ‰ĞµĞ½ Ñ Ğ¸Ğ½Ñ‚ĞµÑ€Ğ²Ğ°Ğ»Ğ¾Ğ¼ {CHECK_INTERVAL} ÑĞµĞºÑƒĞ½Ğ´.")
            logging.info("ĞŸĞ»Ğ°Ğ½Ğ¸Ñ€Ğ¾Ğ²Ñ‰Ğ¸Ğº ÑƒÑĞ¿ĞµÑˆĞ½Ğ¾ Ğ·Ğ°Ğ¿ÑƒÑ‰ĞµĞ½.")
        else:
            # Ğ•ÑĞ»Ğ¸ Ğ¿Ğ»Ğ°Ğ½Ğ¸Ñ€Ğ¾Ğ²Ñ‰Ğ¸Ğº ÑƒĞ¶Ğµ Ğ·Ğ°Ğ¿ÑƒÑ‰ĞµĞ½, ÑƒĞ²ĞµĞ´Ğ¾Ğ¼Ğ»ÑĞµĞ¼ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ
            await bot.reply_to(message, f"ĞŸĞ»Ğ°Ğ½Ğ¸Ñ€Ğ¾Ğ²Ñ‰Ğ¸Ğº ÑƒĞ¶Ğµ Ğ·Ğ°Ğ¿ÑƒÑ‰ĞµĞ½ Ñ Ğ¸Ğ½Ñ‚ĞµÑ€Ğ²Ğ°Ğ»Ğ¾Ğ¼ {current_interval} ÑĞµĞºÑƒĞ½Ğ´.")
            logging.info(f"ĞŸĞ¾Ğ¿Ñ‹Ñ‚ĞºĞ° Ğ·Ğ°Ğ¿ÑƒÑĞºĞ° Ğ¿Ğ»Ğ°Ğ½Ğ¸Ñ€Ğ¾Ğ²Ñ‰Ğ¸ĞºĞ°, Ğ½Ğ¾ Ğ¾Ğ½ ÑƒĞ¶Ğµ Ğ·Ğ°Ğ¿ÑƒÑ‰ĞµĞ½ Ñ Ğ¸Ğ½Ñ‚ĞµÑ€Ğ²Ğ°Ğ»Ğ¾Ğ¼ {current_interval} ÑĞµĞºÑƒĞ½Ğ´.")
    except Exception as e:
        logging.error(f"ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¿Ñ€Ğ¸ Ğ·Ğ°Ğ¿ÑƒÑĞºĞµ Ğ¿Ğ»Ğ°Ğ½Ğ¸Ñ€Ğ¾Ğ²Ñ‰Ğ¸ĞºĞ°: {e}")
        await bot.reply_to(message, "ĞŸÑ€Ğ¾Ğ¸Ğ·Ğ¾ÑˆĞ»Ğ° Ğ¾ÑˆĞ¸Ğ±ĞºĞ° Ğ¿Ñ€Ğ¸ Ğ·Ğ°Ğ¿ÑƒÑĞºĞµ Ğ¿Ğ»Ğ°Ğ½Ğ¸Ñ€Ğ¾Ğ²Ñ‰Ğ¸ĞºĞ°.")
--------------------------------------------------------------------------------
Path: /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/bot/handlers/commands/help.py
File Name: help.py
Code:
from telebot.async_telebot import AsyncTeleBot
from utils.logger import general_logger
from .menu_handlers import get_main_menu_markup

async def send_help(message, bot: AsyncTeleBot):
    general_logger.info("ĞÑ‚Ğ¿Ñ€Ğ°Ğ²ĞºĞ° ÑĞ¿Ñ€Ğ°Ğ²Ğ¾Ñ‡Ğ½Ğ¾Ğ¹ Ğ¸Ğ½Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ†Ğ¸Ğ¸.")
    help_text = """
Ğ”Ğ¾ÑÑ‚ÑƒĞ¿Ğ½Ñ‹Ğµ ĞºĞ¾Ğ¼Ğ°Ğ½Ğ´Ñ‹:
/start - Ğ—Ğ°Ğ¿ÑƒÑÑ‚Ğ¸Ñ‚ÑŒ Ğ±Ğ¾Ñ‚Ğ° Ğ¸ Ğ°ĞºÑ‚Ğ¸Ğ²Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ Ğ¿ĞµÑ€Ğ¸Ğ¾Ğ´Ğ¸Ñ‡ĞµÑĞºĞ¸Ğµ Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ĞºĞ¸
/stop - ĞÑÑ‚Ğ°Ğ½Ğ¾Ğ²Ğ¸Ñ‚ÑŒ Ğ±Ğ¾Ñ‚Ğ° Ğ¸ Ğ´ĞµĞ°ĞºÑ‚Ğ¸Ğ²Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ Ğ¿ĞµÑ€Ğ¸Ğ¾Ğ´Ğ¸Ñ‡ĞµÑĞºĞ¸Ğµ Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ĞºĞ¸
/show - ĞŸĞ¾ĞºĞ°Ğ·Ğ°Ñ‚ÑŒ Ñ‚ĞµĞºÑƒÑ‰Ğ¸Ğµ Ğ°ĞºÑ‚Ğ¸Ğ²Ğ½Ñ‹Ğµ Ğ¸ Ğ·Ğ°ĞºÑ€Ñ‹Ñ‚Ñ‹Ğµ ÑĞ¸Ğ³Ğ½Ğ°Ğ»Ñ‹
/count - ĞŸĞ¾ĞºĞ°Ğ·Ğ°Ñ‚ÑŒ ĞºĞ¾Ğ»Ğ¸Ñ‡ĞµÑÑ‚Ğ²Ğ¾ Ğ¾Ñ‚ĞºÑ€Ñ‹Ñ‚Ñ‹Ñ… Ğ¸ Ğ·Ğ°ĞºÑ€Ñ‹Ñ‚Ñ‹Ñ… ÑĞ¸Ğ³Ğ½Ğ°Ğ»Ğ¾Ğ²
/delete_tables - Ğ£Ğ´Ğ°Ğ»Ğ¸Ñ‚ÑŒ Ğ²ÑĞµ Ñ‚Ğ°Ğ±Ğ»Ğ¸Ñ†Ñ‹ Ğ² Ğ±Ğ°Ğ·Ğµ Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ… (Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞ¹Ñ‚Ğµ Ñ Ğ¾ÑÑ‚Ğ¾Ñ€Ğ¾Ğ¶Ğ½Ğ¾ÑÑ‚ÑŒÑ!)
/table_signals - ĞŸĞ¾ĞºĞ°Ğ·Ğ°Ñ‚ÑŒ ÑĞ¾Ğ´ĞµÑ€Ğ¶Ğ¸Ğ¼Ğ¾Ğµ Ñ‚Ğ°Ğ±Ğ»Ğ¸Ñ†Ñ‹ `signals`
/help - ĞŸĞ¾ĞºĞ°Ğ·Ğ°Ñ‚ÑŒ ÑÑ‚Ğ¾ ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ğµ Ğ¿Ğ¾Ğ¼Ğ¾Ñ‰Ğ¸
/interval - Ğ˜Ğ·Ğ¼ĞµĞ½Ğ¸Ñ‚ÑŒ Ğ¸Ğ½Ñ‚ĞµÑ€Ğ²Ğ°Ğ» Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ĞºĞ¸ Ğ¸Ğ»Ğ¸ Ğ¿Ğ¾ĞºĞ°Ğ·Ğ°Ñ‚ÑŒ Ñ‚ĞµĞºÑƒÑ‰Ğ¸Ğ¹ Ğ¸Ğ½Ñ‚ĞµÑ€Ğ²Ğ°Ğ»
/actual_send - Ğ’ĞºĞ»ÑÑ‡Ğ¸Ñ‚ÑŒ/Ğ²Ñ‹ĞºĞ»ÑÑ‡Ğ¸Ñ‚ÑŒ Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²ĞºÑƒ Ğ°ĞºÑ‚ÑƒĞ°Ğ»ÑŒĞ½Ñ‹Ñ… ÑĞ¸Ğ³Ğ½Ğ°Ğ»Ğ¾Ğ²
/logs - ĞŸĞ¾ĞºĞ°Ğ·Ğ°Ñ‚ÑŒ Ñ„Ğ°Ğ¹Ğ»Ñ‹ Ğ»Ğ¾Ğ³Ğ¾Ğ²
/delete_logs - Ğ£Ğ´Ğ°Ğ»Ğ¸Ñ‚ÑŒ Ğ²ÑĞµ Ñ„Ğ°Ğ¹Ğ»Ñ‹ Ğ»Ğ¾Ğ³Ğ¾Ğ² (Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞ¹Ñ‚Ğµ Ñ Ğ¾ÑÑ‚Ğ¾Ñ€Ğ¾Ğ¶Ğ½Ğ¾ÑÑ‚ÑŒÑ!)
    """
    await bot.reply_to(message, help_text, reply_markup=get_main_menu_markup())
    general_logger.info("Ğ¡Ğ¿Ñ€Ğ°Ğ²Ğ¾Ñ‡Ğ½Ğ°Ñ Ğ¸Ğ½Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ†Ğ¸Ñ Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ°.")
--------------------------------------------------------------------------------
Path: /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/bot/handlers/commands/table_signals.py
File Name: table_signals.py
Code:
from telebot.async_telebot import AsyncTeleBot
from database.db_handler import fetch_all_signals
from utils.logger import general_logger
from utils.message_formatter import format_signals_table, add_timestamp_and_separator

async def table_signals(message, bot: AsyncTeleBot):
    general_logger.info("Ğ—Ğ°Ğ¿ÑƒÑ‰ĞµĞ½Ğ° ĞºĞ¾Ğ¼Ğ°Ğ½Ğ´Ğ° /table_signals.")
    signals = fetch_all_signals()
    if not signals:
        await bot.reply_to(message, "Ğ¢Ğ°Ğ±Ğ»Ğ¸Ñ†Ğ° `signals` Ğ¿ÑƒÑÑ‚Ğ°.")
        general_logger.info("Ğ¢Ğ°Ğ±Ğ»Ğ¸Ñ†Ğ° `signals` Ğ¿ÑƒÑÑ‚Ğ°.")
    else:
        table_message = format_signals_table(signals)
        table_message = add_timestamp_and_separator(table_message)
        await bot.reply_to(message, table_message)
        general_logger.info("Ğ¢Ğ°Ğ±Ğ»Ğ¸Ñ†Ğ° `signals` Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ°.")
--------------------------------------------------------------------------------
Path: /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/bot/handlers/commands/show_signals.py
File Name: show_signals.py
Code:
from telebot.async_telebot import AsyncTeleBot
from database.db_handler import (
    get_active_signals,
    get_closed_signals,
    mark_signal_as_reported,
    get_signals_to_send,
    mark_signal_as_sent,
    get_signal_by_id,
    increment_count_sends
)
from utils.logger import general_logger
from utils.message_formatter import format_new_signal_message, format_closed_signal_message, \
    add_timestamp_and_separator
from bot.handlers.utils import send_signal_messages
from config import get_actual_signals_status

async def show_signals(message, bot: AsyncTeleBot):
    general_logger.info("Command /show initiated.")
    chat_id = message.chat.id

    active_signals = get_active_signals()
    if not active_signals:
        general_logger.info("No active signals found.")
        await bot.reply_to(message, "No active signals currently available.")
    else:
        general_logger.info(f"Found {len(active_signals)} active signals.")
        await bot.reply_to(message, f"Number of active signals: {len(active_signals)}")
        await send_signal_messages(
            chat_id=chat_id, signals=active_signals, format_message_func=format_new_signal_message
        )

    closed_signals = get_closed_signals()
    if closed_signals:
        general_logger.info(f"Found {len(closed_signals)} closed signals.")
        await bot.reply_to(message, f"Number of closed signals: {len(closed_signals)}")
        await send_signal_messages(
            chat_id=chat_id, signals=closed_signals,
            format_message_func=format_closed_signal_message
        )
        for signal in closed_signals:
            mark_signal_as_reported(signal.id)
        general_logger.info("Closed signals processed and marked as reported.")
    else:
        general_logger.info("No closed signals found.")
        await bot.reply_to(message, "No closed signals currently available.")


async def send_pending_signals(bot: AsyncTeleBot, chat_id):
    general_logger.info("Processing pending signals.")
    signals_to_send = get_signals_to_send()
    send_actual = get_actual_signals_status()

    signals_dict = {}
    for signal_id, signal_type in signals_to_send:
        signal = get_signal_by_id(signal_id)
        if signal:
            signals_dict[signal_id] = signal

    general_logger.info(f"Using chat_id: {chat_id}")

    if signals_dict:
        general_logger.info(
            f"Sending {len(signals_dict)} signals. Actual signals sending is {'enabled' if send_actual else 'disabled'}.")

        timestamp_message = add_timestamp_and_separator("")
        await bot.send_message(chat_id, timestamp_message)
        general_logger.info("Sent message with timestamp and separator")

        for signal in signals_dict.values():
            is_new = signal.count_sends == 0
            is_closed = signal.date_end is not None

            if is_new or is_closed or send_actual:
                if is_closed:
                    await send_signal_messages(
                        chat_id=chat_id,
                        signals=[signal],
                        format_message_func=format_closed_signal_message,
                        send_timestamp=False
                    )
                    mark_signal_as_reported(signal.id)
                else:
                    await send_signal_messages(
                        chat_id=chat_id,
                        signals=[signal],
                        format_message_func=format_new_signal_message,
                        is_new=is_new,
                        send_timestamp=False
                    )

                success = increment_count_sends(signal.id)
                if success:
                    general_logger.info(
                        f"Ğ£ÑĞ¿ĞµÑˆĞ½Ğ¾ ÑƒĞ²ĞµĞ»Ğ¸Ñ‡ĞµĞ½Ğ¾ count_sends Ğ´Ğ»Ñ ÑĞ¸Ğ³Ğ½Ğ°Ğ»Ğ° Ñ ID {signal.id}")
                else:
                    general_logger.warning(
                        f"ĞĞµ ÑƒĞ´Ğ°Ğ»Ğ¾ÑÑŒ ÑƒĞ²ĞµĞ»Ğ¸Ñ‡Ğ¸Ñ‚ÑŒ count_sends Ğ´Ğ»Ñ ÑĞ¸Ğ³Ğ½Ğ°Ğ»Ğ° Ñ ID {signal.id}")
                mark_signal_as_sent(signal.id)
            else:
                general_logger.info(
                    f"ĞŸÑ€Ğ¾Ğ¿ÑƒÑ‰ĞµĞ½ Ğ°ĞºÑ‚ÑƒĞ°Ğ»ÑŒĞ½Ñ‹Ğ¹ ÑĞ¸Ğ³Ğ½Ğ°Ğ» Ñ ID {signal.id} Ğ¸Ğ·-Ğ·Ğ° Ğ½Ğ°ÑÑ‚Ñ€Ğ¾ĞµĞº Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²ĞºĞ¸")

        general_logger.info(f"Sent signals processing completed.")
    else:
        general_logger.info("No new signals to send.")
        await bot.send_message(chat_id, "No new signals to send.")
--------------------------------------------------------------------------------
Path: /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/bot/handlers/commands/menu_handlers.py
File Name: menu_handlers.py
Code:
from telebot.async_telebot import AsyncTeleBot
from telebot.types import ReplyKeyboardMarkup, KeyboardButton

def get_main_menu_markup():
    main_menu_markup = ReplyKeyboardMarkup(resize_keyboard=True)
    main_menu_markup.row(KeyboardButton("ğŸ“Š ĞŸĞ¾ĞºĞ°Ğ·Ğ°Ñ‚ÑŒ ÑĞ¸Ğ³Ğ½Ğ°Ğ»Ñ‹"), KeyboardButton("ğŸ”¢ ĞšĞ¾Ğ»Ğ¸Ñ‡ĞµÑÑ‚Ğ²Ğ¾ "
                                                                              "ÑĞ¸Ğ³Ğ½Ğ°Ğ»Ğ¾Ğ²"))
    main_menu_markup.row(KeyboardButton("â–¶ï¸ Ğ¡Ñ‚Ğ°Ñ€Ñ‚"), KeyboardButton("â¹ Ğ¡Ñ‚Ğ¾Ğ¿"))
    main_menu_markup.row(KeyboardButton("ĞĞºÑ‚ÑƒĞ°Ğ»ÑŒĞ½Ğ°Ñ Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²ĞºĞ°"), KeyboardButton("â“ ĞŸĞ¾Ğ¼Ğ¾Ñ‰ÑŒ"))
    main_menu_markup.row(KeyboardButton("/delete_tables"), KeyboardButton("/table_signals"))
    main_menu_markup.row(KeyboardButton("/interval"), KeyboardButton("/actual_send"))
    main_menu_markup.row(KeyboardButton("/logs"), KeyboardButton("/delete_logs"))
    return main_menu_markup

async def show_signals_button(message, bot):
    from .show_signals import show_signals
    await show_signals(message, bot)

async def count_signals_button(message, bot):
    from .count_signals import count_signals
    await count_signals(message, bot)

async def start_bot_button(message, bot):
    from .start import start_bot
    await start_bot(message, bot)

async def stop_bot_button(message, bot):
    from .stop import stop_bot
    await stop_bot(message, bot)

async def actual_send_button(message, bot):
    await bot.send_message(message.chat.id, "Ğ’Ñ‹Ğ¿Ğ¾Ğ»Ğ½ÑĞµÑ‚ÑÑ ĞºĞ¾Ğ¼Ğ°Ğ½Ğ´Ğ° /actual_send")
    from .actual_send import toggle_actual_send  # Ğ˜Ğ¼Ğ¿Ğ¾Ñ€Ñ‚ Ğ·Ğ´ĞµÑÑŒ Ğ²Ğ¾ Ğ¸Ğ·Ğ±ĞµĞ¶Ğ°Ğ½Ğ¸Ğµ Ñ†Ğ¸ĞºĞ»Ğ¸Ñ‡ĞµÑĞºĞ¸Ñ… Ğ¸Ğ¼Ğ¿Ğ¾Ñ€Ñ‚Ğ¾Ğ²
    await toggle_actual_send(message, bot)

async def help_button(message, bot):
    from .help import send_help
    await send_help(message, bot)
--------------------------------------------------------------------------------
Error reading /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/bot/handlers/commands/__pycache__/logs.cpython-311.pyc: 'utf-8' codec can't decode byte 0xa7 in position 0: invalid start byte
Error reading /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/bot/handlers/commands/__pycache__/stop.cpython-311.pyc: 'utf-8' codec can't decode byte 0xa7 in position 0: invalid start byte
Error reading /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/bot/handlers/commands/__pycache__/menu_handlers.cpython-311.pyc: 'utf-8' codec can't decode byte 0xa7 in position 0: invalid start byte
Error reading /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/bot/handlers/commands/__pycache__/count_signals.cpython-311.pyc: 'utf-8' codec can't decode byte 0xa7 in position 0: invalid start byte
Error reading /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/bot/handlers/commands/__pycache__/delete_logs.cpython-311.pyc: 'utf-8' codec can't decode byte 0xa7 in position 0: invalid start byte
Error reading /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/bot/handlers/commands/__pycache__/scheduler_command.cpython-311.pyc: 'utf-8' codec can't decode byte 0xa7 in position 0: invalid start byte
Error reading /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/bot/handlers/commands/__pycache__/help.cpython-311.pyc: 'utf-8' codec can't decode byte 0xa7 in position 0: invalid start byte
Error reading /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/bot/handlers/commands/__pycache__/actual_send.cpython-311.pyc: 'utf-8' codec can't decode byte 0xa7 in position 0: invalid start byte
Error reading /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/bot/handlers/commands/__pycache__/interval.cpython-311.pyc: 'utf-8' codec can't decode byte 0xa7 in position 0: invalid start byte
Error reading /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/bot/handlers/commands/__pycache__/delete_tables.cpython-311.pyc: 'utf-8' codec can't decode byte 0xa7 in position 0: invalid start byte
Error reading /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/bot/handlers/commands/__pycache__/table_signals.cpython-311.pyc: 'utf-8' codec can't decode byte 0xa7 in position 0: invalid start byte
Error reading /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/bot/handlers/commands/__pycache__/show_signals.cpython-311.pyc: 'utf-8' codec can't decode byte 0xa7 in position 0: invalid start byte
Error reading /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/bot/handlers/commands/__pycache__/__init__.cpython-311.pyc: 'utf-8' codec can't decode byte 0xa7 in position 0: invalid start byte
Error reading /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/bot/handlers/commands/__pycache__/start.cpython-311.pyc: 'utf-8' codec can't decode byte 0xa7 in position 0: invalid start byte
Path: /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/database/models.py
File Name: models.py
Code:
from dataclasses import dataclass

@dataclass
class Signal:
    id: int
    name: str
    trend: str
    date_start: str
    date_last: str
    accuracy: float
    date_end: str
    price_start: float
    price_last: float
    price_end: float
    count_sends: int
    reported: int
--------------------------------------------------------------------------------
Path: /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/database/__init__.py
File Name: __init__.py
Code:

--------------------------------------------------------------------------------
Path: /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/database/db_handler.py
File Name: db_handler.py
Code:
from database.models import Signal
import sqlite3
from config import DB_NAME
from utils.logger import general_logger
from typing import Any

def init_db():
    conn = sqlite3.connect(DB_NAME)
    c = conn.cursor()

    c.execute('''CREATE TABLE IF NOT EXISTS signals
                 (id INTEGER PRIMARY KEY AUTOINCREMENT,
                  name TEXT,
                  trend TEXT,
                  date_start TEXT,
                  date_last TEXT,
                  accuracy INTEGER CHECK(accuracy >= 1 AND accuracy <= 100),
                  date_end TEXT,
                  price_start REAL,
                  price_last REAL,
                  price_end REAL,
                  count_sends INTEGER,
                  reported INTEGER DEFAULT 0)''')

    c.execute('''CREATE TABLE IF NOT EXISTS history
                 (id INTEGER PRIMARY KEY AUTOINCREMENT,
                  name TEXT,
                  trend TEXT,
                  date_start TEXT,
                  date_last TEXT,
                  accuracy INTEGER CHECK(accuracy >= 1 AND accuracy <= 100),
                  date_end TEXT,
                  price_start REAL,
                  price_last REAL,
                  price_end REAL,
                  count_sends INTEGER,
                  reported INTEGER)''')

    conn.commit()
    conn.close()

def delete_all_tables():
    conn = sqlite3.connect(DB_NAME)
    c = conn.cursor()

    c.execute("DROP TABLE IF EXISTS signals")
    c.execute("DROP TABLE IF EXISTS history")

    conn.commit()
    conn.close()

def insert_signal(name, trend, date_start, price_start, accuracy):
    conn = sqlite3.connect(DB_NAME)
    c = conn.cursor()

    c.execute('''SELECT * FROM signals 
                 WHERE name = ? AND date_end IS NULL''', (name,))
    existing_signal = c.fetchone()

    if not existing_signal:
        accuracy = max(1, min(100, int(accuracy)))
        c.execute('''INSERT INTO signals 
                     (name, trend, date_start, date_last, accuracy, price_start, price_last, count_sends)
                     VALUES (?, ?, ?, ?, ?, ?, ?, ?)''',
                  (name, trend, date_start, date_start, accuracy, price_start, price_start, 0))

    conn.commit()
    conn.close()

def update_signal(name, date_last, price_last, accuracy):
    conn = sqlite3.connect(DB_NAME)
    c = conn.cursor()
    accuracy = max(1, min(100, int(accuracy)))
    c.execute('''UPDATE signals
                 SET date_last = ?, price_last = ?, accuracy = ?
                 WHERE name = ? AND date_end IS NULL''',
              (date_last, price_last, accuracy, name))
    conn.commit()
    conn.close()

def increment_count_sends(signal_id: Any) -> bool:
    """
    Increment the count_sends for a signal.
    This function is used externally.
    """
    conn = sqlite3.connect(DB_NAME)
    c = conn.cursor()
    c.execute('''UPDATE signals
                 SET count_sends = count_sends + 1
                 WHERE id = ?''', (signal_id,))
    conn.commit()
    rows_affected = c.rowcount
    conn.close()
    general_logger.info(f"Ğ£Ğ²ĞµĞ»Ğ¸Ñ‡ĞµĞ½Ğ¾ count_sends Ğ´Ğ»Ñ ÑĞ¸Ğ³Ğ½Ğ°Ğ»Ğ° Ñ ID {signal_id}. Ğ—Ğ°Ñ‚Ñ€Ğ¾Ğ½ÑƒÑ‚Ğ¾ ÑÑ‚Ñ€Ğ¾Ğº: {rows_affected}")
    return rows_affected > 0

def get_active_signals():
    conn = sqlite3.connect(DB_NAME)
    c = conn.cursor()
    c.execute('''SELECT id, name, trend, date_start, date_last, accuracy, date_end, 
                 price_start, price_last, price_end, count_sends, reported 
                 FROM signals WHERE date_end IS NULL''')
    signals = c.fetchall()
    conn.close()
    return [Signal(*signal) for signal in signals]

def get_closed_signals():
    conn = sqlite3.connect(DB_NAME)
    c = conn.cursor()
    c.execute('''SELECT id, name, trend, date_start, date_last, accuracy, date_end, 
                 price_start, price_last, price_end, count_sends, reported 
                 FROM signals 
                 WHERE date_end IS NOT NULL 
                 AND reported = 0''')
    signals = c.fetchall()
    conn.close()
    return signals

def close_signal(name, date_end, price_end):
    conn = sqlite3.connect(DB_NAME)
    c = conn.cursor()
    c.execute('''UPDATE signals
                 SET date_end = ?, price_end = ?
                 WHERE name = ? AND date_end IS NULL''',
              (date_end, price_end, name))
    conn.commit()
    conn.close()

def mark_signal_as_reported(signal_id):
    conn = sqlite3.connect(DB_NAME)
    c = conn.cursor()
    c.execute('''UPDATE signals
                 SET reported = 1
                 WHERE id = ?''', (signal_id,))
    conn.commit()
    conn.close()

def move_old_signals_to_history():
    conn = sqlite3.connect(DB_NAME)
    c = conn.cursor()
    c.execute('''INSERT INTO history
                 SELECT * FROM signals
                 WHERE date_end IS NOT NULL 
                 AND reported = 1''')
    c.execute('''DELETE FROM signals
                 WHERE date_end IS NOT NULL 
                 AND reported = 1''')
    conn.commit()
    conn.close()

def get_signals_count():
    conn = sqlite3.connect(DB_NAME)
    c = conn.cursor()
    c.execute("SELECT COUNT(*) FROM signals WHERE date_end IS NULL")
    active_count = c.fetchone()[0]
    c.execute("SELECT COUNT(*) FROM signals WHERE date_end IS NOT NULL")
    closed_count = c.fetchone()[0]
    conn.close()
    return active_count, closed_count

def fetch_all_signals():
    conn = sqlite3.connect(DB_NAME)
    c = conn.cursor()
    c.execute("SELECT * FROM signals")
    signals = c.fetchall()
    conn.close()
    return signals

def get_active_signal(name):
    conn = sqlite3.connect(DB_NAME)
    c = conn.cursor()
    c.execute('''SELECT id, name, trend, date_start, date_last, accuracy, date_end, 
                 price_start, price_last, price_end, count_sends, reported 
                 FROM signals 
                 WHERE name = ? AND date_end IS NULL''', (name,))
    signal_data = c.fetchone()
    conn.close()
    return Signal(*signal_data) if signal_data else None

def store_signals_for_sending(new_signals, updated_signals, closed_signals):
    conn = sqlite3.connect(DB_NAME)
    c = conn.cursor()

    c.execute('''CREATE TABLE IF NOT EXISTS signals_to_send
                 (id INTEGER PRIMARY KEY AUTOINCREMENT,
                  signal_id INTEGER,
                  signal_type TEXT,
                  sent INTEGER DEFAULT 0)''')

    for signal in new_signals:
        c.execute("INSERT INTO signals_to_send (signal_id, signal_type) VALUES (?, ?)",
                  (signal.id, "new"))

    for signal in updated_signals:
        c.execute("INSERT INTO signals_to_send (signal_id, signal_type) VALUES (?, ?)",
                  (signal.id, "updated"))

    for signal in closed_signals:
        c.execute("INSERT INTO signals_to_send (signal_id, signal_type) VALUES (?, ?)",
                  (signal.id, "closed"))

    conn.commit()
    conn.close()

def get_signals_to_send():
    conn = sqlite3.connect(DB_NAME)
    c = conn.cursor()

    c.execute("SELECT signal_id, signal_type FROM signals_to_send WHERE sent = 0")
    signals_to_send = c.fetchall()

    conn.close()

    return signals_to_send

def mark_signal_as_sent(signal_id):
    conn = sqlite3.connect(DB_NAME)
    c = conn.cursor()
    c.execute('''UPDATE signals_to_send
                 SET sent = 1
                 WHERE signal_id = ?''', (signal_id,))
    conn.commit()
    conn.close()
    general_logger.info(f"Ğ¡Ğ¸Ğ³Ğ½Ğ°Ğ» Ñ ID {signal_id} Ğ¾Ñ‚Ğ¼ĞµÑ‡ĞµĞ½ ĞºĞ°Ğº Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ½Ñ‹Ğ¹")

def get_signal_by_id(signal_id):
    conn = sqlite3.connect(DB_NAME)
    c = conn.cursor()
    c.execute("SELECT * FROM signals WHERE id = ?", (signal_id,))
    signal_data = c.fetchone()
    conn.close()
    if signal_data:
        return Signal(*signal_data)
    return None

__all__ = ['increment_count_sends']
--------------------------------------------------------------------------------
Error reading /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/database/__pycache__/models.cpython-311.pyc: 'utf-8' codec can't decode byte 0xa7 in position 0: invalid start byte
Error reading /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/database/__pycache__/db_handler.cpython-311.pyc: 'utf-8' codec can't decode byte 0xa7 in position 0: invalid start byte
Error reading /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/database/__pycache__/__init__.cpython-311.pyc: 'utf-8' codec can't decode byte 0xa7 in position 0: invalid start byte
Path: /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/services/crypto_api.py
File Name: crypto_api.py
Code:
import ccxt.async_support as ccxt
from config import EXCHANGE_API_KEY, EXCHANGE_SECRET

exchange = ccxt.binance({
    'apiKey': EXCHANGE_API_KEY,
    'secret': EXCHANGE_SECRET,
})

async def get_ohlcv(symbol, timeframe='1h', limit=48):
    try:
        ohlcv = await exchange.fetch_ohlcv(symbol, timeframe, limit=limit)
        await exchange.close()  # Ğ’Ğ°Ğ¶Ğ½Ğ¾ Ğ·Ğ°ĞºÑ€Ñ‹Ñ‚ÑŒ ÑĞ¾ĞµĞ´Ğ¸Ğ½ĞµĞ½Ğ¸Ğµ Ğ¿Ğ¾ÑĞ»Ğµ Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ğ½Ğ¸Ñ
        return ohlcv
    except Exception as e:
        print(f"Error fetching OHLCV data: {e}")
        await exchange.close()  # Ğ—Ğ°ĞºÑ€Ñ‹Ğ²Ğ°ĞµĞ¼ ÑĞ¾ĞµĞ´Ğ¸Ğ½ĞµĞ½Ğ¸Ğµ Ğ´Ğ°Ğ¶Ğµ Ğ² ÑĞ»ÑƒÑ‡Ğ°Ğµ Ğ¾ÑˆĞ¸Ğ±ĞºĞ¸
        return None

async def get_current_price(symbol):
    try:
        ticker = await exchange.fetch_ticker(symbol)
        await exchange.close()  # Ğ’Ğ°Ğ¶Ğ½Ğ¾ Ğ·Ğ°ĞºÑ€Ñ‹Ñ‚ÑŒ ÑĞ¾ĞµĞ´Ğ¸Ğ½ĞµĞ½Ğ¸Ğµ Ğ¿Ğ¾ÑĞ»Ğµ Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ğ½Ğ¸Ñ
        return ticker['last']
    except Exception as e:
        print(f"Error fetching current price: {e}")
        await exchange.close()  # Ğ—Ğ°ĞºÑ€Ñ‹Ğ²Ğ°ĞµĞ¼ ÑĞ¾ĞµĞ´Ğ¸Ğ½ĞµĞ½Ğ¸Ğµ Ğ´Ğ°Ğ¶Ğµ Ğ² ÑĞ»ÑƒÑ‡Ğ°Ğµ Ğ¾ÑˆĞ¸Ğ±ĞºĞ¸
        return None
--------------------------------------------------------------------------------
Path: /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/services/signal_manager.py
File Name: signal_manager.py
Code:
from database.db_handler import insert_signal, update_signal, close_signal, get_active_signals, \
    get_active_signal
from services.crypto_api import get_ohlcv, get_current_price
from services.trend_analyzer import analyze_trend, is_trend_still_valid
from utils.time_utils import get_current_time
from database.models import Signal
from sqlalchemy.orm import sessionmaker
from sqlalchemy import create_engine
import logging

# Assuming SQLAlchemy is used, initialize the sessionmaker
engine = create_engine('sqlite:///path_to_your_db.sqlite')  # Replace with your actual database URL
Session = sessionmaker(bind=engine)
session = Session()

async def check_and_create_signals(crypto_pairs):
    logging.info("ĞŸÑ€Ğ¾Ğ²ĞµÑ€ĞºĞ° Ğ¸ ÑĞ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ğµ Ğ½Ğ¾Ğ²Ñ‹Ñ… ÑĞ¸Ğ³Ğ½Ğ°Ğ»Ğ¾Ğ².")
    new_signals = []
    updated_signals = []
    closed_signals = []

    for pair in crypto_pairs:
        logging.info(f"ĞŸÑ€Ğ¾Ğ²ĞµÑ€ĞºĞ° Ğ¿Ğ°Ñ€Ñ‹: {pair}")
        ohlcv = await get_ohlcv(pair)
        if ohlcv:
            trend, accuracy = analyze_trend(ohlcv)
            existing_signal = get_active_signal(pair)
            current_price = await get_current_price(pair)
            current_time = get_current_time()

            if existing_signal:
                if existing_signal.trend == trend:
                    update_signal(pair, current_time, current_price, accuracy)
                    updated_signals.append(existing_signal)
                    logging.info(
                        f"ĞĞ±Ğ½Ğ¾Ğ²Ğ»ĞµĞ½ ÑÑƒÑ‰ĞµÑÑ‚Ğ²ÑƒÑÑ‰Ğ¸Ğ¹ ÑĞ¸Ğ³Ğ½Ğ°Ğ» Ğ´Ğ»Ñ Ğ¿Ğ°Ñ€Ñ‹ {pair}: {trend} Ñ Ñ‚Ğ¾Ñ‡Ğ½Ğ¾ÑÑ‚ÑŒÑ {accuracy}.")
                else:
                    close_signal(pair, current_time, current_price)
                    closed_signals.append(existing_signal)
                    insert_signal(pair, trend, current_time, current_price, accuracy)
                    new_signal = get_active_signal(pair)
                    new_signals.append(new_signal)
                    logging.info(
                        f"Ğ—Ğ°ĞºÑ€Ñ‹Ñ‚ ÑÑ‚Ğ°Ñ€Ñ‹Ğ¹ ÑĞ¸Ğ³Ğ½Ğ°Ğ» Ğ¸ ÑĞ¾Ğ·Ğ´Ğ°Ğ½ Ğ½Ğ¾Ğ²Ñ‹Ğ¹ Ğ´Ğ»Ñ Ğ¿Ğ°Ñ€Ñ‹ {pair}: {trend} Ñ Ñ‚Ğ¾Ñ‡Ğ½Ğ¾ÑÑ‚ÑŒÑ {accuracy}.")
            else:
                insert_signal(pair, trend, current_time, current_price, accuracy)
                new_signal = get_active_signal(pair)
                new_signals.append(new_signal)
                logging.info(
                    f"Ğ¡Ğ¾Ğ·Ğ´Ğ°Ğ½ Ğ½Ğ¾Ğ²Ñ‹Ğ¹ ÑĞ¸Ğ³Ğ½Ğ°Ğ» Ğ´Ğ»Ñ Ğ¿Ğ°Ñ€Ñ‹ {pair}: {trend} Ñ Ñ‚Ğ¾Ñ‡Ğ½Ğ¾ÑÑ‚ÑŒÑ {accuracy}.")
        else:
            logging.warning(f"ĞĞµ ÑƒĞ´Ğ°Ğ»Ğ¾ÑÑŒ Ğ¿Ğ¾Ğ»ÑƒÑ‡Ğ¸Ñ‚ÑŒ Ğ´Ğ°Ğ½Ğ½Ñ‹Ğµ OHLCV Ğ´Ğ»Ñ Ğ¿Ğ°Ñ€Ñ‹ {pair}. ĞŸÑ€Ğ¾Ğ¿ÑƒÑĞº.")

    return new_signals, updated_signals, closed_signals


def update_active_signals():
    logging.info("ĞĞ±Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ¸Ğµ Ğ°ĞºÑ‚Ğ¸Ğ²Ğ½Ñ‹Ñ… ÑĞ¸Ğ³Ğ½Ğ°Ğ»Ğ¾Ğ².")
    active_signals = get_active_signals()
    for signal in active_signals:
        pair = signal.name
        logging.info(f"ĞĞºÑ‚ÑƒĞ°Ğ»Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ ÑĞ¸Ğ³Ğ½Ğ°Ğ»Ğ° Ğ´Ğ»Ñ Ğ¿Ğ°Ñ€Ñ‹: {pair}")
        ohlcv = get_ohlcv(pair)
        if ohlcv:
            if is_trend_still_valid(ohlcv, signal.trend):
                logging.info(f"Ğ¡Ğ¸Ğ³Ğ½Ğ°Ğ» Ğ´Ğ»Ñ Ğ¿Ğ°Ñ€Ñ‹ {pair} Ğ²ÑÑ‘ ĞµÑ‰Ñ‘ Ğ°ĞºÑ‚ÑƒĞ°Ğ»ĞµĞ½.")
                current_price = get_current_price(pair)
                current_time = get_current_time()
                _, accuracy = analyze_trend(ohlcv)
                update_signal(pair, current_time, current_price, accuracy)
            else:
                logging.info(f"Ğ¡Ğ¸Ğ³Ğ½Ğ°Ğ» Ğ´Ğ»Ñ Ğ¿Ğ°Ñ€Ñ‹ {pair} Ğ±Ğ¾Ğ»ÑŒÑˆĞµ Ğ½Ğµ Ğ°ĞºÑ‚ÑƒĞ°Ğ»ĞµĞ½.")
                current_price = get_current_price(pair)
                current_time = get_current_time()
                close_signal(pair, current_time, current_price)
        else:
            logging.warning(f"ĞĞµ ÑƒĞ´Ğ°Ğ»Ğ¾ÑÑŒ Ğ¿Ğ¾Ğ»ÑƒÑ‡Ğ¸Ñ‚ÑŒ Ğ´Ğ°Ğ½Ğ½Ñ‹Ğµ OHLCV Ğ´Ğ»Ñ Ğ¿Ğ°Ñ€Ñ‹ {pair}. ĞŸÑ€Ğ¾Ğ¿ÑƒÑĞº.")


async def update_signal_in_db(signal):
    try:
        existing_signal = session.query(Signal).get(signal.id)
        if existing_signal:
            existing_signal.trend = signal.trend
            existing_signal.accuracy = signal.accuracy
            existing_signal.close_value = signal.close_value
            session.commit()
        else:
            logging.error(f"Ğ¡Ğ¸Ğ³Ğ½Ğ°Ğ» Ñ ID {signal.id} Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½ Ğ² Ğ±Ğ°Ğ·Ğµ Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ….")
    except Exception as e:
        logging.error(f"ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¿Ñ€Ğ¸ Ğ¾Ğ±Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ¸Ğ¸ ÑĞ¸Ğ³Ğ½Ğ°Ğ»Ğ° Ğ² Ğ±Ğ°Ğ·Ğµ Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ…: {e}")
--------------------------------------------------------------------------------
Path: /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/services/trend_analyzer.py
File Name: trend_analyzer.py
Code:
import numpy as np

def analyze_trend(ohlcv_data):
    if not ohlcv_data:
        return None, 0

    closes = np.array([x[4] for x in ohlcv_data])
    ma_short = np.mean(closes[-12:])  # 12-hour moving average
    ma_long = np.mean(closes)  # 48-hour moving average

    if ma_short > ma_long:
        trend = "long"
    elif ma_short < ma_long:
        trend = "short"
    else:
        trend = None

    # Ğ Ğ°ÑÑ‡ĞµÑ‚ accuracy
    diff = abs(ma_short - ma_long)
    max_diff = max(closes) - min(closes)
    accuracy = int((1 - diff / max_diff) * 100) if max_diff != 0 else 50
    accuracy = max(1, min(100, accuracy))  # Ğ£Ğ±ĞµĞ´Ğ¸Ğ¼ÑÑ, Ñ‡Ñ‚Ğ¾ accuracy Ğ² Ğ¿Ñ€ĞµĞ´ĞµĞ»Ğ°Ñ… Ğ¾Ñ‚ 1 Ğ´Ğ¾ 100

    return trend, accuracy

def is_trend_still_valid(ohlcv_data, current_trend):
    new_trend, _ = analyze_trend(ohlcv_data)
    return new_trend == current_trend
--------------------------------------------------------------------------------
Path: /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/services/tinyml_analyzer.py
File Name: tinyml_analyzer.py
Code:
import tensorflow as tf

# Ğ—Ğ°Ğ³Ñ€ÑƒĞ·ĞºĞ° Ğ¼Ğ¾Ğ´ĞµĞ»Ğ¸ TinyML
model = tf.lite.Interpreter(model_path="path/to/your/tinyml_model.tflite")
model.allocate_tensors()

def analyze_with_tinyml(data):
    input_details = model.get_input_details()
    output_details = model.get_output_details()

    model.set_tensor(input_details[0]['index'], data)
    model.invoke()
    output = model.get_tensor(output_details[0]['index'])

    return output

# Ğ¤ÑƒĞ½ĞºÑ†Ğ¸Ğ¸ Ğ´Ğ»Ñ Ğ¸Ğ½Ñ‚ĞµĞ³Ñ€Ğ°Ñ†Ğ¸Ğ¸ TinyML Ğ² ÑÑƒÑ‰ĞµÑÑ‚Ğ²ÑƒÑÑ‰ÑƒÑ Ğ»Ğ¾Ğ³Ğ¸ĞºÑƒ Ğ°Ğ½Ğ°Ğ»Ğ¸Ğ·Ğ°
def should_open_signal(ohlcv_data):
    # ĞŸĞ¾Ğ´Ğ³Ğ¾Ñ‚Ğ¾Ğ²ĞºĞ° Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ… Ğ´Ğ»Ñ TinyML
    prepared_data = prepare_data_for_tinyml(ohlcv_data)
    result = analyze_with_tinyml(prepared_data)
    # Ğ˜Ğ½Ñ‚ĞµÑ€Ğ¿Ñ€ĞµÑ‚Ğ°Ñ†Ğ¸Ñ Ñ€ĞµĞ·ÑƒĞ»ÑŒÑ‚Ğ°Ñ‚Ğ°
    return interpret_open_signal_result(result)

def should_close_signal(ohlcv_data, current_trend):
    # ĞŸĞ¾Ğ´Ğ³Ğ¾Ñ‚Ğ¾Ğ²ĞºĞ° Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ… Ğ´Ğ»Ñ TinyML
    prepared_data = prepare_data_for_tinyml(ohlcv_data, current_trend)
    result = analyze_with_tinyml(prepared_data)
    # Ğ˜Ğ½Ñ‚ĞµÑ€Ğ¿Ñ€ĞµÑ‚Ğ°Ñ†Ğ¸Ñ Ñ€ĞµĞ·ÑƒĞ»ÑŒÑ‚Ğ°Ñ‚Ğ°
    return interpret_close_signal_result(result)

# Ğ’ÑĞ¿Ğ¾Ğ¼Ğ¾Ğ³Ğ°Ñ‚ĞµĞ»ÑŒĞ½Ñ‹Ğµ Ñ„ÑƒĞ½ĞºÑ†Ğ¸Ğ¸
def prepare_data_for_tinyml(ohlcv_data, current_trend=None):
    # Ğ›Ğ¾Ğ³Ğ¸ĞºĞ° Ğ¿Ğ¾Ğ´Ğ³Ğ¾Ñ‚Ğ¾Ğ²ĞºĞ¸ Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ… Ğ´Ğ»Ñ Ğ¼Ğ¾Ğ´ĞµĞ»Ğ¸ TinyML
    pass

def interpret_open_signal_result(result):
    # Ğ›Ğ¾Ğ³Ğ¸ĞºĞ° Ğ¸Ğ½Ñ‚ĞµÑ€Ğ¿Ñ€ĞµÑ‚Ğ°Ñ†Ğ¸Ğ¸ Ñ€ĞµĞ·ÑƒĞ»ÑŒÑ‚Ğ°Ñ‚Ğ° Ğ´Ğ»Ñ Ğ¾Ñ‚ĞºÑ€Ñ‹Ñ‚Ğ¸Ñ ÑĞ¸Ğ³Ğ½Ğ°Ğ»Ğ°
    pass

def interpret_close_signal_result(result):
    # Ğ›Ğ¾Ğ³Ğ¸ĞºĞ° Ğ¸Ğ½Ñ‚ĞµÑ€Ğ¿Ñ€ĞµÑ‚Ğ°Ñ†Ğ¸Ğ¸ Ñ€ĞµĞ·ÑƒĞ»ÑŒÑ‚Ğ°Ñ‚Ğ° Ğ´Ğ»Ñ Ğ·Ğ°ĞºÑ€Ñ‹Ñ‚Ğ¸Ñ ÑĞ¸Ğ³Ğ½Ğ°Ğ»Ğ°
    pass
--------------------------------------------------------------------------------
Error reading /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/services/__pycache__/crypto_api.cpython-311.pyc: 'utf-8' codec can't decode byte 0xa7 in position 0: invalid start byte
Error reading /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/services/__pycache__/trend_analyzer.cpython-311.pyc: 'utf-8' codec can't decode byte 0xa7 in position 0: invalid start byte
Error reading /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/services/__pycache__/signal_manager.cpython-311.pyc: 'utf-8' codec can't decode byte 0xa7 in position 0: invalid start byte
Path: /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/utils/time_utils.py
File Name: time_utils.py
Code:
from datetime import datetime
from pytz import timezone
from config import TIMEZONE

def get_current_time():
    return datetime.now(timezone(TIMEZONE)).isoformat()

def format_date(date_string):
    date = datetime.fromisoformat(date_string)
    if date.tzinfo is None:
        date = date.replace(tzinfo=timezone(TIMEZONE))
    return date.astimezone(timezone(TIMEZONE)).strftime("%Y-%m-%d %H:%M")

def calculate_time_difference(start_time, end_time):
    start = datetime.fromisoformat(start_time)
    end = datetime.fromisoformat(end_time)
    if start.tzinfo is None:
        start = start.replace(tzinfo=timezone(TIMEZONE))
    if end.tzinfo is None:
        end = end.replace(tzinfo=timezone(TIMEZONE))
    diff = end - start
    days = diff.days
    hours = diff.seconds // 3600
    return f"{days} Ğ´Ğ½ĞµĞ¹ Ğ¸ {hours} Ñ‡Ğ°ÑĞ¾Ğ²"
--------------------------------------------------------------------------------
Path: /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/utils/logger.py
File Name: logger.py
Code:
import logging
from logging.handlers import TimedRotatingFileHandler
import os
from pathlib import Path

def setup_logging():
    log_dir = Path(__file__).parents[1] / 'logs'
    log_dir.mkdir(exist_ok=True)

    general_log_handler = TimedRotatingFileHandler(
        log_dir / 'general.log',
        when="D",
        interval=1,
        backupCount=1
    )
    general_log_handler.setFormatter(logging.Formatter('%(asctime)s - %(levelname)s - %(message)s'))

    analyze_log_handler = TimedRotatingFileHandler(
        log_dir / 'analyze.log',
        when="D",
        interval=7,
        backupCount=1
    )
    analyze_log_handler.setFormatter(logging.Formatter('%(asctime)s - %(levelname)s - %(message)s'))

    if logging.getLogger('general').hasHandlers():
        logging.getLogger('general').handlers.clear()

    if logging.getLogger('analyze').hasHandlers():
        logging.getLogger('analyze').handlers.clear()

    general_logger = logging.getLogger('general')
    general_logger.setLevel(logging.INFO)
    general_logger.addHandler(general_log_handler)

    analyze_logger = logging.getLogger('analyze')
    analyze_logger.setLevel(logging.INFO)
    analyze_logger.addHandler(analyze_log_handler)

    return general_logger, analyze_logger

general_logger, analyze_logger = setup_logging()

__all__ = ['setup_logging', 'general_logger', 'analyze_logger']
--------------------------------------------------------------------------------
Path: /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/utils/message_formatter.py
File Name: message_formatter.py
Code:
from datetime import datetime
from utils.time_utils import format_date, calculate_time_difference
from datetime import datetime
from config import TIMEZONE
from pytz import timezone
from utils.logger import general_logger


def add_timestamp_and_separator(message):
    current_time = datetime.now(timezone(TIMEZONE)).strftime("%Y-%m-%d %H:%M")
    separator = "-" * 40
    return f"{current_time}\n{separator}\n{message}"


def format_new_signal_message(signal, is_new=False):
    status = "ĞĞ¾Ğ²Ñ‹Ğ¹ ÑĞ¸Ğ³Ğ½Ğ°Ğ»" if signal.count_sends == 0 else "ĞĞºÑ‚ÑƒĞ°Ğ»ÑŒĞ½Ğ¾"
    trend_emoji = "ğŸŸ¢" if signal.trend.lower() == "long" else "ğŸ”´"

    general_logger.info(
        f"Ğ¤Ğ¾Ñ€Ğ¼Ğ°Ñ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ ÑĞ¸Ğ³Ğ½Ğ°Ğ»Ğ°: {signal.name}, Count Sends: {signal.count_sends}, Ğ¡Ñ‚Ğ°Ñ‚ÑƒÑ: {status}")

    return f"âœ…{status}: {signal.name} {trend_emoji} {signal.trend.upper()} Ğ¢Ğ¾Ñ‡Ğ½Ğ¾ÑÑ‚ÑŒ: {signal.accuracy}\n" \
           f"ĞĞ°Ñ‡Ğ°Ğ»Ğ¾: {format_date(signal.date_start)} Ğ¦ĞµĞ½Ğ°: {signal.price_start}\n" \
           f"ĞĞºÑ‚ÑƒĞ°Ğ»ÑŒĞ½Ğ¾ Ğ½Ğ°: {format_date(signal.date_last)} Ğ¦ĞµĞ½Ğ°: {signal.price_last}"


def format_closed_signal_message(signal):
    trend_emoji = "ğŸŸ¢" if signal.trend.lower() == "long" else "ğŸ”´"
    price_change = ((signal.price_end - signal.price_start) / signal.price_start) * 100
    price_change_sign = "+" if (signal.trend.lower() == "long" and price_change > 0) or (
                signal.trend.lower() == "short" and price_change < 0) else "-"
    price_change_str = f"{price_change_sign}{abs(price_change):.2f}%"

    return f"âŒĞ¡Ğ¸Ğ³Ğ½Ğ°Ğ» Ğ·Ğ°ĞºÑ€Ñ‹Ñ‚: {signal.name} {trend_emoji} {signal.trend.upper()}\n" \
           f"ĞĞ°Ñ‡Ğ°Ğ»Ğ¾: {format_date(signal.date_start)} Ğ¦ĞµĞ½Ğ°: {signal.price_start}\n" \
           f"ĞšĞ¾Ğ½ĞµÑ†: {format_date(signal.date_end)} Ğ¦ĞµĞ½Ğ°: {signal.price_end}\n" \
           f"Ğ˜Ğ·Ğ¼ĞµĞ½ĞµĞ½Ğ¸Ğµ Ñ†ĞµĞ½Ñ‹: {price_change_str}\n" \
           f"ĞĞ±Ñ‰Ğ°Ñ Ğ´Ğ»Ğ¸Ñ‚ĞµĞ»ÑŒĞ½Ğ¾ÑÑ‚ÑŒ: {calculate_time_difference(signal.date_start, signal.date_end)}"


def format_signals_table(signals):
    formatted_signals = []

    for signal in signals:
        formatted_signal = (
            f"ID: {signal[0]}\n"
            f"Name: {signal[1]}\n"
            f"Trend: {signal[2]}\n"
            f"Start Date: {signal[3]}\n"
            f"Last Date: {signal[4]}\n"
            f"Accuracy: {signal[5]}\n"
            f"End Date: {signal[6]}\n"
            f"Start Price: {signal[7]}\n"
            f"Last Price: {signal[8]}\n"
            f"End Price: {signal[9]}\n"
            f"Count Sends: {signal[10]}\n"
            f"Reported: {signal[11]}\n"
            "----------------------"
        )
        formatted_signals.append(formatted_signal)

    return "\n".join(formatted_signals)
--------------------------------------------------------------------------------
Path: /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/utils/chart_generator.py
File Name: chart_generator.py
Code:
import mplfinance as mpf
import pandas as pd
import numpy as np
from datetime import datetime
import matplotlib.pyplot as plt
import io


def find_nearest_index(df, target_time):
    nearest_idx = df.index.get_indexer([target_time], method='nearest')[0]
    return df.index[nearest_idx]


def generate_chart(ohlcv_data, trend, signal_start_date=None, signal_end_date=None):
    df = pd.DataFrame(ohlcv_data, columns=['timestamp', 'open', 'high', 'low', 'close', 'volume'])
    df['timestamp'] = pd.to_datetime(df['timestamp'], unit='ms')
    df.set_index('timestamp', inplace=True)

    # Ğ Ğ°ÑÑÑ‡Ğ¸Ñ‚Ñ‹Ğ²Ğ°ĞµĞ¼ Ğ»Ğ¸Ğ½Ğ¸Ñ Ñ‚Ñ€ĞµĞ½Ğ´Ğ°
    x = np.arange(len(df))
    y = df['close'].values

    # Ğ’Ñ‹Ğ²Ğ¾Ğ´ Ğ´Ğ»Ğ¸Ğ½Ñ‹ Ğ¼Ğ°ÑÑĞ¸Ğ²Ğ¾Ğ² x Ğ¸ y Ğ´Ğ»Ñ Ğ´Ğ¸Ğ°Ğ³Ğ½Ğ¾ÑÑ‚Ğ¸ĞºĞ¸
    print(f"Length of x: {len(x)}, Length of y: {len(y)}")

    z = np.polyfit(x, y, 1)
    p = np.poly1d(z)
    trend_line = p(x)

    # ĞĞ°ÑÑ‚Ñ€Ğ¾Ğ¹ĞºĞ° ÑÑ‚Ğ¸Ğ»Ñ Ğ³Ñ€Ğ°Ñ„Ğ¸ĞºĞ°
    mc = mpf.make_marketcolors(up='g', down='r', inherit=True)
    s = mpf.make_mpf_style(marketcolors=mc)

    # ĞŸĞ¾Ğ´Ğ³Ğ¾Ñ‚Ğ¾Ğ²ĞºĞ° Ğ´Ğ¾Ğ¿Ğ¾Ğ»Ğ½Ğ¸Ñ‚ĞµĞ»ÑŒĞ½Ñ‹Ñ… Ğ³Ñ€Ğ°Ñ„Ğ¸ĞºĞ¾Ğ²
    apds = [mpf.make_addplot(trend_line, color='blue', width=1)]

    if signal_start_date:
        signal_start = datetime.fromisoformat(signal_start_date)
        if signal_start.tzinfo is not None:
            signal_start = signal_start.replace(tzinfo=None)

        # Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞµĞ¼ Ğ±Ğ»Ğ¸Ğ¶Ğ°Ğ¹ÑˆÑƒÑ Ğ²Ñ€ĞµĞ¼ĞµĞ½Ğ½ÑƒÑ Ğ¼ĞµÑ‚ĞºÑƒ
        signal_start_index = find_nearest_index(df, signal_start)
        print(
            f"Signal start at {signal_start_index}, close value: {df['close'].loc[signal_start_index]}")

        # Ğ¡Ğ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ğµ Ğ²Ñ€ĞµĞ¼ĞµĞ½Ğ½Ğ¾Ğ³Ğ¾ Ñ€ÑĞ´Ğ° Ñ NaN, ĞºÑ€Ğ¾Ğ¼Ğµ Ğ¾Ğ´Ğ½Ğ¾Ğ³Ğ¾ Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ñ
        signal_start_series = pd.Series([np.nan] * len(df), index=df.index)
        signal_start_series.loc[signal_start_index] = df['close'].loc[signal_start_index]

        apds.append(mpf.make_addplot(signal_start_series, type='scatter',
                                     markersize=100, marker='^',
                                     color='g' if trend.lower() == 'long' else 'r'))

    if signal_end_date:
        signal_end = datetime.fromisoformat(signal_end_date)
        if signal_end.tzinfo is not None:
            signal_end = signal_end.replace(tzinfo=None)

        # Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞµĞ¼ Ğ±Ğ»Ğ¸Ğ¶Ğ°Ğ¹ÑˆÑƒÑ Ğ²Ñ€ĞµĞ¼ĞµĞ½Ğ½ÑƒÑ Ğ¼ĞµÑ‚ĞºÑƒ
        signal_end_index = find_nearest_index(df, signal_end)
        print(f"Signal end at {signal_end_index}, close value: {df['close'].loc[signal_end_index]}")

        # Ğ¡Ğ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ğµ Ğ²Ñ€ĞµĞ¼ĞµĞ½Ğ½Ğ¾Ğ³Ğ¾ Ñ€ÑĞ´Ğ° Ñ NaN, ĞºÑ€Ğ¾Ğ¼Ğµ Ğ¾Ğ´Ğ½Ğ¾Ğ³Ğ¾ Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ñ
        signal_end_series = pd.Series([np.nan] * len(df), index=df.index)
        signal_end_series.loc[signal_end_index] = df['close'].loc[signal_end_index]

        apds.append(mpf.make_addplot(signal_end_series, type='scatter',
                                     markersize=100, marker='v', color='r'))

    # Ğ¡Ğ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ğµ Ğ³Ñ€Ğ°Ñ„Ğ¸ĞºĞ°
    try:
        fig, axes = mpf.plot(df, type='candle', style=s, addplot=apds,
                             title=f'Ğ¢Ñ€ĞµĞ½Ğ´: {trend.capitalize()}',
                             ylabel='Ğ¦ĞµĞ½Ğ°',
                             datetime_format='%Y-%m-%d %H:%M',
                             figsize=(12, 8),
                             returnfig=True)

        # ĞĞ°ÑÑ‚Ñ€Ğ¾Ğ¹ĞºĞ° Ğ»ĞµĞ³ĞµĞ½Ğ´Ñ‹
        axes[0].legend(['Ğ›Ğ¸Ğ½Ğ¸Ñ Ñ‚Ñ€ĞµĞ½Ğ´Ğ°', 'ĞĞ°Ñ‡Ğ°Ğ»Ğ¾ ÑĞ¸Ğ³Ğ½Ğ°Ğ»Ğ°', 'ĞšĞ¾Ğ½ĞµÑ† ÑĞ¸Ğ³Ğ½Ğ°Ğ»Ğ°'])

        # Ğ¡Ğ¾Ñ…Ñ€Ğ°Ğ½ĞµĞ½Ğ¸Ğµ Ğ³Ñ€Ğ°Ñ„Ğ¸ĞºĞ° Ğ² Ğ±Ğ°Ğ¹Ñ‚Ğ¾Ğ²Ñ‹Ğ¹ Ğ¿Ğ¾Ñ‚Ğ¾Ğº
        buf = io.BytesIO()
        plt.savefig(buf, format='png', dpi=100, bbox_inches='tight')
        buf.seek(0)
        plt.close(fig)

        return buf
    except Exception as e:
        print(f"ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¿Ñ€Ğ¸ ÑĞ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ğ¸ Ğ³Ñ€Ğ°Ñ„Ğ¸ĞºĞ°: {e}")
        raise
--------------------------------------------------------------------------------
Error reading /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/utils/__pycache__/message_formatter.cpython-311.pyc: 'utf-8' codec can't decode byte 0xa7 in position 0: invalid start byte
Error reading /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/utils/__pycache__/logger.cpython-311.pyc: 'utf-8' codec can't decode byte 0xa7 in position 0: invalid start byte
Error reading /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/utils/__pycache__/time_utils.cpython-311.pyc: 'utf-8' codec can't decode byte 0xa7 in position 0: invalid start byte
Error reading /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/utils/__pycache__/chart_generator.cpython-311.pyc: 'utf-8' codec can't decode byte 0xa7 in position 0: invalid start byte