Project Tree Structure:
‚îú‚îÄ‚îÄ crypto_trend_bot/
‚îÇ   ‚îú‚îÄ‚îÄ .DS_Store
‚îÇ   ‚îú‚îÄ‚îÄ config.py
‚îÇ   ‚îú‚îÄ‚îÄ requirements.txt
‚îÇ   ‚îú‚îÄ‚îÄ Dockerfile
‚îÇ   ‚îú‚îÄ‚îÄ check_errors.py
‚îÇ   ‚îú‚îÄ‚îÄ main.py
‚îÇ   ‚îú‚îÄ‚îÄ bot/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __pycache__/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __init__.cpython-311.pyc
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ scheduler.cpython-311.pyc
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ handlers/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __pycache__/
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __init__.cpython-311.pyc
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ periodic_tasks.cpython-311.pyc
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ signals.cpython-311.pyc
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ utils.cpython-311.pyc
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ commands/
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __pycache__/
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __init__.cpython-311.pyc
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ actual_send.cpython-311.pyc
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ check.cpython-311.pyc
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ count_signals.cpython-311.pyc
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ delete_logs.cpython-311.pyc
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ delete_tables.cpython-311.pyc
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ help.cpython-311.pyc
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ interval.cpython-311.pyc
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ logs.cpython-311.pyc
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ menu_handlers.cpython-311.pyc
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ scheduler_command.cpython-311.pyc
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ show_signals.cpython-311.pyc
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ start.cpython-311.pyc
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ stop.cpython-311.pyc
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ table_signals.cpython-311.pyc
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ actual_send.py
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ check.py
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ count_signals.py
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ delete_logs.py
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ delete_tables.py
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ help.py
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ interval.py
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ logs.py
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ menu_handlers.py
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ scheduler_command.py
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ show_signals.py
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ start.py
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ stop.py
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ table_signals.py
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ periodic_tasks.py
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ signals.py
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ utils.py
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ scheduler.py
‚îÇ   ‚îú‚îÄ‚îÄ database/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __pycache__/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __init__.cpython-311.pyc
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ db_handler.cpython-311.pyc
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ models.cpython-311.pyc
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ db_handler.py
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ models.py
‚îÇ   ‚îú‚îÄ‚îÄ services/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __pycache__/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ crypto_api.cpython-311.pyc
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ signal_manager.cpython-311.pyc
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ trend_analyzer.cpython-311.pyc
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ crypto_api.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ model_analyzer.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ signal_manager.py
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ trend_analyzer.py
‚îÇ   ‚îú‚îÄ‚îÄ utils/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __pycache__/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ chart_generator.cpython-311.pyc
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ logger.cpython-311.pyc
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ message_formatter.cpython-311.pyc
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ time_utils.cpython-311.pyc
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ chart_generator.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ logger.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ message_formatter.py
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ time_utils.py

================================================================================

Error reading /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/.DS_Store: 'utf-8' codec can't decode byte 0xf4 in position 661: invalid continuation byte
Path: /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/config.py
File Name: config.py
Code:
# –¢–æ–∫–µ–Ω –≤–∞—à–µ–≥–æ –±–æ—Ç–∞
BOT_TOKEN = "7317150884:AAENXygTDLy3KGvLIh5CgxfqRRS69Rd2I1U"

# ID –∫–∞–Ω–∞–ª–∞ Telegram, –∫—É–¥–∞ –±–æ—Ç –±—É–¥–µ—Ç –æ—Ç–ø—Ä–∞–≤–ª—è—Ç—å —Å–æ–æ–±—â–µ–Ω–∏—è
CHANNEL_ID = "7317150884"

# –°–ø–∏—Å–æ–∫ –ø—Ä–æ–≤–µ—Ä—è–µ–º—ã—Ö –ø–∞—Ä
CRYPTO_PAIRS = ["BTC/USDT", "ETH/USDT", "ADA/USDT", "TON/USDT"]

# –ù–∞—Å—Ç—Ä–æ–π–∫–∏ API –±–∏—Ä–∂–∏
EXCHANGE_API_KEY = "MWpeIx2bRxJW9igMlA4LDb6i7JovQLM9CYYS5AfbD803JyQhWbPAgi2m9LsBE58k"
EXCHANGE_SECRET = "nxQoPTFVJeR1U6etHoKXtIFbvV5s3nSDOY5579PKVTeHZQcHJw5VZDtJ60JslMBh"

# –ù–∞—Å—Ç—Ä–æ–π–∫–∏ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö
DB_NAME = "price_trend_db.sqlite"

# –ù–∞—Å—Ç—Ä–æ–π–∫–∏ –ø–ª–∞–Ω–∏—Ä–æ–≤—â–∏–∫–∞
CHECK_INTERVAL = 1 * 60  # 1 –º–∏–Ω—É—Ç–∞ –≤ —Å–µ–∫—É–Ω–¥–∞—Ö

# –ß–∞—Å–æ–≤–æ–π –ø–æ—è—Å
TIMEZONE = "Europe/Samara"

_SEND_ACTUAL_SIGNALS = True

def toggle_actual_signals():
    global _SEND_ACTUAL_SIGNALS
    _SEND_ACTUAL_SIGNALS = not _SEND_ACTUAL_SIGNALS
    return _SEND_ACTUAL_SIGNALS

def get_actual_signals_status():
    return _SEND_ACTUAL_SIGNALS
--------------------------------------------------------------------------------
Path: /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/requirements.txt
File Name: requirements.txt
Code:
pyTelegramBotAPI==4.14.0
ccxt==4.0.80
numpy==1.24.3
APScheduler==3.10.4
matplotlib==3.7.2
pytz==2023.3
tabulate==0.9.0
tensorflow
tensorflow-hub
pandas==1.5.3
mplfinance==0.12.9b7
sqlalchemy
flake8
scipy
telebot
torch
transformers
--------------------------------------------------------------------------------
Path: /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/Dockerfile
File Name: Dockerfile
Code:
FROM python:3.11-slim

WORKDIR /app

COPY requirements.txt .

RUN pip install --no-cache-dir -r requirements.txt

COPY . .

ENV PYTHONDONTWRITEBYTECODE=1
ENV PYTHONUNBUFFERED=1

CMD ["python", "main.py"]
--------------------------------------------------------------------------------
Path: /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/check_errors.py
File Name: check_errors.py
Code:
import subprocess
import os

def run_flake8_and_save_output():
    # –û–ø—Ä–µ–¥–µ–ª—è–µ–º –ø—É—Ç—å –∫ —Ñ–∞–π–ª—É –¥–ª—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤
    log_dir = os.path.join(os.path.dirname(__file__), 'logs')
    os.makedirs(log_dir, exist_ok=True)
    output_file = os.path.join(log_dir, 'check_errors.txt')

    try:
        # –ó–∞–ø—É—Å–∫–∞–µ–º flake8 —Å –∏—Å–∫–ª—é—á–µ–Ω–∏–µ–º –∫–∞—Ç–∞–ª–æ–≥–∞ .venv –∏ —Ñ–∏–ª—å—Ç—Ä–æ–º –ø–æ –∫—Ä–∏—Ç–∏—á–Ω—ã–º –æ—à–∏–±–∫–∞–º
        result = subprocess.run(
            ['flake8', '--select=F', '--exclude=.venv'],
            stdout=subprocess.PIPE,
            stderr=subprocess.STDOUT,
            text=True
        )

        # –û—Ç—Ñ–∏–ª—å—Ç—Ä–æ–≤—ã–≤–∞–µ–º –≤—Å–µ —Å–æ–æ–±—â–µ–Ω–∏—è, –Ω–∞—á–∏–Ω–∞—é—â–∏–µ—Å—è –Ω–∞ E
        filtered_output = "\n".join(
            line for line in result.stdout.splitlines()
            if not line.startswith('E')
        )

        # –ó–∞–ø–∏—Å—ã–≤–∞–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç –≤ —Ñ–∞–π–ª —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ –µ—Å—Ç—å –¥—Ä—É–≥–∏–µ –∫—Ä–∏—Ç–∏—á–Ω—ã–µ –æ—à–∏–±–∫–∏
        if filtered_output.strip():
            with open(output_file, 'w') as file:
                file.write(filtered_output)
            print(f"–†–µ–∑—É–ª—å—Ç–∞—Ç—ã –∞–Ω–∞–ª–∏–∑–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω—ã –≤ {output_file}")
        else:
            print("–ö—Ä–∏—Ç–∏—á–Ω—ã—Ö –æ—à–∏–±–æ–∫ –Ω–µ –æ–±–Ω–∞—Ä—É–∂–µ–Ω–æ.")

    except subprocess.CalledProcessError as e:
        print(f"–í–æ–∑–Ω–∏–∫–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏–∏ flake8: {e}")
    except Exception as e:
        print(f"–í–æ–∑–Ω–∏–∫–ª–∞ –Ω–µ–ø—Ä–µ–¥–≤–∏–¥–µ–Ω–Ω–∞—è –æ—à–∏–±–∫–∞: {e}")

if __name__ == "__main__":
    print("–ó–∞–ø—É—Å–∫ flake8 –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞ –∫–æ–¥–∞ –∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤...")
    run_flake8_and_save_output()
--------------------------------------------------------------------------------
Path: /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/main.py
File Name: main.py
Code:
import logging
import asyncio
from telebot.async_telebot import AsyncTeleBot
from bot.handlers import setup_bot
from database.db_handler import init_db
from config import BOT_TOKEN
from bot.scheduler import start_scheduler

# –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è
logging.basicConfig(level=logging.INFO, format='%(asctime)s [%(levelname)s] %(message)s', handlers=[logging.StreamHandler()])

async def main():
    bot = AsyncTeleBot(BOT_TOKEN)  # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –±–æ—Ç–∞

    while True:
        try:
            logging.info("–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö.")
            init_db()

            await setup_bot(bot)
            logging.info("–ë–æ—Ç –Ω–∞—Å—Ç—Ä–æ–µ–Ω –∏ –≥–æ—Ç–æ–≤ –∫ –∑–∞–ø—É—Å–∫—É.")

            await bot.infinity_polling()
        except Exception as e:
            logging.error(f"–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞: {e}")
            logging.info("–ü–µ—Ä–µ–∑–∞–ø—É—Å–∫ –±–æ—Ç–∞ —á–µ—Ä–µ–∑ 5 —Å–µ–∫—É–Ω–¥...")
            await asyncio.sleep(5)

if __name__ == "__main__":
    logging.info("–ó–∞–ø—É—Å–∫ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è.")
    asyncio.run(main())

--------------------------------------------------------------------------------
Path: /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/bot/__init__.py
File Name: __init__.py
Code:
import asyncio
from .handlers.commands import *
from bot.handlers.commands.menu_handlers import actual_send_button, get_main_menu_markup
from bot.handlers.commands.check import check_command
from bot.scheduler import start_scheduler
import logging

async def setup_bot(bot):
    logging.info("–ù–∞—Å—Ç—Ä–æ–π–∫–∞ –∫–æ–º–∞–Ω–¥ –¥–ª—è –±–æ—Ç–∞ –Ω–∞—á–∞–ª–∞—Å—å")
    main_menu_markup = get_main_menu_markup()

    bot.message_handler(commands=['start'])(lambda message: asyncio.create_task(start_bot(message, bot)))
    bot.message_handler(commands=['stop'])(lambda message: asyncio.create_task(stop_bot(message, bot)))
    bot.message_handler(commands=['show'])(lambda message: asyncio.create_task(show_signals(message, bot)))
    bot.message_handler(commands=['count'])(lambda message: asyncio.create_task(count_signals(message, bot)))
    bot.message_handler(commands=['delete_tables'])(lambda message: asyncio.create_task(delete_tables(message, bot)))
    bot.message_handler(commands=['table_signals'])(lambda message: asyncio.create_task(table_signals(message, bot)))
    bot.message_handler(commands=['actual_send'])(lambda message: asyncio.create_task(toggle_actual_send(message, bot)))
    bot.message_handler(commands=['interval'])(lambda message: asyncio.create_task(change_interval(message, bot)))
    bot.message_handler(commands=['help'])(lambda message: asyncio.create_task(send_help(message, bot)))
    bot.message_handler(commands=['logs'])(lambda message: asyncio.create_task(send_logs(message, bot)))
    bot.message_handler(commands=['delete_logs'])(lambda message: asyncio.create_task(delete_logs(message, bot)))
    bot.message_handler(commands=['check'])(lambda message: asyncio.create_task(check_command(message, bot)))  # –†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è –∫–æ–º–∞–Ω–¥—ã /check

    logging.info("–ö–æ–º–∞–Ω–¥–∞ /check –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω–∞")

    @bot.message_handler(func=lambda message: True)
    async def send_welcome(message):
        await bot.reply_to(message, "–í—ã–±–µ—Ä–∏—Ç–µ –∫–æ–º–∞–Ω–¥—É:", reply_markup=main_menu_markup)

    return bot
--------------------------------------------------------------------------------
Path: /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/bot/scheduler.py
File Name: scheduler.py
Code:
import logging
from apscheduler.schedulers.asyncio import AsyncIOScheduler
from apscheduler.triggers.interval import IntervalTrigger
from services.signal_manager import check_and_create_signals
from bot.handlers.commands.show_signals import send_pending_signals
from database.db_handler import store_signals_for_sending
from config import CRYPTO_PAIRS  # –ò–º–ø–æ—Ä—Ç–∏—Ä—É–µ–º —Å–ø–∏—Å–æ–∫ –∫—Ä–∏–ø—Ç–æ–≤–∞–ª—é—Ç–Ω—ã—Ö –ø–∞—Ä

scheduler = AsyncIOScheduler()
job = None
current_interval = None
user_chat_id = None  # –ì–ª–æ–±–∞–ª—å–Ω–∞—è –ø–µ—Ä–µ–º–µ–Ω–Ω–∞—è –¥–ª—è —Ö—Ä–∞–Ω–µ–Ω–∏—è chat_id

async def start_scheduler(check_interval, bot, chat_id):
    global job, current_interval, scheduler, user_chat_id
    logging.info("–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –∏ –∑–∞–ø—É—Å–∫ –ø–ª–∞–Ω–∏—Ä–æ–≤—â–∏–∫–∞.")

    user_chat_id = chat_id  # –°–æ—Ö—Ä–∞–Ω—è–µ–º chat_id –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è

    if scheduler.running:
        scheduler.shutdown()

    scheduler = AsyncIOScheduler()
    current_interval = check_interval
    job = scheduler.add_job(
        process_signals_func,
        trigger=IntervalTrigger(seconds=check_interval),
        args=[bot],
        id='process_signals'
    )
    scheduler.start()
    logging.info(f"–ü–ª–∞–Ω–∏—Ä–æ–≤—â–∏–∫ –∑–∞–ø—É—â–µ–Ω —Å –∏–Ω—Ç–µ—Ä–≤–∞–ª–æ–º {check_interval} —Å–µ–∫—É–Ω–¥.")

def stop_scheduler():
    global job, current_interval, scheduler
    if scheduler.running:
        scheduler.shutdown()
        job = None
        current_interval = None
        logging.info("–ü–ª–∞–Ω–∏—Ä–æ–≤—â–∏–∫ –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω.")
    else:
        logging.info("–ü–ª–∞–Ω–∏—Ä–æ–≤—â–∏–∫ —É–∂–µ –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω.")

def get_current_interval():
    global current_interval
    return current_interval

def update_scheduler_interval(new_interval):
    global job, current_interval, scheduler
    if scheduler.running and job:
        scheduler.reschedule_job(
            'process_signals', trigger=IntervalTrigger(seconds=new_interval)
        )
        current_interval = new_interval
        logging.info(f"–ò–Ω—Ç–µ—Ä–≤–∞–ª —Ä–∞–±–æ—Ç—ã –ø–ª–∞–Ω–∏—Ä–æ–≤—â–∏–∫–∞ –æ–±–Ω–æ–≤–ª–µ–Ω –¥–æ {new_interval} —Å–µ–∫—É–Ω–¥.")
    else:
        logging.warning("–ü–ª–∞–Ω–∏—Ä–æ–≤—â–∏–∫ –Ω–µ –∑–∞–ø—É—â–µ–Ω, –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∏–Ω—Ç–µ—Ä–≤–∞–ª–∞ –Ω–µ–≤–æ–∑–º–æ–∂–Ω–æ.")

async def process_signals_func(bot):
    global user_chat_id
    logging.info("–ù–∞—á–∞–ª–æ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è –ø–µ—Ä–∏–æ–¥–∏—á–µ—Å–∫–æ–π –ø—Ä–æ–≤–µ—Ä–∫–∏ —Å–∏–≥–Ω–∞–ª–æ–≤.")
    try:
        chat_id = user_chat_id  # –ò—Å–ø–æ–ª—å–∑—É–µ–º —Å–æ—Ö—Ä–∞–Ω–µ–Ω–Ω—ã–π chat_id
        if chat_id is None:
            logging.error("Chat ID –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω.")
            return

        # –í—ã–∑–æ–≤ —Ñ—É–Ω–∫—Ü–∏–∏ —Å –ø–µ—Ä–µ–¥–∞—á–µ–π CRYPTO_PAIRS
        new_signals, updated_signals, closed_signals = await check_and_create_signals(CRYPTO_PAIRS)

        logging.info(
            f"–ü–æ–ª—É—á–µ–Ω–æ –Ω–æ–≤—ã—Ö —Å–∏–≥–Ω–∞–ª–æ–≤: {len(new_signals)}, –æ–±–Ω–æ–≤–ª–µ–Ω–Ω—ã—Ö: {len(updated_signals)}, –∑–∞–∫—Ä—ã—Ç—ã—Ö: {len(closed_signals)}"
        )

        # –°–æ—Ö—Ä–∞–Ω—è–µ–º —Å–∏–≥–Ω–∞–ª—ã –¥–ª—è –æ—Ç–ø—Ä–∞–≤–∫–∏
        store_signals_for_sending(new_signals, updated_signals, closed_signals)

        # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Å–æ—Ö—Ä–∞–Ω–µ–Ω–Ω—ã–µ —Å–∏–≥–Ω–∞–ª—ã
        await send_pending_signals(bot, chat_id)

        logging.info("–ü–µ—Ä–∏–æ–¥–∏—á–µ—Å–∫–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ —Å–∏–≥–Ω–∞–ª–æ–≤ –∑–∞–≤–µ—Ä—à–µ–Ω–∞ —É—Å–ø–µ—à–Ω–æ.")
    except Exception as e:
        logging.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏–∏ –ø–µ—Ä–∏–æ–¥–∏—á–µ—Å–∫–æ–π –ø—Ä–æ–≤–µ—Ä–∫–∏ —Å–∏–≥–Ω–∞–ª–æ–≤: {e}")
        import traceback
        logging.error(traceback.format_exc())
--------------------------------------------------------------------------------
Error reading /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/bot/__pycache__/scheduler.cpython-311.pyc: 'utf-8' codec can't decode byte 0xa7 in position 0: invalid start byte
Error reading /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/bot/__pycache__/__init__.cpython-311.pyc: 'utf-8' codec can't decode byte 0xa7 in position 0: invalid start byte
Path: /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/bot/handlers/signals.py
File Name: signals.py
Code:
import logging
from telebot.async_telebot import AsyncTeleBot
from database.db_handler import get_active_signals, get_closed_signals, mark_signal_as_reported, get_signals_count
from utils.message_formatter import format_new_signal_message, format_closed_signal_message
from config import BOT_TOKEN
from .utils import send_signal_messages

bot = AsyncTeleBot(BOT_TOKEN)

@bot.message_handler(commands=['show'])
async def show_signals(message):
    logging.info("–ó–∞–ø—É—â–µ–Ω–∞ –∫–æ–º–∞–Ω–¥–∞ /show.")
    active_signals = get_active_signals()
    if not active_signals:
        logging.info("–ù–µ—Ç –∞–∫—Ç–∏–≤–Ω—ã—Ö —Å–∏–≥–Ω–∞–ª–æ–≤.")
        await bot.reply_to(message, "–í –¥–∞–Ω–Ω—ã–π –º–æ–º–µ–Ω—Ç –Ω–µ—Ç –∞–∫—Ç–∏–≤–Ω—ã—Ö —Å–∏–≥–Ω–∞–ª–æ–≤.")
    else:
        logging.info(f"–û—Ç–æ–±—Ä–∞–∂–µ–Ω–∏–µ {len(active_signals)} –∞–∫—Ç–∏–≤–Ω—ã—Ö —Å–∏–≥–Ω–∞–ª–æ–≤.")
        await send_signal_messages(bot, message.chat.id, active_signals, format_new_signal_message)

    closed_signals = get_closed_signals()
    if closed_signals:
        logging.info(f"–û—Ç–æ–±—Ä–∞–∂–µ–Ω–∏–µ {len(closed_signals)} –∑–∞–∫—Ä—ã—Ç—ã—Ö —Å–∏–≥–Ω–∞–ª–æ–≤.")
        await send_signal_messages(bot, message.chat.id, closed_signals, format_closed_signal_message)
        for signal in closed_signals:
            mark_signal_as_reported(signal[0])
        logging.info("–ó–∞–∫—Ä—ã—Ç—ã–µ —Å–∏–≥–Ω–∞–ª—ã –æ–±—Ä–∞–±–æ—Ç–∞–Ω—ã –∏ –æ—Ç–º–µ—á–µ–Ω—ã –∫–∞–∫ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–Ω—ã–µ.")
    else:
        logging.info("–ù–µ—Ç –∑–∞–∫—Ä—ã—Ç—ã—Ö —Å–∏–≥–Ω–∞–ª–æ–≤.")
        await bot.reply_to(message, "–í –¥–∞–Ω–Ω—ã–π –º–æ–º–µ–Ω—Ç –Ω–µ—Ç –∑–∞–∫—Ä—ã—Ç—ã—Ö —Å–∏–≥–Ω–∞–ª–æ–≤.")

@bot.message_handler(commands=['count'])
async def count_signals(message):
    logging.info("–ó–∞–ø—É—â–µ–Ω–∞ –∫–æ–º–∞–Ω–¥–∞ /count.")
    active_count, closed_count = get_signals_count()
    logging.info(f"–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –æ—Ç–∫—Ä—ã—Ç—ã—Ö —Å–∏–≥–Ω–∞–ª–æ–≤: {active_count}, –∑–∞–∫—Ä—ã—Ç—ã—Ö —Å–∏–≥–Ω–∞–ª–æ–≤: {closed_count}")
    await bot.reply_to(message, f"–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –æ—Ç–∫—Ä—ã—Ç—ã—Ö —Å–∏–≥–Ω–∞–ª–æ–≤: {active_count}\n–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –∑–∞–∫—Ä—ã—Ç—ã—Ö —Å–∏–≥–Ω–∞–ª–æ–≤: {closed_count}")
--------------------------------------------------------------------------------
Path: /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/bot/handlers/__init__.py
File Name: __init__.py
Code:
from .commands import (
    start_bot,
    start_scheduler_command,
    stop_bot,
    show_signals,
    count_signals,
    delete_tables,
    table_signals,
    toggle_actual_send,
    change_interval,
    send_help,
    send_logs,
    delete_logs,
    send_pending_signals,
    check_command  # –£–±–µ–¥–∏—Ç–µ—Å—å, —á—Ç–æ —ç—Ç–∞ —Å—Ç—Ä–æ–∫–∞ –ø—Ä–∏—Å—É—Ç—Å—Ç–≤—É–µ—Ç
)
from .commands.menu_handlers import (
    get_main_menu_markup,
    show_signals_button,
    count_signals_button,
    start_bot_button,
    stop_bot_button,
    help_button
)

async def setup_bot(bot):
    bot.message_handler(commands=['start'])(
        lambda message: start_bot(message, bot)
    )
    bot.message_handler(commands=['scheduler_start'])(
        lambda message: start_scheduler_command(message, bot)
    )
    bot.message_handler(commands=['stop'])(
        lambda message: stop_bot(message, bot)
    )
    bot.message_handler(commands=['show'])(
        lambda message: show_signals(message, bot)
    )
    bot.message_handler(commands=['count'])(
        lambda message: count_signals(message, bot)
    )
    bot.message_handler(commands=['delete_tables'])(
        lambda message: delete_tables(message, bot)
    )
    bot.message_handler(commands=['table_signals'])(
        lambda message: table_signals(message, bot)
    )
    bot.message_handler(commands=['actual_send'])(
        lambda message: toggle_actual_send(message, bot)
    )
    bot.message_handler(commands=['interval'])(
        lambda message: change_interval(message, bot)
    )
    bot.message_handler(commands=['help'])(
        lambda message: send_help(message, bot)
    )
    bot.message_handler(commands=['logs'])(
        lambda message: send_logs(message, bot)
    )
    bot.message_handler(commands=['delete_logs'])(
        lambda message: delete_logs(message, bot)
    )
    bot.message_handler(commands=['send_signals'])(
        lambda message: send_pending_signals(message, bot)
    )

    bot.message_handler(func=lambda message: message.text == "üìä –ü–æ–∫–∞–∑–∞—Ç—å —Å–∏–≥–Ω–∞–ª—ã")(
        lambda message: show_signals_button(message, bot)
    )
    bot.message_handler(func=lambda message: message.text == "üî¢ –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ —Å–∏–≥–Ω–∞–ª–æ–≤")(
        lambda message: count_signals_button(message, bot)
    )
    bot.message_handler(func=lambda message: message.text == "‚ñ∂Ô∏è –°—Ç–∞—Ä—Ç")(
        lambda message: start_bot_button(message, bot)
    )
    bot.message_handler(func=lambda message: message.text == "‚èπ –°—Ç–æ–ø")(
        lambda message: stop_bot_button(message, bot)
    )
    bot.message_handler(func=lambda message: message.text == "‚ùì –ü–æ–º–æ—â—å")(
        lambda message: help_button(message, bot)
    )

    return bot
--------------------------------------------------------------------------------
Path: /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/bot/handlers/utils.py
File Name: utils.py
Code:
import io
import asyncio
from telebot.async_telebot import AsyncTeleBot
from database.models import Signal
from services.crypto_api import get_ohlcv
from utils.chart_generator import generate_chart
from database.db_handler import increment_count_sends, store_signals_for_sending
import logging
from datetime import datetime
from pytz import timezone
from config import TIMEZONE, BOT_TOKEN
from utils.logger import general_logger

bot = AsyncTeleBot(BOT_TOKEN)

async def process_and_store_signals(new_signals, updated_signals, closed_signals):
    store_signals_for_sending(new_signals, updated_signals, closed_signals)
    logging.info(f"Stored for sending: {len(new_signals)} new, {len(updated_signals)} updated, {len(closed_signals)} closed signals.")

async def send_signal_messages(chat_id, signals, format_message_func, is_new=False, send_timestamp=True):
    general_logger.info(f"Started sending messages for {len(signals)} signals.")

    if signals and send_timestamp:
        current_time = datetime.now(timezone(TIMEZONE)).strftime("%Y-%m-%d %H:%M")
        separator = "-" * 40
        header_message = f"{current_time}\n{separator}"
        try:
            await bot.send_message(chat_id, header_message)
            general_logger.info(f"Sent message with timestamp and separator: {header_message}")
        except Exception as e:
            general_logger.error(f"Error sending header: {e}")
            return

    for signal in signals:
        try:
            message_text = format_message_func(signal, is_new=is_new)

            ohlcv_data = await get_ohlcv(signal.name)
            chart_buffer = generate_chart(ohlcv_data, signal.trend, signal.date_start, signal.date_last)
            chart_bytes = chart_buffer.getvalue()
            general_logger.info(f"Chart for {signal.name} generated successfully.")

            for attempt in range(3):
                try:
                    await asyncio.sleep(1)
                    if chart_bytes:
                        sent_message = await bot.send_photo(chat_id, chart_bytes, caption=message_text)
                        general_logger.info(f"Message with chart sent successfully to chat {chat_id}: {sent_message.message_id}")
                    else:
                        sent_message = await bot.send_message(chat_id, message_text)
                        general_logger.info(f"Text message sent to chat {chat_id}: {sent_message.message_id}")
                    break
                except Exception as e:
                    general_logger.error(f"Error sending message for signal {signal.name} on attempt {attempt + 1}: {e}")
                    if attempt < 2:
                        await asyncio.sleep(5)
                    else:
                        general_logger.error(f"Failed to send message for signal {signal.name} after 3 attempts.")
        except Exception as e:
            general_logger.error(f"Error processing signal {signal.name}: {e}")
--------------------------------------------------------------------------------
Path: /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/bot/handlers/periodic_tasks.py
File Name: periodic_tasks.py
Code:
import logging
from services.signal_manager import check_and_create_signals
from config import CRYPTO_PAIRS


async def perform_check(chat_id, bot):
    logging.info("–í—ã–ø–æ–ª–Ω–µ–Ω–∏–µ –ø–µ—Ä–∏–æ–¥–∏—á–µ—Å–∫–æ–π –ø—Ä–æ–≤–µ—Ä–∫–∏.")
    try:
        new_signals, updated_signals, closed_signals = check_and_create_signals(CRYPTO_PAIRS)

        # –ó–¥–µ—Å—å –¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å –ª–æ–≥–∏–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ –∏ –æ—Ç–ø—Ä–∞–≤–∫–∏ —Å–∏–≥–Ω–∞–ª–æ–≤
        # –ù–∞–ø—Ä–∏–º–µ—Ä:
        if new_signals:
            await bot.send_message(chat_id, f"–û–±–Ω–∞—Ä—É–∂–µ–Ω–æ {len(new_signals)} –Ω–æ–≤—ã—Ö —Å–∏–≥–Ω–∞–ª–æ–≤.")
        if closed_signals:
            await bot.send_message(chat_id, f"–ó–∞–∫—Ä—ã—Ç–æ {len(closed_signals)} —Å–∏–≥–Ω–∞–ª–æ–≤.")

    except Exception as e:
        logging.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏–∏ –ø–µ—Ä–∏–æ–¥–∏—á–µ—Å–∫–æ–π –ø—Ä–æ–≤–µ—Ä–∫–∏: {e}")
--------------------------------------------------------------------------------
Error reading /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/bot/handlers/__pycache__/signals.cpython-311.pyc: 'utf-8' codec can't decode byte 0xa7 in position 0: invalid start byte
Error reading /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/bot/handlers/__pycache__/utils.cpython-311.pyc: 'utf-8' codec can't decode byte 0xa7 in position 0: invalid start byte
Error reading /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/bot/handlers/__pycache__/__init__.cpython-311.pyc: 'utf-8' codec can't decode byte 0xa7 in position 0: invalid start byte
Error reading /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/bot/handlers/__pycache__/periodic_tasks.cpython-311.pyc: 'utf-8' codec can't decode byte 0xa7 in position 0: invalid start byte
Path: /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/bot/handlers/commands/delete_logs.py
File Name: delete_logs.py
Code:
import os
from pathlib import Path
from telebot.async_telebot import AsyncTeleBot
from utils.logger import general_logger, setup_logging

async def delete_logs(message, bot: AsyncTeleBot):
    general_logger.info("–ó–∞–ø—É—â–µ–Ω–∞ –∫–æ–º–∞–Ω–¥–∞ /delete_logs")
    try:
        log_dir = Path(__file__).parents[3] / 'logs'
        deleted_files = 0
        for file in os.listdir(log_dir):
            if file.endswith(".log"):
                os.remove(os.path.join(log_dir, file))
                deleted_files += 1

        # –°–æ–∑–¥–∞–µ–º –Ω–æ–≤—ã–µ –ø—É—Å—Ç—ã–µ —Ñ–∞–π–ª—ã –ª–æ–≥–æ–≤
        open(log_dir / 'general.log', 'w').close()
        open(log_dir / 'analyze.log', 'w').close()

        # –ü–µ—Ä–µ–∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º –ª–æ–≥–≥–µ—Ä—ã
        new_general_logger, new_analyze_logger = setup_logging()

        # –û–±–Ω–æ–≤–ª—è–µ–º –≥–ª–æ–±–∞–ª—å–Ω—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –≤ –º–æ–¥—É–ª–µ utils.logger
        import utils.logger
        utils.logger.general_logger = new_general_logger
        utils.logger.analyze_logger = new_analyze_logger

        response = f"–£–¥–∞–ª–µ–Ω–æ —Ñ–∞–π–ª–æ–≤ –ª–æ–≥–æ–≤: {deleted_files}. –°–æ–∑–¥–∞–Ω—ã –Ω–æ–≤—ã–µ –ø—É—Å—Ç—ã–µ —Ñ–∞–π–ª—ã –ª–æ–≥–æ–≤."
        await bot.reply_to(message, response)
        new_general_logger.info(
            f"–£–¥–∞–ª–µ–Ω–æ {deleted_files} —Ñ–∞–π–ª–æ–≤ –ª–æ–≥–æ–≤. –°–æ–∑–¥–∞–Ω—ã –Ω–æ–≤—ã–µ –ø—É—Å—Ç—ã–µ —Ñ–∞–π–ª—ã.")
    except Exception as e:
        general_logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ —É–¥–∞–ª–µ–Ω–∏–∏ –ª–æ–≥–æ–≤: {e}")
        response = "–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ —É–¥–∞–ª–µ–Ω–∏–∏ –ª–æ–≥–æ–≤."
        await bot.reply_to(message, response)
--------------------------------------------------------------------------------
Path: /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/bot/handlers/commands/count_signals.py
File Name: count_signals.py
Code:
from telebot.async_telebot import AsyncTeleBot
from database.db_handler import get_signals_count
from utils.logger import general_logger

async def count_signals(message, bot: AsyncTeleBot):
    general_logger.info("–ó–∞–ø—É—â–µ–Ω–∞ –∫–æ–º–∞–Ω–¥–∞ /count.")
    active_count, closed_count = get_signals_count()
    await bot.reply_to(
        message,
        f"–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –æ—Ç–∫—Ä—ã—Ç—ã—Ö —Å–∏–≥–Ω–∞–ª–æ–≤: {active_count}\n–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –∑–∞–∫—Ä—ã—Ç—ã—Ö —Å–∏–≥–Ω–∞–ª–æ–≤: {closed_count}"
    )
    general_logger.info(
        f"–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –æ—Ç–∫—Ä—ã—Ç—ã—Ö —Å–∏–≥–Ω–∞–ª–æ–≤: {active_count}, –∑–∞–∫—Ä—ã—Ç—ã—Ö —Å–∏–≥–Ω–∞–ª–æ–≤: {closed_count}"
    )
--------------------------------------------------------------------------------
Path: /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/bot/handlers/commands/check.py
File Name: check.py
Code:
from telebot.async_telebot import AsyncTeleBot
from utils.logger import general_logger
from bot.scheduler import process_signals_func
import logging

async def check_command(message, bot: AsyncTeleBot):
    logging.info("–ö–æ–º–∞–Ω–¥–∞ /check –≤—ã–∑–≤–∞–Ω–∞")
    general_logger.info("–ó–∞–ø—É—â–µ–Ω–∞ –∫–æ–º–∞–Ω–¥–∞ /check")
    chat_id = message.chat.id
    await bot.send_message(chat_id, "–ù–∞—á–∏–Ω–∞—é –≤–Ω–µ–ø–ª–∞–Ω–æ–≤—É—é –ø—Ä–æ–≤–µ—Ä–∫—É —Å–∏–≥–Ω–∞–ª–æ–≤...")

    await process_signals_func(bot)

    await bot.send_message(chat_id, "–í–Ω–µ–ø–ª–∞–Ω–æ–≤–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ —Å–∏–≥–Ω–∞–ª–æ–≤ –∑–∞–≤–µ—Ä—à–µ–Ω–∞.")
    general_logger.info("–í–Ω–µ–ø–ª–∞–Ω–æ–≤–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ —Å–∏–≥–Ω–∞–ª–æ–≤ –∑–∞–≤–µ—Ä—à–µ–Ω–∞")
--------------------------------------------------------------------------------
Path: /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/bot/handlers/commands/interval.py
File Name: interval.py
Code:
from bot.scheduler import update_scheduler_interval, get_current_interval, start_scheduler
from config import CHANNEL_ID

async def change_interval(message, bot):
    command_parts = message.text.split()

    if len(command_parts) == 1:
        # –ï—Å–ª–∏ –∫–æ–º–∞–Ω–¥–∞ –±–µ–∑ –∞—Ä–≥—É–º–µ–Ω—Ç–æ–≤, –ø–æ–∫–∞–∑—ã–≤–∞–µ–º —Ç–µ–∫—É—â–∏–π –∏–Ω—Ç–µ—Ä–≤–∞–ª
        current_interval = get_current_interval()
        if current_interval:
            await bot.send_message(message.chat.id,
                                   f"–¢–µ–∫—É—â–∏–π –∏–Ω—Ç–µ—Ä–≤–∞–ª –ø—Ä–æ–≤–µ—Ä–∫–∏: {int(current_interval // 60)} –º–∏–Ω—É—Ç.")
        else:
            await bot.send_message(message.chat.id, "–ü–ª–∞–Ω–∏—Ä–æ–≤—â–∏–∫ –Ω–µ –∑–∞–ø—É—â–µ–Ω.")
    elif len(command_parts) == 2:
        try:
            # –ü—ã—Ç–∞–µ–º—Å—è –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞—Ç—å –∞—Ä–≥—É–º–µ–Ω—Ç –≤ –º–∏–Ω—É—Ç—ã
            new_interval_minutes = int(command_parts[1])
            if new_interval_minutes <= 0:
                raise ValueError("–ò–Ω—Ç–µ—Ä–≤–∞–ª –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –ø–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω—ã–º —á–∏—Å–ª–æ–º.")

            # –û–±–Ω–æ–≤–ª—è–µ–º –∏–Ω—Ç–µ—Ä–≤–∞–ª (–≤ —Å–µ–∫—É–Ω–¥–∞—Ö)
            new_interval_seconds = new_interval_minutes * 60
            if get_current_interval() is None:
                # –ï—Å–ª–∏ –ø–ª–∞–Ω–∏—Ä–æ–≤—â–∏–∫ –Ω–µ –±—ã–ª –∑–∞–ø—É—â–µ–Ω, –∑–∞–ø—É—Å–∫–∞–µ–º –µ–≥–æ
                await start_scheduler(new_interval_seconds, CHANNEL_ID, bot)
            else:
                update_scheduler_interval(new_interval_seconds)
            await bot.send_message(message.chat.id,
                                   f"–ò–Ω—Ç–µ—Ä–≤–∞–ª –ø—Ä–æ–≤–µ—Ä–∫–∏ –æ–±–Ω–æ–≤–ª–µ–Ω –¥–æ {new_interval_minutes} –º–∏–Ω—É—Ç.")
        except ValueError as e:
            await bot.send_message(message.chat.id,
                                   f"–û—à–∏–±–∫–∞: {str(e)}\n–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, —É–∫–∞–∂–∏—Ç–µ –ø–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω–æ–µ —Ü–µ–ª–æ–µ —á–∏—Å–ª–æ –º–∏–Ω—É—Ç.")
    else:
        await bot.send_message(message.chat.id, "–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ: /interval [—á–∏—Å–ª–æ_–º–∏–Ω—É—Ç]")
--------------------------------------------------------------------------------
Path: /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/bot/handlers/commands/stop.py
File Name: stop.py
Code:
import asyncio
from telebot.async_telebot import AsyncTeleBot
from utils.logger import general_logger
from bot.scheduler import stop_scheduler

check_task = None

async def stop_bot(message, bot: AsyncTeleBot):
    global check_task
    if check_task and not check_task.done():
        check_task.cancel()
        try:
            await check_task
        except asyncio.CancelledError:
            pass
        check_task = None
        stop_scheduler()  # –û—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –ø–ª–∞–Ω–∏—Ä–æ–≤—â–∏–∫
        general_logger.info("–ë–æ—Ç –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω. –ü–µ—Ä–∏–æ–¥–∏—á–µ—Å–∫–∏–µ –ø—Ä–æ–≤–µ—Ä–∫–∏ –¥–µ–∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω—ã.")
        response = "–ë–æ—Ç –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω. –ü–µ—Ä–∏–æ–¥–∏—á–µ—Å–∫–∏–µ –ø—Ä–æ–≤–µ—Ä–∫–∏ –¥–µ–∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω—ã."
        await bot.reply_to(message, response)
    else:
        general_logger.info("–ë–æ—Ç –Ω–µ –∑–∞–ø—É—â–µ–Ω.")
        response = "–ë–æ—Ç –Ω–µ –∑–∞–ø—É—â–µ–Ω."
        await bot.reply_to(message, response)
--------------------------------------------------------------------------------
Path: /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/bot/handlers/commands/__init__.py
File Name: __init__.py
Code:
from .stop import stop_bot
from .show_signals import show_signals, send_pending_signals
from .count_signals import count_signals
from .delete_tables import delete_tables
from .table_signals import table_signals
from .actual_send import toggle_actual_send
from .interval import change_interval
from .help import send_help
from .logs import send_logs
from .delete_logs import delete_logs
from .start import start_bot
from .check import check_command  # –£–±–µ–¥–∏—Ç–µ—Å—å, —á—Ç–æ —ç—Ç–∞ —Å—Ç—Ä–æ–∫–∞ –ø—Ä–∏—Å—É—Ç—Å—Ç–≤—É–µ—Ç
from .menu_handlers import get_main_menu_markup, show_signals_button, count_signals_button, start_bot_button, stop_bot_button, help_button
from .scheduler_command import start_scheduler_command

__all__ = [
    'start_bot', 'stop_bot', 'show_signals', 'count_signals',
    'delete_tables', 'table_signals', 'toggle_actual_send',
    'change_interval', 'send_help', 'send_logs', 'delete_logs',
    'get_main_menu_markup', 'show_signals_button', 'count_signals_button',
    'start_bot_button', 'stop_bot_button', 'help_button', 'send_pending_signals',
    'start_scheduler_command', 'check_command'  # –î–æ–±–∞–≤—å—Ç–µ —Å—é–¥–∞ check_command
]
--------------------------------------------------------------------------------
Path: /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/bot/handlers/commands/actual_send.py
File Name: actual_send.py
Code:
from config import toggle_actual_signals, get_actual_signals_status
from utils.logger import general_logger

async def toggle_actual_send(message, bot):
    new_status = toggle_actual_signals()
    status = "–≤–∫–ª—é—á–µ–Ω–∞" if new_status else "–æ—Ç–∫–ª—é—á–µ–Ω–∞"
    response = f"–û—Ç–ø—Ä–∞–≤–∫–∞ –∞–∫—Ç—É–∞–ª—å–Ω—ã—Ö —Å–∏–≥–Ω–∞–ª–æ–≤ {status}."
    await bot.send_message(message.chat.id, response)
    general_logger.info(response)

    # –£–¥–∞–ª—è–µ–º —ç—Ç–æ—Ç –±–ª–æ–∫, —á—Ç–æ–±—ã –∏–∑–±–µ–∂–∞—Ç—å –¥—É–±–ª–∏—Ä–æ–≤–∞–Ω–∏—è —Å–æ–æ–±—â–µ–Ω–∏—è
    # if not new_status:
    #     additional_info = "–û—Ç–ø—Ä–∞–≤–∫–∞ –∞–∫—Ç—É–∞–ª—å–Ω—ã—Ö —Å–∏–≥–Ω–∞–ª–æ–≤ –æ—Ç–∫–ª—é—á–µ–Ω–∞. –ù–æ–≤—ã–µ –∏ –∑–∞–∫—Ä—ã—Ç—ã–µ —Å–∏–≥–Ω–∞–ª—ã –≤—Å—ë —Ä–∞–≤–Ω–æ –±—É–¥—É—Ç –æ—Ç–ø—Ä–∞–≤–ª—è—Ç—å—Å—è."
    # else:
    #     additional_info = "–û—Ç–ø—Ä–∞–≤–∫–∞ –∞–∫—Ç—É–∞–ª—å–Ω—ã—Ö —Å–∏–≥–Ω–∞–ª–æ–≤ –≤–∫–ª—é—á–µ–Ω–∞."

    # await bot.send_message(message.chat.id, additional_info)
    # general_logger.info(additional_info)
--------------------------------------------------------------------------------
Path: /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/bot/handlers/commands/start.py
File Name: start.py
Code:
from telebot.async_telebot import AsyncTeleBot
from utils.logger import general_logger
from config import CHECK_INTERVAL, CRYPTO_PAIRS
from bot.scheduler import start_scheduler
from database.db_handler import get_active_signals, get_closed_signals, mark_signal_as_reported
from utils.message_formatter import format_new_signal_message, format_closed_signal_message
from .menu_handlers import get_main_menu_markup  # –ü—Ä–æ–≤–µ—Ä—å—Ç–µ –ø—Ä–∞–≤–∏–ª—å–Ω–æ—Å—Ç—å –ø—É—Ç–∏ –∏ –∏–º–µ–Ω–∏ —Ñ–∞–π–ª–∞
from bot.handlers.utils import send_signal_messages
from services.signal_manager import check_and_create_signals

import asyncio

check_task = None

async def start_bot(message, bot: AsyncTeleBot):
    global check_task
    chat_id = message.chat.id  # –ü–æ–ª—É—á–∞–µ–º chat_id –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –∏–∑ —Å–æ–æ–±—â–µ–Ω–∏—è

    if check_task is None or check_task.done():
        general_logger.info("–ë–æ—Ç –∑–∞–ø—É—Å–∫–∞–µ—Ç—Å—è.")
        response = "–ë–æ—Ç –∑–∞–ø—É—â–µ–Ω –∏ –≥–æ—Ç–æ–≤ –∫ —Ä–∞–±–æ—Ç–µ. –í—ã–ø–æ–ª–Ω—è–µ—Ç—Å—è –Ω–∞—á–∞–ª—å–Ω—ã–π –∞–Ω–∞–ª–∏–∑..."
        await bot.reply_to(message, response, reply_markup=get_main_menu_markup())

        # –í—ã–ø–æ–ª–Ω–∏—Ç—å –Ω–∞—á–∞–ª—å–Ω—ã–π –∞–Ω–∞–ª–∏–∑ –∏ –æ—Ç–ø—Ä–∞–≤–∏—Ç—å —Å–∏–≥–Ω–∞–ª—ã
        check_task = asyncio.create_task(process_and_send_signals(bot, chat_id))
        await check_task

        # –ó–∞–ø—É—Å—Ç–∏—Ç—å –ø–ª–∞–Ω–∏—Ä–æ–≤—â–∏–∫ —Å chat_id
        await start_scheduler(CHECK_INTERVAL, bot, chat_id)

        general_logger.info("–ü–µ—Ä–∏–æ–¥–∏—á–µ—Å–∫–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ —Å–∏–≥–Ω–∞–ª–æ–≤ –∑–∞–ø—É—â–µ–Ω–∞.")
        await bot.send_message(chat_id, "–ù–∞—á–∞–ª—å–Ω—ã–π –∞–Ω–∞–ª–∏–∑ –∑–∞–≤–µ—Ä—à–µ–Ω. –ë–æ—Ç –≥–æ—Ç–æ–≤ –∫ —Ä–∞–±–æ—Ç–µ.")
    else:
        general_logger.info("–ë–æ—Ç —É–∂–µ —Ä–∞–±–æ—Ç–∞–µ—Ç.")
        response = "–ë–æ—Ç —É–∂–µ —Ä–∞–±–æ—Ç–∞–µ—Ç. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∫–Ω–æ–ø–∫–∏ –º–µ–Ω—é –¥–ª—è —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è."
        await bot.reply_to(message, response, reply_markup=get_main_menu_markup())

async def process_and_send_signals(bot: AsyncTeleBot, chat_id):
    general_logger.info("–í—ã–ø–æ–ª–Ω–µ–Ω–∏–µ –Ω–∞—á–∞–ª—å–Ω–æ–≥–æ –∞–Ω–∞–ª–∏–∑–∞ –∏ –æ—Ç–ø—Ä–∞–≤–∫–∞ —Å–∏–≥–Ω–∞–ª–æ–≤.")

    # –í—ã–∑–æ–≤ —Ñ—É–Ω–∫—Ü–∏–∏ –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞ —Å–∏–≥–Ω–∞–ª–æ–≤
    new_signals, updated_signals, closed_signals = await check_and_create_signals(CRYPTO_PAIRS)

    # –û—Ç–ø—Ä–∞–≤–∫–∞ –∞–∫—Ç–∏–≤–Ω—ã—Ö —Å–∏–≥–Ω–∞–ª–æ–≤
    if new_signals or updated_signals:
        await bot.send_message(
            chat_id,
            f"–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –∞–∫—Ç–∏–≤–Ω—ã—Ö —Å–∏–≥–Ω–∞–ª–æ–≤: {len(new_signals) + len(updated_signals)}"
        )
        await send_signal_messages(
            chat_id=chat_id,
            signals=new_signals + updated_signals,
            format_message_func=format_new_signal_message
        )

    # –û—Ç–ø—Ä–∞–≤–∫–∞ –∑–∞–∫—Ä—ã—Ç—ã—Ö —Å–∏–≥–Ω–∞–ª–æ–≤
    if closed_signals:
        await bot.send_message(
            chat_id,
            f"–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –∑–∞–∫—Ä—ã—Ç—ã—Ö —Å–∏–≥–Ω–∞–ª–æ–≤: {len(closed_signals)}"
        )
        await send_signal_messages(
            chat_id=chat_id,
            signals=closed_signals,
            format_message_func=format_closed_signal_message
        )
        for signal in closed_signals:
            mark_signal_as_reported(signal.id)
        general_logger.info("–ó–∞–∫—Ä—ã—Ç—ã–µ —Å–∏–≥–Ω–∞–ª—ã –æ–±—Ä–∞–±–æ—Ç–∞–Ω—ã –∏ –æ—Ç–º–µ—á–µ–Ω—ã –∫–∞–∫ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–Ω—ã–µ.")
    else:
        await bot.send_message(chat_id, "–í –¥–∞–Ω–Ω—ã–π –º–æ–º–µ–Ω—Ç –Ω–µ—Ç –∑–∞–∫—Ä—ã—Ç—ã—Ö —Å–∏–≥–Ω–∞–ª–æ–≤.")
--------------------------------------------------------------------------------
Path: /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/bot/handlers/commands/delete_tables.py
File Name: delete_tables.py
Code:
from telebot.async_telebot import AsyncTeleBot
from database.db_handler import delete_all_tables, init_db
from utils.logger import general_logger

async def delete_tables(message, bot: AsyncTeleBot):
    general_logger.info("–ó–∞–ø—É—â–µ–Ω–∞ –∫–æ–º–∞–Ω–¥–∞ /delete_tables.")
    delete_all_tables()
    init_db()
    await bot.reply_to(message, "–í—Å–µ —Ç–∞–±–ª–∏—Ü—ã –±—ã–ª–∏ —É–¥–∞–ª–µ–Ω—ã –∏ –∑–∞–Ω–æ–≤–æ —Å–æ–∑–¥–∞–Ω—ã.")
    general_logger.info("–í—Å–µ —Ç–∞–±–ª–∏—Ü—ã —É–¥–∞–ª–µ–Ω—ã –∏ –∑–∞–Ω–æ–≤–æ —Å–æ–∑–¥–∞–Ω—ã.")
--------------------------------------------------------------------------------
Path: /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/bot/handlers/commands/logs.py
File Name: logs.py
Code:
import logging
from pathlib import Path
from telebot.async_telebot import AsyncTeleBot
from utils.logger import general_logger

MAX_FILE_SIZE = 50 * 1024 * 1024  # –£—Å—Ç–∞–Ω–æ–≤–∏—Ç–µ –ª–∏–º–∏—Ç –Ω–∞ —Ä–∞–∑–º–µ—Ä —Ñ–∞–π–ª–∞ –≤ 50 MB (–∏–ª–∏ –ª—é–±–æ–π –¥—Ä—É–≥–æ–π –ª–∏–º–∏—Ç)

async def send_logs(message, bot: AsyncTeleBot):
    general_logger.info("–ó–∞–ø—Ä–æ—Å –ª–æ–≥–æ–≤ —á–µ—Ä–µ–∑ –∫–æ–º–∞–Ω–¥—É /logs")
    log_dir = Path(__file__).parents[4] / 'crypto_trend_bot' / 'logs'

    try:
        files = list(log_dir.iterdir())  # –ü–æ–ª—É—á–∞–µ–º –≤—Å–µ —Ñ–∞–π–ª—ã –≤ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–∏
        if not files:
            await bot.send_message(message.chat.id, "–ù–µ—Ç –¥–æ—Å—Ç—É–ø–Ω—ã—Ö —Ñ–∞–π–ª–æ–≤ –¥–ª—è –æ—Ç–ø—Ä–∞–≤–∫–∏.")
            general_logger.info("–ù–µ—Ç –¥–æ—Å—Ç—É–ø–Ω—ã—Ö —Ñ–∞–π–ª–æ–≤ –¥–ª—è –æ—Ç–ø—Ä–∞–≤–∫–∏.")
            return

        for log_file in files:
            if log_file.is_file():  # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ —ç—Ç–æ —Ñ–∞–π–ª, –∞ –Ω–µ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—è
                if log_file.stat().st_size == 0:
                    logging.info(f"–§–∞–π–ª {log_file.name} –ø—É—Å—Ç–æ–π, –ø—Ä–æ–ø—É—Å–∫–∞–µ–º –µ–≥–æ –æ—Ç–ø—Ä–∞–≤–∫—É.")
                    await bot.send_message(message.chat.id,
                                           f"–§–∞–π–ª {log_file.name} –ø—É—Å—Ç–æ–π –∏ –Ω–µ –±—É–¥–µ—Ç –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω.")
                    continue

                if log_file.stat().st_size > MAX_FILE_SIZE:
                    logging.warning(f"–§–∞–π–ª {log_file.name} —Å–ª–∏—à–∫–æ–º –±–æ–ª—å—à–æ–π –¥–ª—è –æ—Ç–ø—Ä–∞–≤–∫–∏.")
                    await bot.send_message(message.chat.id,
                                           f"–§–∞–π–ª {log_file.name} —Å–ª–∏—à–∫–æ–º –±–æ–ª—å—à–æ–π –∏ –Ω–µ –±—É–¥–µ—Ç –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω.")
                    continue

                with open(log_file, 'rb') as file:
                    await bot.send_document(message.chat.id, file, caption=f"–§–∞–π–ª: {log_file.name}")
                    general_logger.info(f"–§–∞–π–ª {log_file.name} –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω.")

    except Exception as e:
        general_logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–ø—Ä–∞–≤–∫–µ —Ñ–∞–π–ª–æ–≤: {e}")
        await bot.send_message(message.chat.id, "–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–ø—Ä–∞–≤–∫–µ —Ñ–∞–π–ª–æ–≤.")
--------------------------------------------------------------------------------
Path: /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/bot/handlers/commands/scheduler_command.py
File Name: scheduler_command.py
Code:
import logging
from bot.scheduler import start_scheduler, get_current_interval
from config import CHECK_INTERVAL

async def start_scheduler_command(message, bot):
    try:
        # –ü–æ–ª—É—á–∞–µ–º —Ç–µ–∫—É—â–∏–π –∏–Ω—Ç–µ—Ä–≤–∞–ª, –µ—Å–ª–∏ –ø–ª–∞–Ω–∏—Ä–æ–≤—â–∏–∫ —É–∂–µ –∑–∞–ø—É—â–µ–Ω
        current_interval = get_current_interval()

        if current_interval is None:
            # –ï—Å–ª–∏ –ø–ª–∞–Ω–∏—Ä–æ–≤—â–∏–∫ –Ω–µ –∑–∞–ø—É—â–µ–Ω, –∑–∞–ø—É—Å–∫–∞–µ–º –µ–≥–æ —Å –∏–Ω—Ç–µ—Ä–≤–∞–ª–æ–º –∏–∑ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏
            await start_scheduler(CHECK_INTERVAL, bot)
            await bot.reply_to(message, f"–ü–ª–∞–Ω–∏—Ä–æ–≤—â–∏–∫ —É—Å–ø–µ—à–Ω–æ –∑–∞–ø—É—â–µ–Ω —Å –∏–Ω—Ç–µ—Ä–≤–∞–ª–æ–º {CHECK_INTERVAL} —Å–µ–∫—É–Ω–¥.")
            logging.info("–ü–ª–∞–Ω–∏—Ä–æ–≤—â–∏–∫ —É—Å–ø–µ—à–Ω–æ –∑–∞–ø—É—â–µ–Ω.")
        else:
            # –ï—Å–ª–∏ –ø–ª–∞–Ω–∏—Ä–æ–≤—â–∏–∫ —É–∂–µ –∑–∞–ø—É—â–µ–Ω, —É–≤–µ–¥–æ–º–ª—è–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
            await bot.reply_to(message, f"–ü–ª–∞–Ω–∏—Ä–æ–≤—â–∏–∫ —É–∂–µ –∑–∞–ø—É—â–µ–Ω —Å –∏–Ω—Ç–µ—Ä–≤–∞–ª–æ–º {current_interval} —Å–µ–∫—É–Ω–¥.")
            logging.info(f"–ü–æ–ø—ã—Ç–∫–∞ –∑–∞–ø—É—Å–∫–∞ –ø–ª–∞–Ω–∏—Ä–æ–≤—â–∏–∫–∞, –Ω–æ –æ–Ω —É–∂–µ –∑–∞–ø—É—â–µ–Ω —Å –∏–Ω—Ç–µ—Ä–≤–∞–ª–æ–º {current_interval} —Å–µ–∫—É–Ω–¥.")
    except Exception as e:
        logging.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–ø—É—Å–∫–µ –ø–ª–∞–Ω–∏—Ä–æ–≤—â–∏–∫–∞: {e}")
        await bot.reply_to(message, "–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–ø—É—Å–∫–µ –ø–ª–∞–Ω–∏—Ä–æ–≤—â–∏–∫–∞.")
--------------------------------------------------------------------------------
Path: /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/bot/handlers/commands/help.py
File Name: help.py
Code:
from telebot.async_telebot import AsyncTeleBot
from utils.logger import general_logger
from .menu_handlers import get_main_menu_markup

async def send_help(message, bot: AsyncTeleBot):
    general_logger.info("–û—Ç–ø—Ä–∞–≤–∫–∞ —Å–ø—Ä–∞–≤–æ—á–Ω–æ–π –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏.")
    help_text = """
–î–æ—Å—Ç—É–ø–Ω—ã–µ –∫–æ–º–∞–Ω–¥—ã:
/start - –ó–∞–ø—É—Å—Ç–∏—Ç—å –±–æ—Ç–∞ –∏ –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞—Ç—å –ø–µ—Ä–∏–æ–¥–∏—á–µ—Å–∫–∏–µ –ø—Ä–æ–≤–µ—Ä–∫–∏
/stop - –û—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –±–æ—Ç–∞ –∏ –¥–µ–∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞—Ç—å –ø–µ—Ä–∏–æ–¥–∏—á–µ—Å–∫–∏–µ –ø—Ä–æ–≤–µ—Ä–∫–∏
/show - –ü–æ–∫–∞–∑–∞—Ç—å —Ç–µ–∫—É—â–∏–µ –∞–∫—Ç–∏–≤–Ω—ã–µ –∏ –∑–∞–∫—Ä—ã—Ç—ã–µ —Å–∏–≥–Ω–∞–ª—ã
/count - –ü–æ–∫–∞–∑–∞—Ç—å –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –æ—Ç–∫—Ä—ã—Ç—ã—Ö –∏ –∑–∞–∫—Ä—ã—Ç—ã—Ö —Å–∏–≥–Ω–∞–ª–æ–≤
/delete_tables - –£–¥–∞–ª–∏—Ç—å –≤—Å–µ —Ç–∞–±–ª–∏—Ü—ã –≤ –±–∞–∑–µ –¥–∞–Ω–Ω—ã—Ö (–∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ —Å –æ—Å—Ç–æ—Ä–æ–∂–Ω–æ—Å—Ç—å—é!)
/table_signals - –ü–æ–∫–∞–∑–∞—Ç—å —Å–æ–¥–µ—Ä–∂–∏–º–æ–µ —Ç–∞–±–ª–∏—Ü—ã `signals`
/help - –ü–æ–∫–∞–∑–∞—Ç—å —ç—Ç–æ —Å–æ–æ–±—â–µ–Ω–∏–µ –ø–æ–º–æ—â–∏
/interval - –ò–∑–º–µ–Ω–∏—Ç—å –∏–Ω—Ç–µ—Ä–≤–∞–ª –ø—Ä–æ–≤–µ—Ä–∫–∏ –∏–ª–∏ –ø–æ–∫–∞–∑–∞—Ç—å —Ç–µ–∫—É—â–∏–π –∏–Ω—Ç–µ—Ä–≤–∞–ª
/actual_send - –í–∫–ª—é—á–∏—Ç—å/–≤—ã–∫–ª—é—á–∏—Ç—å –æ—Ç–ø—Ä–∞–≤–∫—É –∞–∫—Ç—É–∞–ª—å–Ω—ã—Ö —Å–∏–≥–Ω–∞–ª–æ–≤
/logs - –ü–æ–∫–∞–∑–∞—Ç—å —Ñ–∞–π–ª—ã –ª–æ–≥–æ–≤
/delete_logs - –£–¥–∞–ª–∏—Ç—å –≤—Å–µ —Ñ–∞–π–ª—ã –ª–æ–≥–æ–≤ (–∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ —Å –æ—Å—Ç–æ—Ä–æ–∂–Ω–æ—Å—Ç—å—é!)
/check - –í—ã–ø–æ–ª–Ω–∏—Ç—å –≤–Ω–µ–ø–ª–∞–Ω–æ–≤—É—é –ø—Ä–æ–≤–µ—Ä–∫—É —Å–∏–≥–Ω–∞–ª–æ–≤
    """
    await bot.reply_to(message, help_text, reply_markup=get_main_menu_markup())
    general_logger.info("–°–ø—Ä–∞–≤–æ—á–Ω–∞—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–∞.")
--------------------------------------------------------------------------------
Path: /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/bot/handlers/commands/table_signals.py
File Name: table_signals.py
Code:
from telebot.async_telebot import AsyncTeleBot
from database.db_handler import fetch_all_signals
from utils.logger import general_logger
from utils.message_formatter import format_signals_table, add_timestamp_and_separator

async def table_signals(message, bot: AsyncTeleBot):
    general_logger.info("–ó–∞–ø—É—â–µ–Ω–∞ –∫–æ–º–∞–Ω–¥–∞ /table_signals.")
    signals = fetch_all_signals()
    if not signals:
        await bot.reply_to(message, "–¢–∞–±–ª–∏—Ü–∞ `signals` –ø—É—Å—Ç–∞.")
        general_logger.info("–¢–∞–±–ª–∏—Ü–∞ `signals` –ø—É—Å—Ç–∞.")
    else:
        table_message = format_signals_table(signals)
        table_message = add_timestamp_and_separator(table_message)
        await bot.reply_to(message, table_message)
        general_logger.info("–¢–∞–±–ª–∏—Ü–∞ `signals` –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–∞.")
--------------------------------------------------------------------------------
Path: /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/bot/handlers/commands/show_signals.py
File Name: show_signals.py
Code:
from telebot.async_telebot import AsyncTeleBot
from database.db_handler import (
    get_active_signals,
    get_closed_signals,
    mark_signal_as_reported,
    get_signals_to_send,
    mark_signal_as_sent,
    get_signal_by_id,
    increment_count_sends
)
from utils.logger import general_logger
from utils.message_formatter import format_new_signal_message, format_closed_signal_message, \
    add_timestamp_and_separator
from bot.handlers.utils import send_signal_messages
from config import get_actual_signals_status

async def show_signals(message, bot: AsyncTeleBot):
    general_logger.info("–ö–æ–º–∞–Ω–¥–∞ /show –∑–∞–ø—É—â–µ–Ω–∞.")
    chat_id = message.chat.id

    # –ü–æ–ª—É—á–µ–Ω–∏–µ –∞–∫—Ç–∏–≤–Ω—ã—Ö —Å–∏–≥–Ω–∞–ª–æ–≤
    active_signals = get_active_signals()
    if not active_signals:
        general_logger.info("–ê–∫—Ç–∏–≤–Ω—ã—Ö —Å–∏–≥–Ω–∞–ª–æ–≤ –Ω–µ—Ç.")
        await bot.reply_to(message, "–í –¥–∞–Ω–Ω—ã–π –º–æ–º–µ–Ω—Ç –Ω–µ—Ç –∞–∫—Ç–∏–≤–Ω—ã—Ö —Å–∏–≥–Ω–∞–ª–æ–≤.")
    else:
        general_logger.info(f"–ù–∞–π–¥–µ–Ω–æ {len(active_signals)} –∞–∫—Ç–∏–≤–Ω—ã—Ö —Å–∏–≥–Ω–∞–ª–æ–≤.")
        await send_signal_messages(
            chat_id=chat_id, signals=active_signals, format_message_func=format_new_signal_message
        )

    # –ü–æ–ª—É—á–µ–Ω–∏–µ –∑–∞–∫—Ä—ã—Ç—ã—Ö —Å–∏–≥–Ω–∞–ª–æ–≤
    closed_signals = get_closed_signals()
    if closed_signals:
        general_logger.info(f"–ù–∞–π–¥–µ–Ω–æ {len(closed_signals)} –∑–∞–∫—Ä—ã—Ç—ã—Ö —Å–∏–≥–Ω–∞–ª–æ–≤.")
        await send_signal_messages(
            chat_id=chat_id, signals=closed_signals, format_message_func=format_closed_signal_message
        )
        for signal in closed_signals:
            mark_signal_as_reported(signal[0])
        general_logger.info("–ó–∞–∫—Ä—ã—Ç—ã–µ —Å–∏–≥–Ω–∞–ª—ã –æ–±—Ä–∞–±–æ—Ç–∞–Ω—ã –∏ –æ—Ç–º–µ—á–µ–Ω—ã –∫–∞–∫ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–Ω—ã–µ.")
    else:
        general_logger.info("–ó–∞–∫—Ä—ã—Ç—ã—Ö —Å–∏–≥–Ω–∞–ª–æ–≤ –Ω–µ—Ç.")
        await bot.reply_to(message, "–í –¥–∞–Ω–Ω—ã–π –º–æ–º–µ–Ω—Ç –Ω–µ—Ç –∑–∞–∫—Ä—ã—Ç—ã—Ö —Å–∏–≥–Ω–∞–ª–æ–≤.")

async def send_pending_signals(bot: AsyncTeleBot, chat_id):
    general_logger.info("–û–±—Ä–∞–±–æ—Ç–∫–∞ –æ–∂–∏–¥–∞—é—â–∏—Ö —Å–∏–≥–Ω–∞–ª–æ–≤.")
    signals_to_send = get_signals_to_send()
    send_actual = get_actual_signals_status()

    signals_dict = {}
    for signal_id, signal_type in signals_to_send:
        signal = get_signal_by_id(signal_id)
        if signal:
            signals_dict[signal_id] = signal

    general_logger.info(f"–ò—Å–ø–æ–ª—å–∑—É–µ–º—ã–π chat_id: {chat_id}")

    if signals_dict:
        general_logger.info(
            f"–û—Ç–ø—Ä–∞–≤–∫–∞ {len(signals_dict)} —Å–∏–≥–Ω–∞–ª–æ–≤. –û—Ç–ø—Ä–∞–≤–∫–∞ –∞–∫—Ç—É–∞–ª—å–Ω—ã—Ö —Å–∏–≥–Ω–∞–ª–æ–≤ {'–≤–∫–ª—é—á–µ–Ω–∞' if send_actual else '–≤—ã–∫–ª—é—á–µ–Ω–∞'}.")

        if send_actual:
            timestamp_message = add_timestamp_and_separator("")
            await bot.send_message(chat_id, timestamp_message)
            general_logger.info("–û—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ —Å–æ–æ–±—â–µ–Ω–∏–µ —Å –≤—Ä–µ–º–µ–Ω–Ω–æ–π –º–µ—Ç–∫–æ–π –∏ —Ä–∞–∑–¥–µ–ª–∏—Ç–µ–ª–µ–º.")

        for signal in signals_dict.values():
            is_new = signal.count_sends == 0
            is_closed = signal.date_end is not None

            if is_new:
                general_logger.info(f"–û–±–Ω–∞—Ä—É–∂–µ–Ω –Ω–æ–≤—ã–π —Å–∏–≥–Ω–∞–ª —Å ID {signal.id}.")
            elif is_closed:
                general_logger.info(f"–û–±–Ω–∞—Ä—É–∂–µ–Ω –∑–∞–∫—Ä—ã—Ç—ã–π —Å–∏–≥–Ω–∞–ª —Å ID {signal.id}.")
            else:
                general_logger.info(f"–û–±–Ω–∞—Ä—É–∂–µ–Ω –∞–∫—Ç—É–∞–ª—å–Ω—ã–π —Å–∏–≥–Ω–∞–ª —Å ID {signal.id}.")

            if is_new or is_closed or send_actual:
                if is_closed:
                    await send_signal_messages(
                        chat_id=chat_id,
                        signals=[signal],
                        format_message_func=format_closed_signal_message,
                        send_timestamp=False
                    )
                    mark_signal_as_reported(signal.id)
                else:
                    await send_signal_messages(
                        chat_id=chat_id,
                        signals=[signal],
                        format_message_func=format_new_signal_message,
                        is_new=is_new,
                        send_timestamp=False
                    )

                success = increment_count_sends(signal.id)
                if success:
                    general_logger.info(
                        f"–£—Å–ø–µ—à–Ω–æ —É–≤–µ–ª–∏—á–µ–Ω–æ count_sends –¥–ª—è —Å–∏–≥–Ω–∞–ª–∞ —Å ID {signal.id}")
                else:
                    general_logger.warning(
                        f"–ù–µ —É–¥–∞–ª–æ—Å—å —É–≤–µ–ª–∏—á–∏—Ç—å count_sends –¥–ª—è —Å–∏–≥–Ω–∞–ª–∞ —Å ID {signal.id}")
                mark_signal_as_sent(signal.id)
            else:
                general_logger.info(
                    f"–ü—Ä–æ–ø—É—â–µ–Ω –∞–∫—Ç—É–∞–ª—å–Ω—ã–π —Å–∏–≥–Ω–∞–ª —Å ID {signal.id} –∏–∑-–∑–∞ –Ω–∞—Å—Ç—Ä–æ–µ–∫ –æ—Ç–ø—Ä–∞–≤–∫–∏")

        general_logger.info("–û–±—Ä–∞–±–æ—Ç–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ —Å–∏–≥–Ω–∞–ª–æ–≤ –∑–∞–≤–µ—Ä—à–µ–Ω–∞.")
    else:
        general_logger.info("–ù–æ–≤—ã—Ö —Å–∏–≥–Ω–∞–ª–æ–≤ –¥–ª—è –æ—Ç–ø—Ä–∞–≤–∫–∏ –Ω–µ—Ç.")
        await bot.send_message(chat_id, "–ù–æ–≤—ã—Ö —Å–∏–≥–Ω–∞–ª–æ–≤ –¥–ª—è –æ—Ç–ø—Ä–∞–≤–∫–∏ –Ω–µ—Ç.")
--------------------------------------------------------------------------------
Path: /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/bot/handlers/commands/menu_handlers.py
File Name: menu_handlers.py
Code:
from telebot.async_telebot import AsyncTeleBot
from .actual_send import toggle_actual_send
from telebot.types import ReplyKeyboardMarkup, KeyboardButton

def get_main_menu_markup():
    main_menu_markup = ReplyKeyboardMarkup(resize_keyboard=True)
    main_menu_markup.row(KeyboardButton("üìä –ü–æ–∫–∞–∑–∞—Ç—å —Å–∏–≥–Ω–∞–ª—ã"), KeyboardButton("üî¢ –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ —Å–∏–≥–Ω–∞–ª–æ–≤"))
    main_menu_markup.row(KeyboardButton("‚ñ∂Ô∏è –°—Ç–∞—Ä—Ç"), KeyboardButton("‚èπ –°—Ç–æ–ø"))
    main_menu_markup.row(KeyboardButton("/actual_send"), KeyboardButton("‚ùì –ü–æ–º–æ—â—å"))
    main_menu_markup.row(KeyboardButton("/delete_tables"), KeyboardButton("/table_signals"))
    main_menu_markup.row(KeyboardButton("/interval"), KeyboardButton("/check"))
    main_menu_markup.row(KeyboardButton("/logs"), KeyboardButton("/delete_logs"))
    return main_menu_markup

async def show_signals_button(message, bot):
    from .show_signals import show_signals
    await show_signals(message, bot)

async def count_signals_button(message, bot):
    from .count_signals import count_signals
    await count_signals(message, bot)

async def start_bot_button(message, bot):
    from .start import start_bot
    await start_bot(message, bot)

async def stop_bot_button(message, bot):
    from .stop import stop_bot
    await stop_bot(message, bot)

async def actual_send_button(message, bot):
    await toggle_actual_send(message, bot)

async def help_button(message, bot):
    from .help import send_help
    await send_help(message, bot)
--------------------------------------------------------------------------------
Error reading /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/bot/handlers/commands/__pycache__/logs.cpython-311.pyc: 'utf-8' codec can't decode byte 0xa7 in position 0: invalid start byte
Error reading /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/bot/handlers/commands/__pycache__/stop.cpython-311.pyc: 'utf-8' codec can't decode byte 0xa7 in position 0: invalid start byte
Error reading /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/bot/handlers/commands/__pycache__/check.cpython-311.pyc: 'utf-8' codec can't decode byte 0xa7 in position 0: invalid start byte
Error reading /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/bot/handlers/commands/__pycache__/menu_handlers.cpython-311.pyc: 'utf-8' codec can't decode byte 0xa7 in position 0: invalid start byte
Error reading /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/bot/handlers/commands/__pycache__/count_signals.cpython-311.pyc: 'utf-8' codec can't decode byte 0xa7 in position 0: invalid start byte
Error reading /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/bot/handlers/commands/__pycache__/delete_logs.cpython-311.pyc: 'utf-8' codec can't decode byte 0xa7 in position 0: invalid start byte
Error reading /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/bot/handlers/commands/__pycache__/scheduler_command.cpython-311.pyc: 'utf-8' codec can't decode byte 0xa7 in position 0: invalid start byte
Error reading /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/bot/handlers/commands/__pycache__/help.cpython-311.pyc: 'utf-8' codec can't decode byte 0xa7 in position 0: invalid start byte
Error reading /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/bot/handlers/commands/__pycache__/actual_send.cpython-311.pyc: 'utf-8' codec can't decode byte 0xa7 in position 0: invalid start byte
Error reading /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/bot/handlers/commands/__pycache__/interval.cpython-311.pyc: 'utf-8' codec can't decode byte 0xa7 in position 0: invalid start byte
Error reading /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/bot/handlers/commands/__pycache__/delete_tables.cpython-311.pyc: 'utf-8' codec can't decode byte 0xa7 in position 0: invalid start byte
Error reading /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/bot/handlers/commands/__pycache__/table_signals.cpython-311.pyc: 'utf-8' codec can't decode byte 0xa7 in position 0: invalid start byte
Error reading /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/bot/handlers/commands/__pycache__/show_signals.cpython-311.pyc: 'utf-8' codec can't decode byte 0xa7 in position 0: invalid start byte
Error reading /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/bot/handlers/commands/__pycache__/__init__.cpython-311.pyc: 'utf-8' codec can't decode byte 0xa7 in position 0: invalid start byte
Error reading /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/bot/handlers/commands/__pycache__/start.cpython-311.pyc: 'utf-8' codec can't decode byte 0xa7 in position 0: invalid start byte
Path: /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/database/models.py
File Name: models.py
Code:
from dataclasses import dataclass

@dataclass
class Signal:
    id: int
    name: str
    trend: str
    date_start: str
    date_last: str
    accuracy: float
    date_end: str
    price_start: float
    price_last: float
    price_end: float
    count_sends: int
    reported: int
--------------------------------------------------------------------------------
Path: /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/database/__init__.py
File Name: __init__.py
Code:

--------------------------------------------------------------------------------
Path: /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/database/db_handler.py
File Name: db_handler.py
Code:
from database.models import Signal
import sqlite3
from config import DB_NAME
from utils.logger import general_logger
from typing import Any

def init_db():
    conn = sqlite3.connect(DB_NAME)
    c = conn.cursor()

    c.execute('''CREATE TABLE IF NOT EXISTS signals
                 (id INTEGER PRIMARY KEY AUTOINCREMENT,
                  name TEXT,
                  trend TEXT,
                  date_start TEXT,
                  date_last TEXT,
                  accuracy INTEGER CHECK(accuracy >= 1 AND accuracy <= 100),
                  date_end TEXT,
                  price_start REAL,
                  price_last REAL,
                  price_end REAL,
                  count_sends INTEGER,
                  reported INTEGER DEFAULT 0)''')

    c.execute('''CREATE TABLE IF NOT EXISTS history
                 (id INTEGER PRIMARY KEY AUTOINCREMENT,
                  name TEXT,
                  trend TEXT,
                  date_start TEXT,
                  date_last TEXT,
                  accuracy INTEGER CHECK(accuracy >= 1 AND accuracy <= 100),
                  date_end TEXT,
                  price_start REAL,
                  price_last REAL,
                  price_end REAL,
                  count_sends INTEGER,
                  reported INTEGER)''')

    conn.commit()
    conn.close()

def delete_all_tables():
    conn = sqlite3.connect(DB_NAME)
    c = conn.cursor()

    c.execute("DROP TABLE IF EXISTS signals")
    c.execute("DROP TABLE IF EXISTS history")

    conn.commit()
    conn.close()

def insert_signal(name, trend, date_start, price_start, accuracy):
    conn = sqlite3.connect(DB_NAME)
    c = conn.cursor()

    c.execute('''SELECT * FROM signals 
                 WHERE name = ? AND date_end IS NULL''', (name,))
    existing_signal = c.fetchone()

    if not existing_signal:
        accuracy = max(1, min(100, int(accuracy)))
        c.execute('''INSERT INTO signals 
                     (name, trend, date_start, date_last, accuracy, price_start, price_last, count_sends)
                     VALUES (?, ?, ?, ?, ?, ?, ?, ?)''',
                  (name, trend, date_start, date_start, accuracy, price_start, price_start, 0))

    conn.commit()
    conn.close()

def update_signal(name, date_last, price_last, accuracy):
    conn = sqlite3.connect(DB_NAME)
    c = conn.cursor()
    accuracy = max(1, min(100, int(accuracy)))
    c.execute('''UPDATE signals
                 SET date_last = ?, price_last = ?, accuracy = ?
                 WHERE name = ? AND date_end IS NULL''',
              (date_last, price_last, accuracy, name))
    conn.commit()
    conn.close()

def increment_count_sends(signal_id: Any) -> bool:
    """
    Increment the count_sends for a signal.
    This function is used externally.
    """
    conn = sqlite3.connect(DB_NAME)
    c = conn.cursor()
    c.execute('''UPDATE signals
                 SET count_sends = count_sends + 1
                 WHERE id = ?''', (signal_id,))
    conn.commit()
    rows_affected = c.rowcount
    conn.close()
    general_logger.info(f"–£–≤–µ–ª–∏—á–µ–Ω–æ count_sends –¥–ª—è —Å–∏–≥–Ω–∞–ª–∞ —Å ID {signal_id}. –ó–∞—Ç—Ä–æ–Ω—É—Ç–æ —Å—Ç—Ä–æ–∫: {rows_affected}")
    return rows_affected > 0

def get_active_signals():
    conn = sqlite3.connect(DB_NAME)
    c = conn.cursor()
    c.execute('''SELECT id, name, trend, date_start, date_last, accuracy, date_end, 
                 price_start, price_last, price_end, count_sends, reported 
                 FROM signals WHERE date_end IS NULL''')
    signals = c.fetchall()
    conn.close()
    return [Signal(*signal) for signal in signals]

def get_closed_signals():
    conn = sqlite3.connect(DB_NAME)
    c = conn.cursor()
    c.execute('''SELECT id, name, trend, date_start, date_last, accuracy, date_end, 
                 price_start, price_last, price_end, count_sends, reported 
                 FROM signals 
                 WHERE date_end IS NOT NULL 
                 AND reported = 0''')
    signals = c.fetchall()
    conn.close()
    return signals

def close_signal(name, date_end, price_end):
    conn = sqlite3.connect(DB_NAME)
    c = conn.cursor()
    c.execute('''UPDATE signals
                 SET date_end = ?, price_end = ?
                 WHERE name = ? AND date_end IS NULL''',
              (date_end, price_end, name))
    conn.commit()
    conn.close()

def mark_signal_as_reported(signal_id):
    conn = sqlite3.connect(DB_NAME)
    c = conn.cursor()
    c.execute('''UPDATE signals
                 SET reported = 1
                 WHERE id = ?''', (signal_id,))
    conn.commit()
    conn.close()

def move_old_signals_to_history():
    conn = sqlite3.connect(DB_NAME)
    c = conn.cursor()
    c.execute('''INSERT INTO history
                 SELECT * FROM signals
                 WHERE date_end IS NOT NULL 
                 AND reported = 1''')
    c.execute('''DELETE FROM signals
                 WHERE date_end IS NOT NULL 
                 AND reported = 1''')
    conn.commit()
    conn.close()

def get_signals_count():
    conn = sqlite3.connect(DB_NAME)
    c = conn.cursor()
    c.execute("SELECT COUNT(*) FROM signals WHERE date_end IS NULL")
    active_count = c.fetchone()[0]
    c.execute("SELECT COUNT(*) FROM signals WHERE date_end IS NOT NULL")
    closed_count = c.fetchone()[0]
    conn.close()
    return active_count, closed_count

def fetch_all_signals():
    conn = sqlite3.connect(DB_NAME)
    c = conn.cursor()
    c.execute("SELECT * FROM signals")
    signals = c.fetchall()
    conn.close()
    return signals

def get_active_signal(name):
    conn = sqlite3.connect(DB_NAME)
    c = conn.cursor()
    c.execute('''SELECT id, name, trend, date_start, date_last, accuracy, date_end, 
                 price_start, price_last, price_end, count_sends, reported 
                 FROM signals 
                 WHERE name = ? AND date_end IS NULL''', (name,))
    signal_data = c.fetchone()
    conn.close()
    return Signal(*signal_data) if signal_data else None

def store_signals_for_sending(new_signals, updated_signals, closed_signals):
    conn = sqlite3.connect(DB_NAME)
    c = conn.cursor()

    c.execute('''CREATE TABLE IF NOT EXISTS signals_to_send
                 (id INTEGER PRIMARY KEY AUTOINCREMENT,
                  signal_id INTEGER,
                  signal_type TEXT,
                  sent INTEGER DEFAULT 0)''')

    for signal in new_signals:
        c.execute("INSERT INTO signals_to_send (signal_id, signal_type) VALUES (?, ?)",
                  (signal.id, "new"))

    for signal in updated_signals:
        c.execute("INSERT INTO signals_to_send (signal_id, signal_type) VALUES (?, ?)",
                  (signal.id, "updated"))

    for signal in closed_signals:
        c.execute("INSERT INTO signals_to_send (signal_id, signal_type) VALUES (?, ?)",
                  (signal.id, "closed"))

    conn.commit()
    conn.close()

def get_signals_to_send():
    conn = sqlite3.connect(DB_NAME)
    c = conn.cursor()

    c.execute("SELECT signal_id, signal_type FROM signals_to_send WHERE sent = 0")
    signals_to_send = c.fetchall()

    conn.close()

    return signals_to_send

def mark_signal_as_sent(signal_id):
    conn = sqlite3.connect(DB_NAME)
    c = conn.cursor()
    c.execute('''UPDATE signals_to_send
                 SET sent = 1
                 WHERE signal_id = ?''', (signal_id,))
    conn.commit()
    conn.close()
    general_logger.info(f"–°–∏–≥–Ω–∞–ª —Å ID {signal_id} –æ—Ç–º–µ—á–µ–Ω –∫–∞–∫ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–Ω—ã–π")

def get_signal_by_id(signal_id):
    conn = sqlite3.connect(DB_NAME)
    c = conn.cursor()
    c.execute("SELECT * FROM signals WHERE id = ?", (signal_id,))
    signal_data = c.fetchone()
    conn.close()
    if signal_data:
        return Signal(*signal_data)
    return None

__all__ = ['increment_count_sends']
--------------------------------------------------------------------------------
Error reading /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/database/__pycache__/models.cpython-311.pyc: 'utf-8' codec can't decode byte 0xa7 in position 0: invalid start byte
Error reading /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/database/__pycache__/db_handler.cpython-311.pyc: 'utf-8' codec can't decode byte 0xa7 in position 0: invalid start byte
Error reading /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/database/__pycache__/__init__.cpython-311.pyc: 'utf-8' codec can't decode byte 0xa7 in position 0: invalid start byte
Path: /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/services/crypto_api.py
File Name: crypto_api.py
Code:
import ccxt.async_support as ccxt
from config import EXCHANGE_API_KEY, EXCHANGE_SECRET

exchange = ccxt.binance({
    'apiKey': EXCHANGE_API_KEY,
    'secret': EXCHANGE_SECRET,
})

async def get_ohlcv(symbol, timeframe='1h', limit=48):
    try:
        ohlcv = await exchange.fetch_ohlcv(symbol, timeframe, limit=limit)
        await exchange.close()  # –í–∞–∂–Ω–æ –∑–∞–∫—Ä—ã—Ç—å —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ –ø–æ—Å–ª–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è
        return ohlcv
    except Exception as e:
        print(f"Error fetching OHLCV data: {e}")
        await exchange.close()  # –ó–∞–∫—Ä—ã–≤–∞–µ–º —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ –¥–∞–∂–µ –≤ —Å–ª—É—á–∞–µ –æ—à–∏–±–∫–∏
        return None

async def get_current_price(symbol):
    try:
        ticker = await exchange.fetch_ticker(symbol)
        await exchange.close()  # –í–∞–∂–Ω–æ –∑–∞–∫—Ä—ã—Ç—å —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ –ø–æ—Å–ª–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è
        return ticker['last']
    except Exception as e:
        print(f"Error fetching current price: {e}")
        await exchange.close()  # –ó–∞–∫—Ä—ã–≤–∞–µ–º —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ –¥–∞–∂–µ –≤ —Å–ª—É—á–∞–µ –æ—à–∏–±–∫–∏
        return None
--------------------------------------------------------------------------------
Path: /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/services/signal_manager.py
File Name: signal_manager.py
Code:
from database.db_handler import insert_signal, update_signal, close_signal, get_active_signals, get_active_signal
from services.crypto_api import get_ohlcv, get_current_price
from services.trend_analyzer import analyze_trend, is_trend_still_valid
from utils.time_utils import get_current_time
from database.models import Signal
from sqlalchemy.orm import sessionmaker
from sqlalchemy import create_engine
from utils.logger import analyze_logger, general_logger

engine = create_engine('sqlite:///path_to_your_db.sqlite')
Session = sessionmaker(bind=engine)
session = Session()

async def check_and_create_signals(crypto_pairs):
    general_logger.info("–ü—Ä–æ–≤–µ—Ä–∫–∞ –∏ —Å–æ–∑–¥–∞–Ω–∏–µ –Ω–æ–≤—ã—Ö —Å–∏–≥–Ω–∞–ª–æ–≤.")
    analyze_logger.info("–ù–∞—á–∞–ª–æ –ø—Ä–æ—Ü–µ—Å—Å–∞ –ø—Ä–æ–≤–µ—Ä–∫–∏ –∏ —Å–æ–∑–¥–∞–Ω–∏—è —Å–∏–≥–Ω–∞–ª–æ–≤")
    new_signals = []
    updated_signals = []
    closed_signals = []

    for pair in crypto_pairs:
        analyze_logger.info(f"–ê–Ω–∞–ª–∏–∑ –ø–∞—Ä—ã: {pair}")
        ohlcv = await get_ohlcv(pair)
        if ohlcv:
            trend, accuracy = analyze_trend(ohlcv)
            existing_signal = get_active_signal(pair)
            current_price = await get_current_price(pair)
            current_time = get_current_time()

            if existing_signal:
                if existing_signal.trend == trend:
                    update_signal(pair, current_time, current_price, accuracy)
                    updated_signals.append(existing_signal)
                    analyze_logger.info(f"–û–±–Ω–æ–≤–ª–µ–Ω —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–π —Å–∏–≥–Ω–∞–ª –¥–ª—è –ø–∞—Ä—ã {pair}: {trend} —Å —Ç–æ—á–Ω–æ—Å—Ç—å—é {accuracy}")
                else:
                    close_signal(pair, current_time, current_price)
                    closed_signals.append(existing_signal)
                    insert_signal(pair, trend, current_time, current_price, accuracy)
                    new_signal = get_active_signal(pair)
                    new_signals.append(new_signal)
                    analyze_logger.info(f"–ó–∞–∫—Ä—ã—Ç —Å—Ç–∞—Ä—ã–π —Å–∏–≥–Ω–∞–ª –∏ —Å–æ–∑–¥–∞–Ω –Ω–æ–≤—ã–π –¥–ª—è –ø–∞—Ä—ã {pair}: {trend} —Å —Ç–æ—á–Ω–æ—Å—Ç—å—é {accuracy}")
            else:
                insert_signal(pair, trend, current_time, current_price, accuracy)
                new_signal = get_active_signal(pair)
                new_signals.append(new_signal)
                analyze_logger.info(f"–°–æ–∑–¥–∞–Ω –Ω–æ–≤—ã–π —Å–∏–≥–Ω–∞–ª –¥–ª—è –ø–∞—Ä—ã {pair}: {trend} —Å —Ç–æ—á–Ω–æ—Å—Ç—å—é {accuracy}")
        else:
            analyze_logger.warning(f"–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –¥–∞–Ω–Ω—ã–µ OHLCV –¥–ª—è –ø–∞—Ä—ã {pair}. –ü—Ä–æ–ø—É—Å–∫.")

    analyze_logger.info("–ó–∞–≤–µ—Ä—à–µ–Ω–∏–µ –ø—Ä–æ—Ü–µ—Å—Å–∞ –ø—Ä–æ–≤–µ—Ä–∫–∏ –∏ —Å–æ–∑–¥–∞–Ω–∏—è —Å–∏–≥–Ω–∞–ª–æ–≤")
    return new_signals, updated_signals, closed_signals

def update_active_signals():
    general_logger.info("–û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∞–∫—Ç–∏–≤–Ω—ã—Ö —Å–∏–≥–Ω–∞–ª–æ–≤.")
    analyze_logger.info("–ù–∞—á–∞–ª–æ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –∞–∫—Ç–∏–≤–Ω—ã—Ö —Å–∏–≥–Ω–∞–ª–æ–≤")
    active_signals = get_active_signals()
    for signal in active_signals:
        pair = signal.name
        analyze_logger.info(f"–ê–∫—Ç—É–∞–ª–∏–∑–∞—Ü–∏—è —Å–∏–≥–Ω–∞–ª–∞ –¥–ª—è –ø–∞—Ä—ã: {pair}")
        ohlcv = get_ohlcv(pair)
        if ohlcv:
            if is_trend_still_valid(ohlcv, signal.trend):
                analyze_logger.info(f"–°–∏–≥–Ω–∞–ª –¥–ª—è –ø–∞—Ä—ã {pair} –≤—Å—ë –µ—â—ë –∞–∫—Ç—É–∞–ª–µ–Ω")
                current_price = get_current_price(pair)
                current_time = get_current_time()
                _, accuracy = analyze_trend(ohlcv)
                update_signal(pair, current_time, current_price, accuracy)
            else:
                analyze_logger.info(f"–°–∏–≥–Ω–∞–ª –¥–ª—è –ø–∞—Ä—ã {pair} –±–æ–ª—å—à–µ –Ω–µ –∞–∫—Ç—É–∞–ª–µ–Ω")
                current_price = get_current_price(pair)
                current_time = get_current_time()
                close_signal(pair, current_time, current_price)
        else:
            analyze_logger.warning(f"–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –¥–∞–Ω–Ω—ã–µ OHLCV –¥–ª—è –ø–∞—Ä—ã {pair}. –ü—Ä–æ–ø—É—Å–∫.")
    analyze_logger.info("–ó–∞–≤–µ—Ä—à–µ–Ω–∏–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –∞–∫—Ç–∏–≤–Ω—ã—Ö —Å–∏–≥–Ω–∞–ª–æ–≤")

async def update_signal_in_db(signal):
    try:
        existing_signal = session.query(Signal).get(signal.id)
        if existing_signal:
            existing_signal.trend = signal.trend
            existing_signal.accuracy = signal.accuracy
            existing_signal.close_value = signal.close_value
            session.commit()
            analyze_logger.info(f"–û–±–Ω–æ–≤–ª–µ–Ω —Å–∏–≥–Ω–∞–ª –≤ –ë–î: ID {signal.id}, —Ç—Ä–µ–Ω–¥ {signal.trend}, —Ç–æ—á–Ω–æ—Å—Ç—å {signal.accuracy}")
        else:
            analyze_logger.error(f"–°–∏–≥–Ω–∞–ª —Å ID {signal.id} –Ω–µ –Ω–∞–π–¥–µ–Ω –≤ –±–∞–∑–µ –¥–∞–Ω–Ω—ã—Ö.")
    except Exception as e:
        analyze_logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–∏ —Å–∏–≥–Ω–∞–ª–∞ –≤ –±–∞–∑–µ –¥–∞–Ω–Ω—ã—Ö: {e}")

--------------------------------------------------------------------------------
Path: /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/services/trend_analyzer.py
File Name: trend_analyzer.py
Code:
import numpy as np
from utils.logger import analyze_logger
from services.model_analyzer import PatchTSMixerAnalyzer

def analyze_trend(ohlcv_data):
    analyze_logger.info("–ù–∞—á–∞–ª–æ –∞–Ω–∞–ª–∏–∑–∞ —Ç—Ä–µ–Ω–¥–∞")
    if not ohlcv_data:
        analyze_logger.warning("–ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞")
        return None, 0

    patchtsmixer_analyzer = PatchTSMixerAnalyzer('patchtsmixer-etth1-pretrain')
    patchtsmixer_result = patchtsmixer_analyzer.analyze(ohlcv_data)

    closes = np.array([x[4] for x in ohlcv_data])
    ma_short = np.mean(closes[-24:])
    ma_long = np.mean(closes)

    analyze_logger.info(f"–ö–æ—Ä–æ—Ç–∫–∞—è MA: {ma_short}, –î–ª–∏–Ω–Ω–∞—è MA: {ma_long}")

    if ma_short > ma_long:
        trend = "long"
    elif ma_short < ma_long:
        trend = "short"
    else:
        trend = None

    diff = abs(ma_short - ma_long)
    max_diff = max(closes) - min(closes)
    accuracy = int((1 - diff / max_diff) * 100) if max_diff != 0 else 50
    accuracy = max(1, min(100, accuracy))

    if patchtsmixer_result['trend'] is not None:
        trend = patchtsmixer_result['trend']
        accuracy = patchtsmixer_result['accuracy']

    return trend, accuracy

def is_trend_still_valid(ohlcv_data, trend):
    closes = [x[4] for x in ohlcv_data]
    ma_current = sum(closes[-24:]) / 24
    if trend == "long" and ma_current > sum(closes) / len(closes):
        return True
    elif trend == "short" and ma_current < sum(closes) / len(closes):
        return True
    return False
--------------------------------------------------------------------------------
Path: /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/services/model_analyzer.py
File Name: model_analyzer.py
Code:
import torch
from transformers import PatchTSMixerConfig, PatchTSMixerForPrediction
from utils.logger import analyze_logger


class PatchTSMixerAnalyzer:
    def __init__(self, model_path):
        config = PatchTSMixerConfig(
            context_length=48,
            prediction_length=96,
            num_input_channels=1,
            patch_length=8,
            d_model=16,
            num_layers=8,
            dropout=0.2
        )
        self.model = PatchTSMixerForPrediction.from_pretrained(
            model_path,
            config=config,
            ignore_mismatched_sizes=True
        )
        self.model.eval()

    def analyze(self, data):
        if self.model is None:
            analyze_logger.warning("PatchTSMixer –º–æ–¥–µ–ª—å –Ω–µ –∑–∞–≥—Ä—É–∂–µ–Ω–∞, –ø—Ä–æ–ø—É—Å–∫ –∞–Ω–∞–ª–∏–∑–∞")
            return {'trend': None, 'accuracy': 0}

        data_tensor = torch.tensor(data, dtype=torch.float32).unsqueeze(0)
        data_tensor = self.pad_sequence(data_tensor, target_length=48)

        with torch.no_grad():
            output = self.model(past_values=data_tensor)
            predictions = output.prediction_outputs.numpy()

        trend = "long" if predictions.mean() > 0.5 else "short"
        accuracy = int(predictions.mean() * 100)

        return {'trend': trend, 'accuracy': accuracy}

    def pad_sequence(self, data_tensor, target_length=512):
        current_length = data_tensor.size(1)
        if current_length < target_length:
            padding_length = target_length - current_length
            padding = torch.zeros((data_tensor.size(0), padding_length, data_tensor.size(2)))
            data_tensor = torch.cat((padding, data_tensor), dim=1)
        elif current_length > target_length:
            data_tensor = data_tensor[:, -target_length:, :]
        return data_tensor
--------------------------------------------------------------------------------
Error reading /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/services/__pycache__/crypto_api.cpython-311.pyc: 'utf-8' codec can't decode byte 0xa7 in position 0: invalid start byte
Error reading /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/services/__pycache__/trend_analyzer.cpython-311.pyc: 'utf-8' codec can't decode byte 0xa7 in position 0: invalid start byte
Error reading /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/services/__pycache__/signal_manager.cpython-311.pyc: 'utf-8' codec can't decode byte 0xa7 in position 0: invalid start byte
Path: /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/utils/time_utils.py
File Name: time_utils.py
Code:
from datetime import datetime
from pytz import timezone
from config import TIMEZONE

def get_current_time():
    return datetime.now(timezone(TIMEZONE)).isoformat()

def format_date(date_string):
    date = datetime.fromisoformat(date_string)
    if date.tzinfo is None:
        date = date.replace(tzinfo=timezone(TIMEZONE))
    return date.astimezone(timezone(TIMEZONE)).strftime("%Y-%m-%d %H:%M")

def calculate_time_difference(start_time, end_time):
    start = datetime.fromisoformat(start_time)
    end = datetime.fromisoformat(end_time)
    if start.tzinfo is None:
        start = start.replace(tzinfo=timezone(TIMEZONE))
    if end.tzinfo is None:
        end = end.replace(tzinfo=timezone(TIMEZONE))
    diff = end - start
    days = diff.days
    hours = diff.seconds // 3600
    return f"{days} –¥–Ω–µ–π –∏ {hours} —á–∞—Å–æ–≤"
--------------------------------------------------------------------------------
Path: /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/utils/logger.py
File Name: logger.py
Code:
import logging
from logging.handlers import TimedRotatingFileHandler
from pathlib import Path

def setup_logging():
    log_dir = Path(__file__).parents[1] / 'logs'
    log_dir.mkdir(exist_ok=True)

    general_log_handler = TimedRotatingFileHandler(
        log_dir / 'general.log',
        when="D",
        interval=1,
        backupCount=7
    )
    general_log_handler.setFormatter(logging.Formatter('%(asctime)s - %(levelname)s - %(message)s'))

    analyze_log_handler = TimedRotatingFileHandler(
        log_dir / 'analyze.log',
        when="D",
        interval=1,
        backupCount=7
    )
    analyze_log_handler.setFormatter(logging.Formatter('%(asctime)s - %(levelname)s - %(message)s'))

    if logging.getLogger('general').hasHandlers():
        logging.getLogger('general').handlers.clear()

    if logging.getLogger('analyze').hasHandlers():
        logging.getLogger('analyze').handlers.clear()

    general_logger = logging.getLogger('general')
    general_logger.setLevel(logging.INFO)
    general_logger.addHandler(general_log_handler)

    analyze_logger = logging.getLogger('analyze')
    analyze_logger.setLevel(logging.INFO)
    analyze_logger.addHandler(analyze_log_handler)

    return general_logger, analyze_logger

general_logger, analyze_logger = setup_logging()

__all__ = ['setup_logging', 'general_logger', 'analyze_logger']
--------------------------------------------------------------------------------
Path: /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/utils/message_formatter.py
File Name: message_formatter.py
Code:
from datetime import datetime
from utils.time_utils import format_date, calculate_time_difference
from datetime import datetime
from config import TIMEZONE
from pytz import timezone
from utils.logger import general_logger


def add_timestamp_and_separator(message):
    current_time = datetime.now(timezone(TIMEZONE)).strftime("%Y-%m-%d %H:%M")
    separator = "-" * 40
    return f"{current_time}\n{separator}\n{message}"


def format_new_signal_message(signal, is_new=False):
    status = "–ù–æ–≤—ã–π —Å–∏–≥–Ω–∞–ª" if signal.count_sends == 0 else "–ê–∫—Ç—É–∞–ª—å–Ω–æ"
    trend_emoji = "üü¢" if signal.trend.lower() == "long" else "üî¥"
    price_change = ((signal.price_last - signal.price_start) / signal.price_start) * 100
    price_change_sign = "+" if (signal.trend.lower() == "long" and price_change > 0) or (signal.trend.lower() == "short" and price_change < 0) else "-"
    price_change_str = f"{price_change_sign}{abs(price_change):.2f}%"

    general_logger.info(
        f"–§–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ —Å–∏–≥–Ω–∞–ª–∞: {signal.name}, Count Sends: {signal.count_sends}, –°—Ç–∞—Ç—É—Å: {status}")

    return f"‚úÖ{status}: {signal.name} {trend_emoji} {signal.trend.upper()} –¢–æ—á–Ω–æ—Å—Ç—å: {signal.accuracy}\n" \
           f"–ù–∞—á–∞–ª–æ: {format_date(signal.date_start)} –¶–µ–Ω–∞: {signal.price_start}\n" \
           f"–ê–∫—Ç—É–∞–ª—å–Ω–æ –Ω–∞: {format_date(signal.date_last)} –¶–µ–Ω–∞: {signal.price_last}\n" \
           f"–ò–∑–º–µ–Ω–µ–Ω–∏–µ —Ü–µ–Ω—ã: {price_change_str}"


def format_closed_signal_message(signal):
    trend_emoji = "üü¢" if signal.trend.lower() == "long" else "üî¥"
    price_change = ((signal.price_end - signal.price_start) / signal.price_start) * 100
    price_change_sign = "+" if (signal.trend.lower() == "long" and price_change > 0) or (
                signal.trend.lower() == "short" and price_change < 0) else "-"
    price_change_str = f"{price_change_sign}{abs(price_change):.2f}%"

    return f"‚ùå–°–∏–≥–Ω–∞–ª –∑–∞–∫—Ä—ã—Ç: {signal.name} {trend_emoji} {signal.trend.upper()}\n" \
           f"–ù–∞—á–∞–ª–æ: {format_date(signal.date_start)} –¶–µ–Ω–∞: {signal.price_start}\n" \
           f"–ö–æ–Ω–µ—Ü: {format_date(signal.date_end)} –¶–µ–Ω–∞: {signal.price_end}\n" \
           f"–ò–∑–º–µ–Ω–µ–Ω–∏–µ —Ü–µ–Ω—ã: {price_change_str}\n" \
           f"–û–±—â–∞—è –¥–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å: {calculate_time_difference(signal.date_start, signal.date_end)}"


def format_signals_table(signals):
    formatted_signals = []

    for signal in signals:
        formatted_signal = (
            f"ID: {signal[0]}\n"
            f"Name: {signal[1]}\n"
            f"Trend: {signal[2]}\n"
            f"Start Date: {signal[3]}\n"
            f"Last Date: {signal[4]}\n"
            f"Accuracy: {signal[5]}\n"
            f"End Date: {signal[6]}\n"
            f"Start Price: {signal[7]}\n"
            f"Last Price: {signal[8]}\n"
            f"End Price: {signal[9]}\n"
            f"Count Sends: {signal[10]}\n"
            f"Reported: {signal[11]}\n"
            "----------------------"
        )
        formatted_signals.append(formatted_signal)

    return "\n".join(formatted_signals)
--------------------------------------------------------------------------------
Path: /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/utils/chart_generator.py
File Name: chart_generator.py
Code:
import mplfinance as mpf
import pandas as pd
import numpy as np
from datetime import datetime
import matplotlib.pyplot as plt
import io

def find_nearest_index(df, target_time):
    nearest_idx = df.index.get_indexer([target_time], method='nearest')[0]
    return df.index[nearest_idx]

def analyze_trend(df, trend):
    if len(df) == 0:
        return trend

    ma20 = df['MA20'].iloc[-1] if 'MA20' in df.columns and not df['MA20'].isnull().all() else np.nan
    ma50 = df['MA50'].iloc[-1] if 'MA50' in df.columns and not df['MA50'].isnull().all() else np.nan
    ema20 = df['EMA20'].iloc[-1] if 'EMA20' in df.columns and not df['EMA20'].isnull().all() else np.nan
    close = df['close'].iloc[-1] if 'close' in df.columns and not df['close'].isnull().all() else np.nan
    bb_upper = df['BB_upper'].iloc[-1] if 'BB_upper' in df.columns and not df['BB_upper'].isnull().all() else np.nan
    bb_lower = df['BB_lower'].iloc[-1] if 'BB_lower' in df.columns and not df['BB_lower'].isnull().all() else np.nan

    trend_signal = None

    if not np.isnan(close) and not np.isnan(ma20) and not np.isnan(ma50) and not np.isnan(ema20):
        if close > ma20 and close > ma50 and close > ema20:
            trend_signal = 'long'
        elif close < ma20 and close < ma50 and close < ema20:
            trend_signal = 'short'
    if not np.isnan(close) and not np.isnan(bb_upper) and close > bb_upper:
        trend_signal = 'overbought'
    elif not np.isnan(close) and not np.isnan(bb_lower) and close < bb_lower:
        trend_signal = 'oversold'

    return trend_signal if trend_signal else trend

def generate_chart(ohlcv_data, trend, signal_start_date=None, signal_end_date=None):
    df = pd.DataFrame(ohlcv_data, columns=['timestamp', 'open', 'high', 'low', 'close', 'volume'])
    df['timestamp'] = pd.to_datetime(df['timestamp'], unit='ms')
    df.set_index('timestamp', inplace=True)

    if len(df) < 20:
        raise ValueError("Insufficient data to compute indicators")

    df['MA20'] = df['close'].rolling(window=20).mean()
    df['MA50'] = df['close'].rolling(window=50).mean()
    df['EMA20'] = df['close'].ewm(span=20, adjust=False).mean()
    df['BB_upper'] = df['MA20'] + 2 * df['close'].rolling(window=20).std()
    df['BB_lower'] = df['MA20'] - 2 * df['close'].rolling(window=20).std()

    trend = analyze_trend(df, trend)

    mc = mpf.make_marketcolors(up='g', down='r', inherit=True)
    s = mpf.make_mpf_style(marketcolors=mc)

    apds = []

    if 'MA20' in df.columns and not df['MA20'].isnull().all():
        apds.append(mpf.make_addplot(df['MA20'], color='blue', width=1))
    if 'MA50' in df.columns and not df['MA50'].isnull().all():
        apds.append(mpf.make_addplot(df['MA50'], color='red', width=1))
    if 'EMA20' in df.columns and not df['EMA20'].isnull().all():
        apds.append(mpf.make_addplot(df['EMA20'], color='purple', width=1))
    if 'BB_upper' in df.columns and not df['BB_upper'].isnull().all():
        apds.append(mpf.make_addplot(df['BB_upper'], color='green', linestyle='--'))
    if 'BB_lower' in df.columns and not df['BB_lower'].isnull().all():
        apds.append(mpf.make_addplot(df['BB_lower'], color='green', linestyle='--'))

    if signal_start_date:
        signal_start = datetime.fromisoformat(signal_start_date)
        if signal_start.tzinfo is not None:
            signal_start = signal_start.replace(tzinfo=None)
        signal_start_index = df.index.get_indexer([signal_start], method='nearest')[0]
        signal_start_series = pd.Series([np.nan] * len(df), index=df.index)
        if trend.lower() == 'long':
            signal_start_series.iloc[signal_start_index] = df['high'].max() * 1.02
            apds.append(mpf.make_addplot(signal_start_series, type='scatter', markersize=100, marker='^', color='g'))
        elif trend.lower() == 'short':
            signal_start_series.iloc[signal_start_index] = df['high'].max() * 1.02
            apds.append(mpf.make_addplot(signal_start_series, type='scatter', markersize=100, marker='v', color='r'))

    fig, axes = mpf.plot(df, type='candle', style=s, addplot=apds,
                         title=f'Trend: {trend.capitalize()}',
                         ylabel='Price',
                         datetime_format='%Y-%m-%d %H:%M',
                         figsize=(12, 8),
                         returnfig=True)

    buf = io.BytesIO()
    plt.savefig(buf, format='png', dpi=100, bbox_inches='tight')
    buf.seek(0)
    plt.close(fig)

    return buf
--------------------------------------------------------------------------------
Error reading /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/utils/__pycache__/message_formatter.cpython-311.pyc: 'utf-8' codec can't decode byte 0xa7 in position 0: invalid start byte
Error reading /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/utils/__pycache__/logger.cpython-311.pyc: 'utf-8' codec can't decode byte 0xa7 in position 0: invalid start byte
Error reading /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/utils/__pycache__/time_utils.cpython-311.pyc: 'utf-8' codec can't decode byte 0xa7 in position 0: invalid start byte
Error reading /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/utils/__pycache__/chart_generator.cpython-311.pyc: 'utf-8' codec can't decode byte 0xa7 in position 0: invalid start byte