Project Tree Structure:
├── crypto_trend_bot/
│   ├── .DS_Store
│   ├── config.py
│   ├── requirements.txt
│   ├── Dockerfile
│   ├── check_errors.py
│   ├── test_data.py
│   ├── main.py
│   ├── bot/
│   │   ├── __init__.py
│   │   ├── __pycache__/
│   │   │   ├── __init__.cpython-311.pyc
│   │   │   └── scheduler.cpython-311.pyc
│   │   ├── handlers/
│   │   │   ├── __init__.py
│   │   │   ├── __pycache__/
│   │   │   │   ├── __init__.cpython-311.pyc
│   │   │   │   ├── periodic_tasks.cpython-311.pyc
│   │   │   │   ├── signals.cpython-311.pyc
│   │   │   │   └── utils.cpython-311.pyc
│   │   │   ├── commands/
│   │   │   │   ├── __init__.py
│   │   │   │   ├── __pycache__/
│   │   │   │   │   ├── __init__.cpython-311.pyc
│   │   │   │   │   ├── actual_send.cpython-311.pyc
│   │   │   │   │   ├── check.cpython-311.pyc
│   │   │   │   │   ├── count_signals.cpython-311.pyc
│   │   │   │   │   ├── delete_logs.cpython-311.pyc
│   │   │   │   │   ├── delete_tables.cpython-311.pyc
│   │   │   │   │   ├── help.cpython-311.pyc
│   │   │   │   │   ├── interval.cpython-311.pyc
│   │   │   │   │   ├── logs.cpython-311.pyc
│   │   │   │   │   ├── menu_handlers.cpython-311.pyc
│   │   │   │   │   ├── scheduler_command.cpython-311.pyc
│   │   │   │   │   ├── show_signals.cpython-311.pyc
│   │   │   │   │   ├── start.cpython-311.pyc
│   │   │   │   │   ├── stop.cpython-311.pyc
│   │   │   │   │   └── table_signals.cpython-311.pyc
│   │   │   │   ├── actual_send.py
│   │   │   │   ├── check.py
│   │   │   │   ├── count_signals.py
│   │   │   │   ├── delete_logs.py
│   │   │   │   ├── delete_tables.py
│   │   │   │   ├── help.py
│   │   │   │   ├── interval.py
│   │   │   │   ├── logs.py
│   │   │   │   ├── menu_handlers.py
│   │   │   │   ├── scheduler_command.py
│   │   │   │   ├── show_signals.py
│   │   │   │   ├── start.py
│   │   │   │   ├── stop.py
│   │   │   │   └── table_signals.py
│   │   │   ├── periodic_tasks.py
│   │   │   ├── signals.py
│   │   │   └── utils.py
│   │   └── scheduler.py
│   ├── database/
│   │   ├── __init__.py
│   │   ├── __pycache__/
│   │   │   ├── __init__.cpython-311.pyc
│   │   │   ├── db_handler.cpython-311.pyc
│   │   │   └── models.cpython-311.pyc
│   │   ├── db_handler.py
│   │   └── models.py
│   ├── services/
│   │   ├── __pycache__/
│   │   │   ├── crypto_api.cpython-311.pyc
│   │   │   ├── signal_manager.cpython-311.pyc
│   │   │   └── trend_analyzer.cpython-311.pyc
│   │   ├── crypto_api.py
│   │   ├── signal_manager.py
│   │   └── trend_analyzer.py
│   ├── utils/
│   │   ├── __pycache__/
│   │   │   ├── chart_generator.cpython-311.pyc
│   │   │   ├── logger.cpython-311.pyc
│   │   │   ├── message_formatter.cpython-311.pyc
│   │   │   └── time_utils.cpython-311.pyc
│   │   ├── chart_generator.py
│   │   ├── logger.py
│   │   ├── message_formatter.py
│   │   └── time_utils.py

================================================================================

Error reading /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/.DS_Store: 'utf-8' codec can't decode byte 0xf4 in position 325: invalid continuation byte
Path: /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/config.py
File Name: config.py
Code:
# Токен вашего бота
BOT_TOKEN = "7317150884:AAENXygTDLy3KGvLIh5CgxfqRRS69Rd2I1U"

# ID канала Telegram, куда бот будет отправлять сообщения
CHANNEL_ID = "7317150884"

# Список проверяемых пар
CRYPTO_PAIRS = ["BTC/USDT", "ETH/USDT", "ADA/USDT", "TON/USDT"]

# Настройки API биржи
EXCHANGE_API_KEY = "MWpeIx2bRxJW9igMlA4LDb6i7JovQLM9CYYS5AfbD803JyQhWbPAgi2m9LsBE58k"
EXCHANGE_SECRET = "nxQoPTFVJeR1U6etHoKXtIFbvV5s3nSDOY5579PKVTeHZQcHJw5VZDtJ60JslMBh"

# Настройки базы данных
DB_NAME = "price_trend_db.sqlite"

# Настройки планировщика
CHECK_INTERVAL = 15 * 60  # 15 минут в секундах

# Часовой пояс
TIMEZONE = "Europe/Samara"

_SEND_ACTUAL_SIGNALS = True

def toggle_actual_signals():
    global _SEND_ACTUAL_SIGNALS
    _SEND_ACTUAL_SIGNALS = not _SEND_ACTUAL_SIGNALS
    return _SEND_ACTUAL_SIGNALS

def get_actual_signals_status():
    return _SEND_ACTUAL_SIGNALS
--------------------------------------------------------------------------------
Path: /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/requirements.txt
File Name: requirements.txt
Code:
pyTelegramBotAPI==4.14.0
ccxt==4.0.80
numpy==1.24.3
APScheduler==3.10.4
matplotlib==3.7.2
pytz==2023.3
tabulate==0.9.0
pandas==1.5.3
mplfinance==0.12.9b7
sqlalchemy
flake8
scipy
telebot
--------------------------------------------------------------------------------
Path: /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/Dockerfile
File Name: Dockerfile
Code:
FROM python:3.11-slim

WORKDIR /app

COPY requirements.txt .

RUN pip install --no-cache-dir -r requirements.txt

COPY . .

ENV PYTHONDONTWRITEBYTECODE=1
ENV PYTHONUNBUFFERED=1

CMD ["python", "main.py"]
--------------------------------------------------------------------------------
Path: /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/check_errors.py
File Name: check_errors.py
Code:
import subprocess
import os

def run_flake8_and_save_output():
    # Определяем путь к файлу для сохранения результатов
    log_dir = os.path.join(os.path.dirname(__file__), 'logs')
    os.makedirs(log_dir, exist_ok=True)
    output_file = os.path.join(log_dir, 'check_errors.txt')

    try:
        # Запускаем flake8 с исключением каталога .venv и фильтром по критичным ошибкам
        result = subprocess.run(
            ['flake8', '--select=F', '--exclude=.venv'],
            stdout=subprocess.PIPE,
            stderr=subprocess.STDOUT,
            text=True
        )

        # Отфильтровываем все сообщения, начинающиеся на E
        filtered_output = "\n".join(
            line for line in result.stdout.splitlines()
            if not line.startswith('E')
        )

        # Записываем результат в файл только если есть другие критичные ошибки
        if filtered_output.strip():
            with open(output_file, 'w') as file:
                file.write(filtered_output)
            print(f"Результаты анализа сохранены в {output_file}")
        else:
            print("Критичных ошибок не обнаружено.")

    except subprocess.CalledProcessError as e:
        print(f"Возникла ошибка при выполнении flake8: {e}")
    except Exception as e:
        print(f"Возникла непредвиденная ошибка: {e}")

if __name__ == "__main__":
    print("Запуск flake8 для анализа кода и сохранения результатов...")
    run_flake8_and_save_output()
--------------------------------------------------------------------------------
Path: /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/test_data.py
File Name: test_data.py
Code:
from database.db_handler import insert_signal, update_signal, close_signal, init_db, update_db_structure
from datetime import datetime, timedelta

def add_test_data():
    init_db()  # Ensure the database is initialized
    update_db_structure()  # Update the database structure if needed

    now = datetime.now()

    # Новый сигнал BTC/USDT
    insert_signal("BTC/USDT", "bullish", now.isoformat(), 50000, 80, "upward")

    # Актуальный сигнал ETH/USDT
    eth_start = now - timedelta(days=2)
    insert_signal("ETH/USDT", "bearish", eth_start.isoformat(), 3000, 75, "downward")
    update_signal("ETH/USDT", now.isoformat(), 2900, 78, "stable")

    # Закрытый сигнал ADA/USDT
    ada_start = now - timedelta(days=5)
    ada_end = now - timedelta(days=1)
    insert_signal("ADA/USDT", "bullish", ada_start.isoformat(), 1.2, 70, "upward")
    update_signal("ADA/USDT", ada_end.isoformat(), 1.3, 72, "downward")
    close_signal("ADA/USDT", now.isoformat(), 1.25)

if __name__ == "__main__":
    add_test_data()
    print("Test data added to the database.")
--------------------------------------------------------------------------------
Path: /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/main.py
File Name: main.py
Code:
import logging
import asyncio
from telebot.async_telebot import AsyncTeleBot
from bot import setup_bot
from database.db_handler import init_db
from config import BOT_TOKEN
from bot.scheduler import start_scheduler

logging.basicConfig(level=logging.INFO, format='%(asctime)s [%(levelname)s] %(message)s',
                    handlers=[logging.StreamHandler()])

# Отключаем логи для библиотек
logging.getLogger("asyncio").setLevel(logging.WARNING)
logging.getLogger("urllib3").setLevel(logging.WARNING)
logging.getLogger("ccxt").setLevel(logging.WARNING)

async def main():
    bot = AsyncTeleBot(BOT_TOKEN)
    logging.info(f"Тип переменной bot: {type(bot)}")

    while True:
        try:
            logging.info("Инициализация базы данных.")
            init_db()

            logging.info("Настройка бота.")
            await setup_bot(bot)
            logging.info("Бот настроен и готов к запуску.")
            logging.info(f"Тип переменной bot перед infinity_polling: {type(bot)}")

            logging.info("Запуск infinity_polling.")
            await bot.infinity_polling(timeout=10, request_timeout=15)

        except Exception as e:
            logging.error(f"Произошла ошибка: {e}")
            logging.info("Перезапуск бота через 5 секунд...")
            await asyncio.sleep(5)

if __name__ == "__main__":
    logging.info("Запуск приложения.")
    asyncio.run(main())
--------------------------------------------------------------------------------
Path: /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/bot/__init__.py
File Name: __init__.py
Code:
import asyncio
import logging
import traceback
from bot.handlers.commands import (
    start_bot, start_scheduler_command, stop_bot, show_signals,
    count_signals, delete_tables, table_signals, toggle_actual_send,
    change_interval, send_help, send_logs, delete_logs, send_pending_signals
)
from bot.handlers.commands.menu_handlers import (
    get_main_menu_markup, show_signals_button, count_signals_button,
    start_bot_button, stop_bot_button, help_button,
    delete_tables_button, table_signals_button,
    change_interval_button, check_command_button,
    send_logs_button, delete_logs_button, actual_send_button
)
from bot.handlers.commands.check import check_command

async def setup_bot(bot):
    logging.info("Настройка команд для бота началась")
    main_menu_markup = get_main_menu_markup()

    def log_and_execute(func):
        async def wrapper(message):
            try:
                logging.info(f"Выполнение команды: {func.__name__}")
                await func(message, bot)
            except Exception as e:
                logging.error(f"Ошибка при выполнении {func.__name__}: {e}")
                logging.error(f"Traceback: {traceback.format_exc()}")
        return wrapper

    # Регистрация текстовых команд
    command_handlers = [
        ('start', start_bot),
        ('scheduler_start', start_scheduler_command),
        ('stop', stop_bot),
        ('show', show_signals),
        ('count', count_signals),
        ('delete_tables', delete_tables),
        ('table_signals', table_signals),
        ('actual_send', toggle_actual_send),
        ('interval', change_interval),
        ('help', send_help),
        ('logs', send_logs),
        ('delete_logs', delete_logs),
        ('check', check_command),
        ('send_signals', send_pending_signals)
    ]

    for command, handler in command_handlers:
        bot.register_message_handler(log_and_execute(handler), commands=[command])

    # Регистрация кнопок меню
    button_handlers = [
        ("📊 Показать сигналы", show_signals_button),
        ("🔢 Количество сигналов", count_signals_button),
        ("▶️ Старт", start_bot_button),
        ("⏹ Стоп", stop_bot_button),
        ("❓ Помощь", help_button),
        ("🗑 Удалить таблицы", delete_tables_button),
        ("📋 Таблица сигналов", table_signals_button),
        ("⏱ Изменить интервал", change_interval_button),
        ("🔍 Проверить сейчас", check_command_button),
        ("📁 Показать логи", send_logs_button),
        ("🗑 Удалить логи", delete_logs_button),
        ("🔄 Переключить отправку", actual_send_button)
    ]

    for button_text, handler in button_handlers:
        bot.register_message_handler(log_and_execute(handler), func=lambda message, text=button_text: message.text == text)

    # Обработчик по умолчанию для сообщений без команд
    async def send_welcome(message):
        logging.info("Выполнение обработчика по умолчанию")
        await bot.reply_to(message, "Выберите команду:", reply_markup=main_menu_markup)

    bot.register_message_handler(send_welcome, func=lambda message: True)

    logging.info("Настройка команд для бота завершена")
    return bot
--------------------------------------------------------------------------------
Path: /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/bot/scheduler.py
File Name: scheduler.py
Code:
import logging
from apscheduler.schedulers.asyncio import AsyncIOScheduler
from apscheduler.triggers.interval import IntervalTrigger
from services.signal_manager import check_and_create_signals
from bot.handlers.commands.show_signals import send_pending_signals
from database.db_handler import store_signals_for_sending
from config import CRYPTO_PAIRS

scheduler = AsyncIOScheduler()
job = None
current_interval = None
user_chat_id = None

async def start_scheduler(check_interval, bot, chat_id):
    global job, current_interval, scheduler, user_chat_id
    logging.info("Инициализация и запуск планировщика.")
    logging.info(f"Типы переменных перед запуском планировщика: scheduler={type(scheduler)}, job={type(job)}, current_interval={type(current_interval)}, bot={type(bot)}")

    user_chat_id = chat_id

    if scheduler.running:
        scheduler.shutdown()

    scheduler = AsyncIOScheduler()
    current_interval = check_interval
    job = scheduler.add_job(
        process_signals_func,
        trigger=IntervalTrigger(seconds=check_interval),
        args=[bot],
        id='process_signals'
    )
    logging.info(f"Тип переменной job после создания задачи: {type(job)}")
    scheduler.start()
    logging.info(f"Планировщик запущен с интервалом {check_interval} секунд.")

def stop_scheduler():
    global job, current_interval, scheduler
    logging.info(f"Типы переменных перед остановкой планировщика: scheduler={type(scheduler)}, job={type(job)}, current_interval={type(current_interval)}")
    if scheduler.running:
        scheduler.shutdown()
        job = None
        current_interval = None
        logging.info("Планировщик остановлен.")
    else:
        logging.info("Планировщик уже остановлен.")

def get_current_interval():
    global current_interval
    return current_interval

def update_scheduler_interval(new_interval):
    global job, current_interval, scheduler
    logging.info(f"Типы переменных перед обновлением интервала планировщика: scheduler={type(scheduler)}, job={type(job)}, current_interval={type(current_interval)}")
    if scheduler.running and job:
        logging.info(f"Тип переменной job перед изменением интервала: {type(job)}")
        scheduler.reschedule_job(
            'process_signals', trigger=IntervalTrigger(seconds=new_interval)
        )
        current_interval = new_interval
        logging.info(f"Интервал работы планировщика обновлен до {new_interval} секунд.")
    else:
        logging.warning("Планировщик не запущен, обновление интервала невозможно.")

def is_scheduler_running():
    global scheduler
    return scheduler.running if scheduler else False

async def process_signals_func(bot):
    global user_chat_id
    logging.info(f"Начало выполнения периодической проверки сигналов. Тип переменной bot: {type(bot)}")
    try:
        chat_id = user_chat_id
        if chat_id is None:
            logging.error("Chat ID пользователя не установлен.")
            return

        new_signals, updated_signals, closed_signals = await check_and_create_signals(CRYPTO_PAIRS)

        logging.info(
            f"Получено новых сигналов: {len(new_signals)}, обновленных: {len(updated_signals)}, закрытых: {len(closed_signals)}"
        )

        store_signals_for_sending(new_signals, updated_signals, closed_signals)

        # Дополнительное логирование перед отправкой сигналов
        logging.info(f"Перед отправкой сигналов. Тип переменной bot: {type(bot)}, Функция send_pending_signals: {send_pending_signals}")
        await send_pending_signals(bot, chat_id)

        logging.info("Периодическая проверка сигналов завершена успешно.")
    except Exception as e:
        logging.error(f"Ошибка при выполнении периодической проверки сигналов: {e}")
        import traceback
        logging.error(traceback.format_exc())
--------------------------------------------------------------------------------
Error reading /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/bot/__pycache__/scheduler.cpython-311.pyc: 'utf-8' codec can't decode byte 0xa7 in position 0: invalid start byte
Error reading /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/bot/__pycache__/__init__.cpython-311.pyc: 'utf-8' codec can't decode byte 0xa7 in position 0: invalid start byte
Path: /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/bot/handlers/signals.py
File Name: signals.py
Code:
import logging
from telebot.async_telebot import AsyncTeleBot
from database.db_handler import get_active_signals, get_closed_signals, mark_signal_as_reported, get_signals_count
from utils.message_formatter import format_new_signal_message, format_closed_signal_message
from config import BOT_TOKEN
from .utils import send_signal_messages

bot = AsyncTeleBot(BOT_TOKEN)

@bot.message_handler(commands=['show'])
async def show_signals(message):
    logging.info("Запущена команда /show.")
    active_signals = get_active_signals()
    if not active_signals:
        logging.info("Нет активных сигналов.")
        await bot.reply_to(message, "В данный момент нет активных сигналов.")
    else:
        logging.info(f"Отображение {len(active_signals)} активных сигналов.")
        await send_signal_messages(bot, message.chat.id, active_signals, format_new_signal_message)

    closed_signals = get_closed_signals()
    if closed_signals:
        logging.info(f"Отображение {len(closed_signals)} закрытых сигналов.")
        await send_signal_messages(bot, message.chat.id, closed_signals, format_closed_signal_message)
        for signal in closed_signals:
            mark_signal_as_reported(signal[0])
        logging.info("Закрытые сигналы обработаны и отмечены как отправленные.")
    else:
        logging.info("Нет закрытых сигналов.")
        await bot.reply_to(message, "В данный момент нет закрытых сигналов.")

@bot.message_handler(commands=['count'])
async def count_signals(message):
    logging.info("Запущена команда /count.")
    active_count, closed_count = get_signals_count()
    logging.info(f"Количество открытых сигналов: {active_count}, закрытых сигналов: {closed_count}")
    await bot.reply_to(message, f"Количество открытых сигналов: {active_count}\nКоличество закрытых сигналов: {closed_count}")
--------------------------------------------------------------------------------
Path: /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/bot/handlers/__init__.py
File Name: __init__.py
Code:

--------------------------------------------------------------------------------
Path: /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/bot/handlers/utils.py
File Name: utils.py
Code:
import io
import asyncio
from telebot.async_telebot import AsyncTeleBot
from database.models import Signal
from services.crypto_api import get_ohlcv
from utils.chart_generator import generate_chart
from database.db_handler import increment_count_sends, store_signals_for_sending, get_signals_to_send, get_signal_by_id, mark_signal_as_reported, mark_signal_as_sent
import logging
from datetime import datetime
from pytz import timezone
from config import TIMEZONE, BOT_TOKEN, get_actual_signals_status
from utils.logger import general_logger
from utils.message_formatter import format_closed_signal_message, format_new_signal_message

bot = AsyncTeleBot(BOT_TOKEN)

async def process_and_store_signals(new_signals, updated_signals, closed_signals):
    store_signals_for_sending(new_signals, updated_signals, closed_signals)
    logging.info(f"Сохранено для отправки: {len(new_signals)} новых, {len(updated_signals)} обновленных, {len(closed_signals)} закрытых сигналов.")

async def send_signal_messages(chat_id, signals, format_message_func, is_new=False):
    general_logger.info(f"Начата отправка сообщений для {len(signals)} сигналов.")

    for signal in signals:
        if not is_new and not get_actual_signals_status():
            continue

        try:
            if format_message_func.__name__ == "format_new_signal_message":
                message_text = format_message_func(signal, is_new=is_new)
            else:
                message_text = format_message_func(signal)

            ohlcv_data = await get_ohlcv(signal.name)
            chart_buffer = generate_chart(ohlcv_data, signal.trend, signal.date_start,
                                          signal.date_last)
            chart_bytes = chart_buffer.getvalue()
            general_logger.info(f"График для {signal.name} успешно создан.")

            for attempt in range(3):
                try:
                    await asyncio.sleep(1)
                    if chart_bytes:
                        sent_message = await bot.send_photo(chat_id, chart_bytes,
                                                            caption=message_text)
                        general_logger.info(
                            f"Сообщение с графиком успешно отправлено в чат {chat_id}: {sent_message.message_id}")
                    else:
                        sent_message = await bot.send_message(chat_id, message_text)
                        general_logger.info(
                            f"Текстовое сообщение отправлено в чат {chat_id}: {sent_message.message_id}")

                    success = increment_count_sends(signal.id)
                    if success:
                        general_logger.info(
                            f"Успешно увеличено количество отправок для сигнала с ID {signal.id}")
                    else:
                        general_logger.warning(
                            f"Не удалось увеличить количество отправок для сигнала с ID {signal.id}")
                    break
                except Exception as e:
                    general_logger.error(
                        f"Ошибка при отправке сообщения для сигнала {signal.name} на попытке {attempt + 1}: {e}")
                    if attempt < 2:
                        await asyncio.sleep(5)
                    else:
                        general_logger.error(
                            f"Не удалось отправить сообщение для сигнала {signal.name} после 3 попыток.")
        except Exception as e:
            general_logger.error(f"Ошибка при обработке сигнала {signal.name}: {e}")

async def send_pending_signals(bot: AsyncTeleBot, chat_id):
    general_logger.info("Обработка отложенных сигналов.")
    signals_to_send = get_signals_to_send()
    send_actual = get_actual_signals_status()

    signals_dict = {}
    for signal_id, signal_type in signals_to_send:
        signal = get_signal_by_id(signal_id)
        if signal:
            signals_dict[signal_id] = signal

    general_logger.info(f"Используем chat_id: {chat_id}")

    if signals_dict:
        general_logger.info(
            f"Отправка {len(signals_dict)} сигналов. Актуальная отправка сигналов "
            f"{'включена' if send_actual else 'выключена'}."
        )

        # Отправляем разделитель только если актуальная отправка выключена и есть сигналы для отправки
        if not send_actual and signals_dict:
            current_time = datetime.now(timezone(TIMEZONE)).strftime("%Y-%m-%d %H:%M")
            separator = "=" * 40
            separator_message = f"{separator}\n{current_time}\n{separator}"
            await bot.send_message(chat_id, separator_message)

        for signal in signals_dict.values():
            is_new = signal.count_sends == 0
            is_closed = signal.date_end is not None

            if is_new:
                general_logger.info(f"Обнаружен новый сигнал с ID {signal.id}.")
            elif is_closed:
                general_logger.info(f"Обнаружен закрытый сигнал с ID {signal.id}.")
            else:
                general_logger.info(f"Обнаружен актуальный сигнал с ID {signal.id}.")

            if is_new or is_closed or send_actual:
                if is_closed:
                    await send_signal_messages(
                        chat_id=chat_id,
                        signals=[signal],
                        format_message_func=format_closed_signal_message,
                    )
                    mark_signal_as_reported(signal.id)
                else:
                    await send_signal_messages(
                        chat_id=chat_id,
                        signals=[signal],
                        format_message_func=format_new_signal_message,
                        is_new=is_new,
                    )

                success = increment_count_sends(signal.id)
                if success:
                    general_logger.info(
                        f"Успешно увеличено количество отправок для сигнала с ID {signal.id}"
                    )
                else:
                    general_logger.warning(
                        f"Не удалось увеличить количество отправок для сигнала с ID {signal.id}"
                    )
                mark_signal_as_sent(signal.id)
            else:
                general_logger.info(
                    f"Пропущен актуальный сигнал с ID {signal.id} из-за настроек отправки"
                )

        general_logger.info("Процесс отправки сигналов завершен.")
    else:
        general_logger.info("Нет новых сигналов для отправки.")
        await bot.send_message(chat_id, "Нет новых сигналов для отправки.")
--------------------------------------------------------------------------------
Path: /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/bot/handlers/periodic_tasks.py
File Name: periodic_tasks.py
Code:
import logging
from services.signal_manager import check_and_create_signals
from config import CRYPTO_PAIRS


async def perform_check(chat_id, bot):
    logging.info("Выполнение периодической проверки.")
    try:
        new_signals, updated_signals, closed_signals = check_and_create_signals(CRYPTO_PAIRS)

        if new_signals:
            await bot.send_message(chat_id, f"Обнаружено {len(new_signals)} новых сигналов.")
        if closed_signals:
            await bot.send_message(chat_id, f"Закрыто {len(closed_signals)} сигналов.")

    except Exception as e:
        logging.error(f"Ошибка при выполнении периодической проверки: {e}")
--------------------------------------------------------------------------------
Error reading /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/bot/handlers/__pycache__/signals.cpython-311.pyc: 'utf-8' codec can't decode byte 0xa7 in position 0: invalid start byte
Error reading /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/bot/handlers/__pycache__/utils.cpython-311.pyc: 'utf-8' codec can't decode byte 0xa7 in position 0: invalid start byte
Error reading /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/bot/handlers/__pycache__/__init__.cpython-311.pyc: 'utf-8' codec can't decode byte 0xa7 in position 0: invalid start byte
Error reading /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/bot/handlers/__pycache__/periodic_tasks.cpython-311.pyc: 'utf-8' codec can't decode byte 0xa7 in position 0: invalid start byte
Path: /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/bot/handlers/commands/delete_logs.py
File Name: delete_logs.py
Code:
import os
from pathlib import Path
from telebot.async_telebot import AsyncTeleBot
from utils.logger import general_logger, setup_logging

async def delete_logs(message, bot: AsyncTeleBot):
    general_logger.info("Запущена команда /delete_logs")
    try:
        log_dir = Path(__file__).parents[3] / 'logs'
        deleted_files = 0
        for file in os.listdir(log_dir):
            if file.endswith(".log"):
                os.remove(os.path.join(log_dir, file))
                deleted_files += 1

        open(log_dir / 'general.log', 'w').close()
        open(log_dir / 'analyze.log', 'w').close()

        new_general_logger, new_analyze_logger = setup_logging()

        import utils.logger
        utils.logger.general_logger = new_general_logger
        utils.logger.analyze_logger = new_analyze_logger

        response = f"Удалено файлов логов: {deleted_files}. Созданы новые пустые файлы логов."
        await bot.reply_to(message, response)
        new_general_logger.info(
            f"Удалено {deleted_files} файлов логов. Созданы новые пустые файлы.")
    except Exception as e:
        general_logger.error(f"Ошибка при удалении логов: {e}")
        response = "Произошла ошибка при удалении логов."
        await bot.reply_to(message, response)
--------------------------------------------------------------------------------
Path: /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/bot/handlers/commands/count_signals.py
File Name: count_signals.py
Code:
from telebot.async_telebot import AsyncTeleBot
from database.db_handler import get_signals_count
from utils.logger import general_logger

async def count_signals(message, bot: AsyncTeleBot):
    general_logger.info("Запущена команда /count.")
    active_count, closed_count = get_signals_count()
    await bot.reply_to(
        message,
        f"Количество открытых сигналов: {active_count}\nКоличество закрытых сигналов: {closed_count}"
    )
    general_logger.info(
        f"Количество открытых сигналов: {active_count}, закрытых сигналов: {closed_count}"
    )
--------------------------------------------------------------------------------
Path: /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/bot/handlers/commands/check.py
File Name: check.py
Code:
from telebot.async_telebot import AsyncTeleBot
from utils.logger import general_logger
from services.signal_manager import check_and_create_signals
from bot.handlers.commands.show_signals import show_signals  # Импорт функции show_signals
from config import CRYPTO_PAIRS  # Импорт списка криптовалютных пар из config.py

async def check_command(message, bot: AsyncTeleBot):
    general_logger.info("Команда /check вызвана")
    await bot.reply_to(message, "Начинаю внеплановую проверку сигналов...")

    # Передаем CRYPTO_PAIRS в функцию check_and_create_signals
    await check_and_create_signals(CRYPTO_PAIRS)

    general_logger.info("Внеплановая проверка сигналов завершена.")
    await bot.reply_to(message, "Внеплановая проверка сигналов завершена.")

    # Вызов функции show_signals после завершения проверки
    await show_signals(message, bot)
    general_logger.info("Автоматическая отправка сигналов после проверки завершена.")
--------------------------------------------------------------------------------
Path: /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/bot/handlers/commands/interval.py
File Name: interval.py
Code:
from bot.scheduler import update_scheduler_interval, get_current_interval, start_scheduler
from config import CHANNEL_ID

async def change_interval(message, bot):
    command_parts = message.text.split()

    if len(command_parts) == 1:
        current_interval = get_current_interval()
        if current_interval:
            await bot.send_message(message.chat.id,
                                   f"Текущий интервал проверки: {int(current_interval // 60)} минут.")
        else:
            await bot.send_message(message.chat.id, "Планировщик не запущен.")
    elif len(command_parts) == 2:
        try:
            new_interval_minutes = int(command_parts[1])
            if new_interval_minutes <= 0:
                raise ValueError("Интервал должен быть положительным числом.")

            new_interval_seconds = new_interval_minutes * 60
            if get_current_interval() is None:
                await start_scheduler(new_interval_seconds, CHANNEL_ID, bot)
            else:
                update_scheduler_interval(new_interval_seconds)
            await bot.send_message(message.chat.id,
                                   f"Интервал проверки обновлен до {new_interval_minutes} минут.")
        except ValueError as e:
            await bot.send_message(message.chat.id,
                                   f"Ошибка: {str(e)}\nПожалуйста, укажите положительное целое число минут.")
    else:
        await bot.send_message(message.chat.id, "Использование: /interval [число_минут]")
--------------------------------------------------------------------------------
Path: /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/bot/handlers/commands/stop.py
File Name: stop.py
Code:
import asyncio
from telebot.async_telebot import AsyncTeleBot
from utils.logger import general_logger
from bot.scheduler import stop_scheduler, is_scheduler_running

check_task = None

async def stop_bot(message, bot: AsyncTeleBot):
    global check_task
    if check_task and not check_task.done() or is_scheduler_running():
        if check_task and not check_task.done():
            check_task.cancel()
            try:
                await check_task
            except asyncio.CancelledError:
                pass
        check_task = None
        stop_scheduler()
        general_logger.info("Бот остановлен. Периодические проверки деактивированы.")
        response = "Бот остановлен. Периодические проверки деактивированы."
    else:
        general_logger.info("Бот не запущен.")
        response = "Бот не запущен."
    await bot.reply_to(message, response)
--------------------------------------------------------------------------------
Path: /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/bot/handlers/commands/__init__.py
File Name: __init__.py
Code:
from .stop import stop_bot
from .show_signals import show_signals, send_pending_signals
from .count_signals import count_signals
from .delete_tables import delete_tables
from .table_signals import table_signals
from .actual_send import toggle_actual_send
from .interval import change_interval
from .help import send_help
from .logs import send_logs
from .delete_logs import delete_logs
from .start import start_bot
from .check import check_command
from .menu_handlers import (
    get_main_menu_markup, show_signals_button, count_signals_button,
    start_bot_button, stop_bot_button, help_button, actual_send_button,
    delete_tables_button, table_signals_button, change_interval_button,
    check_command_button, send_logs_button, delete_logs_button
)
from .scheduler_command import start_scheduler_command

__all__ = [
    'start_bot', 'stop_bot', 'show_signals', 'count_signals',
    'delete_tables', 'table_signals', 'toggle_actual_send',
    'change_interval', 'send_help', 'send_logs', 'delete_logs',
    'get_main_menu_markup', 'show_signals_button', 'count_signals_button',
    'start_bot_button', 'stop_bot_button', 'help_button', 'actual_send_button',
    'delete_tables_button', 'table_signals_button', 'change_interval_button',
    'check_command_button', 'send_logs_button', 'delete_logs_button',
    'send_pending_signals', 'start_scheduler_command', 'check_command'
]
--------------------------------------------------------------------------------
Path: /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/bot/handlers/commands/actual_send.py
File Name: actual_send.py
Code:
from config import toggle_actual_signals, get_actual_signals_status
from utils.logger import general_logger

async def toggle_actual_send(message, bot):
    new_status = toggle_actual_signals()
    status = "включена" if new_status else "отключена"
    response = f"Отправка актуальных сигналов {status}."
    await bot.send_message(message.chat.id, response)
    general_logger.info(response)

async def actual_send_button(message, bot):
    await toggle_actual_send(message, bot)
--------------------------------------------------------------------------------
Path: /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/bot/handlers/commands/start.py
File Name: start.py
Code:
from telebot.async_telebot import AsyncTeleBot
from utils.logger import general_logger
from config import CHECK_INTERVAL, CRYPTO_PAIRS
from bot.scheduler import start_scheduler
from database.db_handler import get_active_signals, get_closed_signals, mark_signal_as_reported
from utils.message_formatter import format_new_signal_message, format_closed_signal_message
from .menu_handlers import get_main_menu_markup
from bot.handlers.utils import send_signal_messages
from services.signal_manager import check_and_create_signals

import asyncio

check_task = None

async def start_bot(message, bot: AsyncTeleBot):
    global check_task
    chat_id = message.chat.id

    if check_task is None or check_task.done():
        general_logger.info("Бот запускается.")
        response = "Бот запущен и готов к работе. Выполняется начальный анализ..."
        await bot.reply_to(message, response, reply_markup=get_main_menu_markup())

        check_task = asyncio.create_task(process_and_send_signals(bot, chat_id))
        await check_task

        await start_scheduler(CHECK_INTERVAL, bot, chat_id)

        general_logger.info("Периодическая проверка сигналов запущена.")
        await bot.send_message(chat_id, "Начальный анализ завершен. Бот готов к работе.")
    else:
        general_logger.info("Бот уже работает.")
        response = "Бот уже работает. Используйте кнопки меню для управления."
        await bot.reply_to(message, response, reply_markup=get_main_menu_markup())

async def process_and_send_signals(bot: AsyncTeleBot, chat_id):
    general_logger.info("Выполнение начального анализа и отправка сигналов.")

    new_signals, updated_signals, closed_signals = await check_and_create_signals(CRYPTO_PAIRS)

    # Отправляем разделитель только при старте бота
    await bot.send_message(chat_id, "Начало анализа сигналов:")

    if new_signals or updated_signals:
        await bot.send_message(
            chat_id,
            f"Количество активных сигналов: {len(new_signals) + len(updated_signals)}"
        )
        await send_signal_messages(
            chat_id=chat_id,
            signals=new_signals + updated_signals,
            format_message_func=format_new_signal_message,
            is_new=True
        )

    if closed_signals:
        await bot.send_message(
            chat_id,
            f"Количество закрытых сигналов: {len(closed_signals)}"
        )
        for signal in closed_signals:
            try:
                if signal.price_end is not None and signal.price_start is not None:
                    message = format_closed_signal_message(signal)
                    await bot.send_message(chat_id, message)
                    mark_signal_as_reported(signal.id)
                else:
                    general_logger.warning(f"Пропущен закрытый сигнал {signal.name} из-за отсутствия данных о цене")
            except Exception as e:
                general_logger.error(f"Ошибка при обработке закрытого сигнала {signal.name}: {e}")
        general_logger.info("Закрытые сигналы обработаны и отмечены как отправленные.")
    else:
        await bot.send_message(chat_id, "В данный момент нет закрытых сигналов.")

    # Обработка существующих закрытых сигналов, которые еще не были отправлены
    existing_closed_signals = get_closed_signals()
    if existing_closed_signals:
        await bot.send_message(
            chat_id,
            f"Количество существующих закрытых сигналов: {len(existing_closed_signals)}"
        )
        for signal in existing_closed_signals:
            try:
                if signal.price_end is not None and signal.price_start is not None:
                    message = format_closed_signal_message(signal)
                    await bot.send_message(chat_id, message)
                    mark_signal_as_reported(signal.id)
                else:
                    general_logger.warning(f"Пропущен существующий закрытый сигнал {signal.name} из-за отсутствия данных о цене")
            except Exception as e:
                general_logger.error(f"Ошибка при обработке существующего закрытого сигнала {signal.name}: {e}")
        general_logger.info("Существующие закрытые сигналы обработаны и отмечены как отправленные.")
--------------------------------------------------------------------------------
Path: /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/bot/handlers/commands/delete_tables.py
File Name: delete_tables.py
Code:
from telebot.async_telebot import AsyncTeleBot
from database.db_handler import delete_all_tables, init_db
from utils.logger import general_logger

async def delete_tables(message, bot: AsyncTeleBot):
    general_logger.info("Команда /delete_tables инициирована.")
    delete_all_tables()
    init_db()
    await bot.reply_to(message, "Все таблицы удалены и созданы заново.")
    general_logger.info("Все таблицы удалены и созданы заново.")
--------------------------------------------------------------------------------
Path: /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/bot/handlers/commands/logs.py
File Name: logs.py
Code:
import logging
from pathlib import Path
from telebot.async_telebot import AsyncTeleBot
from utils.logger import general_logger

MAX_FILE_SIZE = 50 * 1024 * 1024

async def send_logs(message, bot: AsyncTeleBot):
    general_logger.info("Запрос логов через команду /logs")
    log_dir = Path(__file__).parents[4] / 'crypto_trend_bot' / 'logs'

    try:
        files = list(log_dir.iterdir())
        if not files:
            await bot.send_message(message.chat.id, "Нет доступных файлов для отправки.")
            general_logger.info("Нет доступных файлов для отправки.")
            return

        for log_file in files:
            if log_file.is_file():
                if log_file.stat().st_size == 0:
                    logging.info(f"Файл {log_file.name} пустой, пропускаем его отправку.")
                    await bot.send_message(message.chat.id,
                                           f"Файл {log_file.name} пустой и не будет отправлен.")
                    continue

                if log_file.stat().st_size > MAX_FILE_SIZE:
                    logging.warning(f"Файл {log_file.name} слишком большой для отправки.")
                    await bot.send_message(message.chat.id,
                                           f"Файл {log_file.name} слишком большой и не будет отправлен.")
                    continue

                with open(log_file, 'rb') as file:
                    await bot.send_document(message.chat.id, file, caption=f"Файл: {log_file.name}")
                    general_logger.info(f"Файл {log_file.name} отправлен.")

    except Exception as e:
        general_logger.error(f"Ошибка при отправке файлов: {e}")
        await bot.send_message(message.chat.id, "Произошла ошибка при отправке файлов.")
--------------------------------------------------------------------------------
Path: /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/bot/handlers/commands/scheduler_command.py
File Name: scheduler_command.py
Code:
import logging
from bot.scheduler import start_scheduler, get_current_interval
from config import CHECK_INTERVAL

async def start_scheduler_command(message, bot):
    try:
        current_interval = get_current_interval()

        if current_interval is None:
            await start_scheduler(CHECK_INTERVAL, bot)
            await bot.reply_to(message, f"Планировщик успешно запущен с интервалом {CHECK_INTERVAL} секунд.")
            logging.info("Планировщик успешно запущен.")
        else:
            await bot.reply_to(message, f"Планировщик уже запущен с интервалом {current_interval} секунд.")
            logging.info(f"Попытка запуска планировщика, но он уже запущен с интервалом {current_interval} секунд.")
    except Exception as e:
        logging.error(f"Ошибка при запуске планировщика: {e}")
        await bot.reply_to(message, "Произошла ошибка при запуске планировщика.")
--------------------------------------------------------------------------------
Path: /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/bot/handlers/commands/help.py
File Name: help.py
Code:
from telebot.async_telebot import AsyncTeleBot
from utils.logger import general_logger
from .menu_handlers import get_main_menu_markup

async def send_help(message, bot: AsyncTeleBot):
    general_logger.info("Отправка справочной информации.")
    help_text = """
Доступные команды:
/start - Запустить бота и активировать периодические проверки
/stop - Остановить бота и деактивировать периодические проверки
/show - Показать текущие активные и закрытые сигналы
/count - Показать количество открытых и закрытых сигналов
/delete_tables - Удалить все таблицы в базе данных (используйте с осторожностью!)
/table_signals - Показать содержимое таблицы `signals`
/help - Показать это сообщение помощи
/interval - Изменить интервал проверки или показать текущий интервал
/actual_send - Включить/выключить отправку актуальных сигналов
/logs - Показать файлы логов
/delete_logs - Удалить все файлы логов (используйте с осторожностью!)
/check - Выполнить внеплановую проверку сигналов
    """
    await bot.reply_to(message, help_text, reply_markup=get_main_menu_markup())
    general_logger.info("Справочная информация отправлена.")
--------------------------------------------------------------------------------
Path: /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/bot/handlers/commands/table_signals.py
File Name: table_signals.py
Code:
from telebot.async_telebot import AsyncTeleBot
from database.db_handler import fetch_all_signals
from utils.logger import general_logger
from utils.message_formatter import format_signals_table

async def table_signals(message, bot: AsyncTeleBot):
    general_logger.info("Запущена команда /table_signals.")
    signals = fetch_all_signals()
    if not signals:
        await bot.reply_to(message, "Таблица `signals` пуста.")
        general_logger.info("Таблица `signals` пуста.")
    else:
        table_message = format_signals_table(signals)
        await bot.reply_to(message, table_message)
        general_logger.info("Таблица `signals` отправлена.")
--------------------------------------------------------------------------------
Path: /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/bot/handlers/commands/show_signals.py
File Name: show_signals.py
Code:
from telebot.async_telebot import AsyncTeleBot
from database.db_handler import (
    get_active_signals,
    get_closed_signals,
    mark_signal_as_reported,
    get_signals_to_send,
    mark_signal_as_sent,
    get_signal_by_id,
    increment_count_sends
)
from utils.logger import general_logger
from utils.message_formatter import format_new_signal_message, format_closed_signal_message
from bot.handlers.utils import send_signal_messages
from config import get_actual_signals_status

async def show_signals(message, bot: AsyncTeleBot):
    general_logger.info("Команда /show инициирована.")
    chat_id = message.chat.id

    active_signals = get_active_signals()
    closed_signals = get_closed_signals()

    if not active_signals:
        general_logger.info("Нет активных сигналов.")
        await bot.reply_to(message, "В данный момент нет активных сигналов.")
    else:
        general_logger.info(f"Найдено {len(active_signals)} активных сигналов.")
        await send_signal_messages(
            chat_id=chat_id, signals=active_signals, format_message_func=format_new_signal_message
        )

    if closed_signals:
        general_logger.info(f"Найдено {len(closed_signals)} закрытых сигналов.")
        await send_signal_messages(
            chat_id=chat_id,
            signals=closed_signals,
            format_message_func=format_closed_signal_message
        )
        for signal in closed_signals:
            mark_signal_as_reported(signal.id)
        general_logger.info("Закрытые сигналы обработаны и отмечены как отправленные.")
    else:
        general_logger.info("Нет закрытых сигналов.")
        await bot.reply_to(message, "В данный момент нет закрытых сигналов.")

async def send_pending_signals(bot: AsyncTeleBot, chat_id):
    general_logger.info("Обработка отложенных сигналов.")
    signals_to_send = get_signals_to_send()
    send_actual = get_actual_signals_status()

    signals_dict = {}
    for signal_id, signal_type in signals_to_send:
        signal = get_signal_by_id(signal_id)
        if signal:
            signals_dict[signal_id] = signal

    general_logger.info(f"Используем chat_id: {chat_id}")

    if signals_dict:
        general_logger.info(
            f"Отправка {len(signals_dict)} сигналов. Актуальная отправка сигналов "
            f"{'включена' if send_actual else 'выключена'}."
        )

        for signal in signals_dict.values():
            is_new = signal.count_sends == 0
            is_closed = signal.date_end is not None

            if is_new:
                general_logger.info(f"Обнаружен новый сигнал с ID {signal.id}.")
            elif is_closed:
                general_logger.info(f"Обнаружен закрытый сигнал с ID {signal.id}.")
            else:
                general_logger.info(f"Обнаружен актуальный сигнал с ID {signal.id}.")

            if is_new or is_closed or send_actual:
                if is_closed:
                    await send_signal_messages(
                        chat_id=chat_id,
                        signals=[signal],
                        format_message_func=format_closed_signal_message,
                    )
                    mark_signal_as_reported(signal.id)
                else:
                    await send_signal_messages(
                        chat_id=chat_id,
                        signals=[signal],
                        format_message_func=format_new_signal_message,
                        is_new=is_new,
                    )

                success = increment_count_sends(signal.id)
                if success:
                    general_logger.info(
                        f"Успешно увеличено количество отправок для сигнала с ID {signal.id}"
                    )
                else:
                    general_logger.warning(
                        f"Не удалось увеличить количество отправок для сигнала с ID {signal.id}"
                    )
                mark_signal_as_sent(signal.id)
            else:
                general_logger.info(
                    f"Пропущен актуальный сигнал с ID {signal.id} из-за настроек отправки"
                )

        general_logger.info("Процесс отправки сигналов завершен.")
    else:
        general_logger.info("Нет новых сигналов для отправки.")
        await bot.send_message(chat_id, "Нет новых сигналов для отправки.")
--------------------------------------------------------------------------------
Path: /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/bot/handlers/commands/menu_handlers.py
File Name: menu_handlers.py
Code:
from telebot.async_telebot import AsyncTeleBot
from .actual_send import toggle_actual_send
from telebot.types import ReplyKeyboardMarkup, KeyboardButton

def get_main_menu_markup():
    main_menu_markup = ReplyKeyboardMarkup(resize_keyboard=True)
    main_menu_markup.row(KeyboardButton("📊 Показать сигналы"), KeyboardButton("🔢 Количество сигналов"))
    main_menu_markup.row(KeyboardButton("▶️ Старт"), KeyboardButton("⏹ Стоп"))
    main_menu_markup.row(KeyboardButton("🔄 Переключить отправку"), KeyboardButton("❓ Помощь"))
    main_menu_markup.row(KeyboardButton("🗑 Удалить таблицы"), KeyboardButton("📋 Таблица сигналов"))
    main_menu_markup.row(KeyboardButton("⏱ Изменить интервал"), KeyboardButton("🔍 Проверить сейчас"))
    main_menu_markup.row(KeyboardButton("📁 Показать логи"), KeyboardButton("🗑 Удалить логи"))
    return main_menu_markup

async def show_signals_button(message, bot):
    from .show_signals import show_signals
    await show_signals(message, bot)

async def count_signals_button(message, bot):
    from .count_signals import count_signals
    await count_signals(message, bot)

async def start_bot_button(message, bot):
    from .start import start_bot
    await start_bot(message, bot)

async def stop_bot_button(message, bot):
    from .stop import stop_bot
    await stop_bot(message, bot)

async def actual_send_button(message, bot):
    await toggle_actual_send(message, bot)

async def help_button(message, bot):
    from .help import send_help
    await send_help(message, bot)

async def delete_tables_button(message, bot):
    from .delete_tables import delete_tables
    await delete_tables(message, bot)

async def table_signals_button(message, bot):
    from .table_signals import table_signals
    await table_signals(message, bot)

async def change_interval_button(message, bot):
    from .interval import change_interval
    await change_interval(message, bot)

async def check_command_button(message, bot):
    from .check import check_command
    await check_command(message, bot)

async def send_logs_button(message, bot):
    from .logs import send_logs
    await send_logs(message, bot)

async def delete_logs_button(message, bot):
    from .delete_logs import delete_logs
    await delete_logs(message, bot)
--------------------------------------------------------------------------------
Error reading /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/bot/handlers/commands/__pycache__/logs.cpython-311.pyc: 'utf-8' codec can't decode byte 0xa7 in position 0: invalid start byte
Error reading /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/bot/handlers/commands/__pycache__/stop.cpython-311.pyc: 'utf-8' codec can't decode byte 0xa7 in position 0: invalid start byte
Error reading /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/bot/handlers/commands/__pycache__/check.cpython-311.pyc: 'utf-8' codec can't decode byte 0xa7 in position 0: invalid start byte
Error reading /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/bot/handlers/commands/__pycache__/menu_handlers.cpython-311.pyc: 'utf-8' codec can't decode byte 0xa7 in position 0: invalid start byte
Error reading /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/bot/handlers/commands/__pycache__/count_signals.cpython-311.pyc: 'utf-8' codec can't decode byte 0xa7 in position 0: invalid start byte
Error reading /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/bot/handlers/commands/__pycache__/delete_logs.cpython-311.pyc: 'utf-8' codec can't decode byte 0xa7 in position 0: invalid start byte
Error reading /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/bot/handlers/commands/__pycache__/scheduler_command.cpython-311.pyc: 'utf-8' codec can't decode byte 0xa7 in position 0: invalid start byte
Error reading /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/bot/handlers/commands/__pycache__/help.cpython-311.pyc: 'utf-8' codec can't decode byte 0xa7 in position 0: invalid start byte
Error reading /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/bot/handlers/commands/__pycache__/actual_send.cpython-311.pyc: 'utf-8' codec can't decode byte 0xa7 in position 0: invalid start byte
Error reading /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/bot/handlers/commands/__pycache__/interval.cpython-311.pyc: 'utf-8' codec can't decode byte 0xa7 in position 0: invalid start byte
Error reading /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/bot/handlers/commands/__pycache__/delete_tables.cpython-311.pyc: 'utf-8' codec can't decode byte 0xa7 in position 0: invalid start byte
Error reading /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/bot/handlers/commands/__pycache__/table_signals.cpython-311.pyc: 'utf-8' codec can't decode byte 0xa7 in position 0: invalid start byte
Error reading /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/bot/handlers/commands/__pycache__/show_signals.cpython-311.pyc: 'utf-8' codec can't decode byte 0xa7 in position 0: invalid start byte
Error reading /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/bot/handlers/commands/__pycache__/__init__.cpython-311.pyc: 'utf-8' codec can't decode byte 0xa7 in position 0: invalid start byte
Error reading /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/bot/handlers/commands/__pycache__/start.cpython-311.pyc: 'utf-8' codec can't decode byte 0xa7 in position 0: invalid start byte
Path: /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/database/models.py
File Name: models.py
Code:
from dataclasses import dataclass

@dataclass
class Signal:
    id: int
    name: str
    trend: str
    date_start: str
    date_last: str
    accuracy: float
    date_end: str
    price_start: float
    price_last: float
    price_end: float
    count_sends: int
    reported: int
    forecast: str = "unknown"
--------------------------------------------------------------------------------
Path: /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/database/__init__.py
File Name: __init__.py
Code:

--------------------------------------------------------------------------------
Path: /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/database/db_handler.py
File Name: db_handler.py
Code:
from database.models import Signal
import sqlite3
from config import DB_NAME
from utils.logger import general_logger
from typing import Any

def init_db():
    conn = sqlite3.connect(DB_NAME)
    c = conn.cursor()

    c.execute('''CREATE TABLE IF NOT EXISTS signals
                 (id INTEGER PRIMARY KEY AUTOINCREMENT,
                  name TEXT,
                  trend TEXT,
                  date_start TEXT,
                  date_last TEXT,
                  accuracy INTEGER CHECK(accuracy >= 1 AND accuracy <= 100),
                  date_end TEXT,
                  price_start REAL,
                  price_last REAL,
                  price_end REAL,
                  count_sends INTEGER,
                  reported INTEGER DEFAULT 0,
                  forecast TEXT DEFAULT 'unknown')''')

    c.execute('''CREATE TABLE IF NOT EXISTS signals_to_send
                 (id INTEGER PRIMARY KEY AUTOINCREMENT,
                  signal_id INTEGER,
                  signal_type TEXT,
                  sent INTEGER DEFAULT 0)''')

    conn.commit()
    conn.close()

def delete_all_tables():
    conn = sqlite3.connect(DB_NAME)
    c = conn.cursor()

    c.execute("DROP TABLE IF EXISTS signals")
    c.execute("DROP TABLE IF EXISTS signals_to_send")
    c.execute("DROP TABLE IF EXISTS history")

    conn.commit()
    conn.close()

    general_logger.info("Все таблицы удалены.")

def update_db_structure():
    conn = sqlite3.connect(DB_NAME)
    c = conn.cursor()

    c.execute("PRAGMA table_info(signals)")
    columns = [column[1] for column in c.fetchall()]

    if 'forecast' not in columns:
        c.execute("ALTER TABLE signals ADD COLUMN forecast TEXT DEFAULT 'unknown'")
        general_logger.info("Добавлена колонка 'forecast' в таблицу signals")

    conn.commit()
    conn.close()

def insert_signal(name, trend, date_start, price_start, accuracy, forecast):
    conn = sqlite3.connect(DB_NAME)
    c = conn.cursor()

    c.execute('''SELECT * FROM signals 
                 WHERE name = ? AND date_end IS NULL''', (name,))
    existing_signal = c.fetchone()

    if not existing_signal:
        accuracy = max(1, min(100, int(accuracy)))
        c.execute('''INSERT INTO signals 
                     (name, trend, date_start, date_last, accuracy, price_start, price_last, count_sends, forecast)
                     VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)''',
                  (name, trend, date_start, date_start, accuracy, price_start, price_start, 0, forecast))

    conn.commit()
    conn.close()

def update_signal(name, date_last, price_last, accuracy, forecast):
    conn = sqlite3.connect(DB_NAME)
    c = conn.cursor()
    accuracy = max(1, min(100, int(accuracy)))
    c.execute('''UPDATE signals
                 SET date_last = ?, price_last = ?, accuracy = ?, forecast = ?
                 WHERE name = ? AND date_end IS NULL''',
              (date_last, price_last, accuracy, forecast, name))
    conn.commit()
    conn.close()

def increment_count_sends(signal_id: Any) -> bool:
    conn = sqlite3.connect(DB_NAME)
    c = conn.cursor()
    c.execute('''UPDATE signals
                 SET count_sends = count_sends + 1
                 WHERE id = ?''', (signal_id,))
    conn.commit()
    rows_affected = c.rowcount
    conn.close()
    general_logger.info(
        f"Увеличено количество отправок для сигнала с ID {signal_id}. Затронуто строк: {rows_affected}")
    return rows_affected > 0

def get_active_signals():
    conn = sqlite3.connect(DB_NAME)
    c = conn.cursor()
    c.execute('''SELECT id, name, trend, date_start, date_last, accuracy, date_end, 
                 price_start, price_last, price_end, count_sends, reported, forecast
                 FROM signals WHERE date_end IS NULL''')
    signals = c.fetchall()
    conn.close()
    return [Signal(*signal) for signal in signals]

def get_closed_signals():
    conn = sqlite3.connect(DB_NAME)
    c = conn.cursor()
    c.execute('''SELECT id, name, trend, date_start, date_last, accuracy, date_end, 
                 price_start, price_last, price_end, count_sends, reported, forecast
                 FROM signals 
                 WHERE date_end IS NOT NULL 
                 AND reported = 0''')
    signals = c.fetchall()
    conn.close()
    return [Signal(*signal) for signal in signals]

def close_signal(name, date_end, price_end):
    conn = sqlite3.connect(DB_NAME)
    c = conn.cursor()
    c.execute('''UPDATE signals
                 SET date_end = ?, price_end = ?
                 WHERE name = ? AND date_end IS NULL''',
              (date_end, price_end, name))
    conn.commit()
    conn.close()

def mark_signal_as_reported(signal_id):
    conn = sqlite3.connect(DB_NAME)
    c = conn.cursor()
    c.execute('''UPDATE signals
                 SET reported = 1
                 WHERE id = ?''', (signal_id,))
    conn.commit()
    conn.close()

def move_old_signals_to_history():
    conn = sqlite3.connect(DB_NAME)
    c = conn.cursor()
    c.execute('''INSERT INTO history
                 SELECT * FROM signals
                 WHERE date_end IS NOT NULL 
                 AND reported = 1''')
    c.execute('''DELETE FROM signals
                 WHERE date_end IS NOT NULL 
                 AND reported = 1''')
    conn.commit()
    conn.close()

def get_signals_count():
    conn = sqlite3.connect(DB_NAME)
    c = conn.cursor()
    c.execute("SELECT COUNT(*) FROM signals WHERE date_end IS NULL")
    active_count = c.fetchone()[0]
    c.execute("SELECT COUNT(*) FROM signals WHERE date_end IS NOT NULL")
    closed_count = c.fetchone()[0]
    conn.close()
    return active_count, closed_count

def fetch_all_signals():
    conn = sqlite3.connect(DB_NAME)
    c = conn.cursor()
    c.execute("SELECT * FROM signals")
    signals = c.fetchall()
    conn.close()
    return signals

def get_active_signal(name):
    conn = sqlite3.connect(DB_NAME)
    c = conn.cursor()  # Инициализация курсора
    c.execute('''SELECT id, name, trend, date_start, date_last, accuracy, date_end, 
                 price_start, price_last, price_end, count_sends, reported, forecast
                 FROM signals 
                 WHERE name = ? AND date_end IS NULL''', (name,))
    signal_data = c.fetchone()
    conn.close()
    return Signal(*signal_data) if signal_data else None

def store_signals_for_sending(new_signals, updated_signals, closed_signals):
    conn = sqlite3.connect(DB_NAME)
    c = conn.cursor()

    c.execute('''CREATE TABLE IF NOT EXISTS signals_to_send
                 (id INTEGER PRIMARY KEY AUTOINCREMENT,
                  signal_id INTEGER,
                  signal_type TEXT,
                  sent INTEGER DEFAULT 0)''')

    for signal in new_signals:
        c.execute("INSERT INTO signals_to_send (signal_id, signal_type) VALUES (?, ?)",
                  (signal.id, "new"))

    for signal in updated_signals:
        c.execute("INSERT INTO signals_to_send (signal_id, signal_type) VALUES (?, ?)",
                  (signal.id, "updated"))

    for signal in closed_signals:
        c.execute("INSERT INTO signals_to_send (signal_id, signal_type) VALUES (?, ?)",
                  (signal.id, "closed"))

    conn.commit()
    conn.close()

def get_signals_to_send():
    conn = sqlite3.connect(DB_NAME)
    c = conn.cursor()

    c.execute("SELECT signal_id, signal_type FROM signals_to_send WHERE sent = 0")
    signals_to_send = c.fetchall()

    conn.close()

    return signals_to_send

def mark_signal_as_sent(signal_id):
    conn = sqlite3.connect(DB_NAME)
    c = conn.cursor()
    c.execute('''UPDATE signals_to_send
                 SET sent = 1
                 WHERE signal_id = ?''', (signal_id,))
    conn.commit()
    conn.close()
    general_logger.info(f"Сигнал с ID {signal_id} отмечен как отправленный")

def get_signal_by_id(signal_id):
    conn = sqlite3.connect(DB_NAME)
    c = conn.cursor()
    c.execute('''SELECT id, name, trend, date_start, date_last, accuracy, date_end, 
                 price_start, price_last, price_end, count_sends, reported, forecast
                 FROM signals WHERE id = ?''', (signal_id,))
    signal_data = c.fetchone()
    conn.close()
    if signal_data:
        return Signal(*signal_data)
    return None

__all__ = ['increment_count_sends', 'init_db', 'delete_all_tables', 'insert_signal', 'update_signal',
           'get_active_signals', 'get_closed_signals', 'close_signal', 'mark_signal_as_reported',
           'get_signals_count', 'fetch_all_signals', 'get_active_signal', 'store_signals_for_sending',
           'get_signals_to_send', 'mark_signal_as_sent', 'get_signal_by_id', 'update_db_structure']
--------------------------------------------------------------------------------
Error reading /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/database/__pycache__/models.cpython-311.pyc: 'utf-8' codec can't decode byte 0xa7 in position 0: invalid start byte
Error reading /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/database/__pycache__/db_handler.cpython-311.pyc: 'utf-8' codec can't decode byte 0xa7 in position 0: invalid start byte
Error reading /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/database/__pycache__/__init__.cpython-311.pyc: 'utf-8' codec can't decode byte 0xa7 in position 0: invalid start byte
Path: /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/services/crypto_api.py
File Name: crypto_api.py
Code:
import ccxt
from config import EXCHANGE_API_KEY, EXCHANGE_SECRET
import numpy as np

exchange = ccxt.binance({
    'apiKey': EXCHANGE_API_KEY,
    'secret': EXCHANGE_SECRET
})

async def get_ohlcv(pair):
    try:
        ohlcv = exchange.fetch_ohlcv(pair, timeframe='1h', limit=48)
        ohlcv_array = np.array(ohlcv)
        return {
            'timestamp': ohlcv_array[:, 0],
            'open': ohlcv_array[:, 1],
            'high': ohlcv_array[:, 2],
            'low': ohlcv_array[:, 3],
            'close': ohlcv_array[:, 4],
            'volume': ohlcv_array[:, 5]
        }
    except Exception as e:
        print(f"Ошибка при получении данных OHLCV для пары {pair}: {e}")
        return None

async def get_current_price(pair):
    try:
        ticker = exchange.fetch_ticker(pair)
        return ticker['close']
    except Exception as e:
        print(f"Ошибка при получении текущей цены для пары {pair}: {e}")
        return None
--------------------------------------------------------------------------------
Path: /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/services/signal_manager.py
File Name: signal_manager.py
Code:
from database.db_handler import insert_signal, update_signal, close_signal, get_active_signals, get_active_signal
from services.crypto_api import get_ohlcv, get_current_price
from services.trend_analyzer import analyze_trend, is_trend_still_valid
from utils.time_utils import get_current_time
from database.models import Signal
from utils.logger import analyze_logger, general_logger
import asyncio

async def check_and_create_signals(crypto_pairs):
    general_logger.info("Проверка и создание новых сигналов.")
    analyze_logger.info("Начало процесса проверки и создания сигналов")
    new_signals = []
    updated_signals = []
    closed_signals = []

    for pair in crypto_pairs:
        analyze_logger.info(f"Анализ пары: {pair}")
        ohlcv = await get_ohlcv(pair)
        if ohlcv:
            trend, accuracy, forecast = analyze_trend(ohlcv)
            existing_signal = get_active_signal(pair)
            current_price = await get_current_price(pair)
            current_time = get_current_time()

            if existing_signal:
                if existing_signal.trend == trend:
                    update_signal(pair, current_time, current_price, accuracy, forecast)
                    updated_signals.append(existing_signal)
                    analyze_logger.info(f"Обновлен существующий сигнал для пары {pair}: {trend} с точностью {accuracy}")
                else:
                    close_signal(pair, current_time, current_price)
                    closed_signals.append(existing_signal)
                    insert_signal(pair, trend, current_time, current_price, accuracy, forecast)
                    new_signal = get_active_signal(pair)
                    new_signals.append(new_signal)
                    analyze_logger.info(f"Закрыт старый сигнал и создан новый для пары {pair}: {trend} с точностью {accuracy}")
            else:
                insert_signal(pair, trend, current_time, current_price, accuracy, forecast)
                new_signal = get_active_signal(pair)
                new_signals.append(new_signal)
                analyze_logger.info(f"Создан новый сигнал для пары {pair}: {trend} с точностью {accuracy}")
        else:
            analyze_logger.warning(f"Не удалось получить данные OHLCV для пары {pair}. Пропуск.")

    analyze_logger.info("Завершение процесса проверки и создания сигналов")
    return new_signals, updated_signals, closed_signals

async def update_active_signals():
    general_logger.info("Обновление активных сигналов.")
    analyze_logger.info("Начало обновления активных сигналов")
    active_signals = get_active_signals()
    for signal in active_signals:
        pair = signal.name
        analyze_logger.info(f"Обновление сигнала для пары: {pair}")
        ohlcv = await get_ohlcv(pair)
        if ohlcv:
            if is_trend_still_valid(ohlcv, signal.trend):
                analyze_logger.info(f"Сигнал для пары {pair} все еще актуален")
                current_price = await get_current_price(pair)
                current_time = get_current_time()
                _, accuracy, forecast = analyze_trend(ohlcv)
                update_signal(pair, current_time, current_price, accuracy, forecast)
            else:
                analyze_logger.info(f"Сигнал для пары {pair} больше не актуален")
                current_price = await get_current_price(pair)
                current_time = get_current_time()
                close_signal(pair, current_time, current_price)
        else:
            analyze_logger.warning(f"Не удалось получить данные OHLCV для пары {pair}. Пропуск.")
    analyze_logger.info("Завершение обновления активных сигналов")

async def update_signal_in_db(signal):
    try:
        existing_signal = get_active_signal(signal.name)
        if existing_signal:
            update_signal(signal.name, signal.date_last, signal.price_last, signal.accuracy, signal.forecast)
            analyze_logger.info(f"Обновлен сигнал в базе данных: ID {signal.id}, тренд {signal.trend}, точность {signal.accuracy}")
        else:
            analyze_logger.error(f"Сигнал с ID {signal.id} не найден в базе данных.")
    except Exception as e:
        analyze_logger.error(f"Ошибка при обновлении сигнала в базе данных: {e}")
--------------------------------------------------------------------------------
Path: /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/services/trend_analyzer.py
File Name: trend_analyzer.py
Code:
import pandas as pd
import numpy as np
from utils.logger import analyze_logger
from scipy import stats

def analyze_trend(ohlcv_data):
    analyze_logger.info("Начало анализа тренда")

    df = pd.DataFrame(ohlcv_data, columns=['timestamp', 'open', 'high', 'low', 'close', 'volume'])
    df['timestamp'] = pd.to_datetime(df['timestamp'], unit='ms')
    df.set_index('timestamp', inplace=True)

    if len(df) < 48:  # Минимум 2 дня данных с часовыми интервалами
        analyze_logger.warning("Недостаточно данных для анализа")
        return 'neutral', 50, None

    df['MA20'] = df['close'].rolling(window=20).mean()
    df['MA50'] = df['close'].rolling(window=50).mean()
    df['EMA20'] = df['close'].ewm(span=20, adjust=False).mean()
    df['BB_upper'] = df['MA20'] + 2 * df['close'].rolling(window=20).std()
    df['BB_lower'] = df['MA20'] - 2 * df['close'].rolling(window=20).std()

    current_trend = determine_trend(df)
    accuracy = calculate_accuracy(df)
    forecast = generate_forecast(df)

    analyze_logger.info(f"Тренд: {current_trend}, Точность: {accuracy}%, Прогноз: {forecast}")

    return current_trend, accuracy, forecast

def determine_trend(df):
    close = df['close'].iloc[-1]
    ma20 = df['MA20'].iloc[-1]
    ma50 = df['MA50'].iloc[-1]
    ema20 = df['EMA20'].iloc[-1]
    bb_upper = df['BB_upper'].iloc[-1]
    bb_lower = df['BB_lower'].iloc[-1]

    if close > ma20 and close > ma50 and close > ema20:
        if close > bb_upper:
            return 'перекупленность'
        return 'бычий'
    elif close < ma20 and close < ma50 and close < ema20:
        if close < bb_lower:
            return 'перепроданность'
        return 'медвежий'
    elif ma20 > ma50:
        return 'краткосрочный бычий'
    elif ma20 < ma50:
        return 'краткосрочный медвежий'
    else:
        return 'боковой'

def calculate_accuracy(df):
    close = df['close'].iloc[-1]
    ma20 = df['MA20'].iloc[-1]
    diff = abs(close - ma20)
    max_diff = max(df['close']) - min(df['close'])
    accuracy = int((1 - diff / max_diff) * 100)
    return accuracy

def generate_forecast(df):
    slope, intercept, r_value, p_value, std_err = stats.linregress(range(len(df['close'])), df['close'])
    forecast = 'upward' if slope > 0 else 'downward' if slope < 0 else 'neutral'
    return forecast

def is_trend_still_valid(ohlcv_data, current_trend):
    df = pd.DataFrame(ohlcv_data, columns=['timestamp', 'open', 'high', 'low', 'close', 'volume'])
    df['timestamp'] = pd.to_datetime(df['timestamp'], unit='ms')
    df.set_index('timestamp', inplace=True)

    if len(df) < 48:  # Минимум 2 дня данных с часовыми интервалами
        return False

    df['MA20'] = df['close'].rolling(window=20).mean()
    df['MA50'] = df['close'].rolling(window=50).mean()
    df['EMA20'] = df['close'].ewm(span=20, adjust=False).mean()
    df['BB_upper'] = df['MA20'] + 2 * df['close'].rolling(window=20).std()
    df['BB_lower'] = df['MA20'] - 2 * df['close'].rolling(window=20).std()

    detected_trend = determine_trend(df)
    return detected_trend == current_trend
--------------------------------------------------------------------------------
Error reading /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/services/__pycache__/crypto_api.cpython-311.pyc: 'utf-8' codec can't decode byte 0xa7 in position 0: invalid start byte
Error reading /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/services/__pycache__/trend_analyzer.cpython-311.pyc: 'utf-8' codec can't decode byte 0xa7 in position 0: invalid start byte
Error reading /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/services/__pycache__/signal_manager.cpython-311.pyc: 'utf-8' codec can't decode byte 0xa7 in position 0: invalid start byte
Path: /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/utils/time_utils.py
File Name: time_utils.py
Code:
from datetime import datetime
from pytz import timezone
from config import TIMEZONE

def get_current_time():
    return datetime.now(timezone(TIMEZONE)).isoformat()

def format_date(date_string):
    date = datetime.fromisoformat(date_string)
    if date.tzinfo is None:
        date = date.replace(tzinfo=timezone(TIMEZONE))
    return date.astimezone(timezone(TIMEZONE)).strftime("%Y-%m-%d %H:%M")

def calculate_time_difference(start_time, end_time):
    start = datetime.fromisoformat(start_time)
    end = datetime.fromisoformat(end_time)
    if start.tzinfo is None:
        start = start.replace(tzinfo=timezone(TIMEZONE))
    if end.tzinfo is None:
        end = end.replace(tzinfo=timezone(TIMEZONE))
    diff = end - start
    days = diff.days
    hours = diff.seconds // 3600
    return f"{days} дней и {hours} часов"
--------------------------------------------------------------------------------
Path: /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/utils/logger.py
File Name: logger.py
Code:
import logging
from logging.handlers import TimedRotatingFileHandler
from pathlib import Path

def setup_logging():
    log_dir = Path(__file__).parents[1] / 'logs'
    log_dir.mkdir(exist_ok=True)

    general_log_handler = TimedRotatingFileHandler(
        log_dir / 'general.log',
        when="D",
        interval=1,
        backupCount=7
    )
    general_log_handler.setFormatter(logging.Formatter('%(asctime)s - %(levelname)s - %(message)s'))

    analyze_log_handler = TimedRotatingFileHandler(
        log_dir / 'analyze.log',
        when="D",
        interval=1,
        backupCount=7
    )
    analyze_log_handler.setFormatter(logging.Formatter('%(asctime)s - %(levelname)s - %(message)s'))

    if logging.getLogger('general').hasHandlers():
        logging.getLogger('general').handlers.clear()

    if logging.getLogger('analyze').hasHandlers():
        logging.getLogger('analyze').handlers.clear()

    general_logger = logging.getLogger('general')
    general_logger.setLevel(logging.INFO)
    general_logger.addHandler(general_log_handler)

    analyze_logger = logging.getLogger('analyze')
    analyze_logger.setLevel(logging.INFO)
    analyze_logger.addHandler(analyze_log_handler)

    return general_logger, analyze_logger

general_logger, analyze_logger = setup_logging()

__all__ = ['setup_logging', 'general_logger', 'analyze_logger']
--------------------------------------------------------------------------------
Path: /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/utils/message_formatter.py
File Name: message_formatter.py
Code:
from utils.time_utils import format_date, calculate_time_difference
from utils.logger import general_logger
import datetime
from datetime import datetime
from pytz import timezone
from config import TIMEZONE, get_actual_signals_status


def format_new_signal_message(signal, is_new=False):
    status = "Новый сигнал" if signal.count_sends == 0 else "Актуальный"

    trend_emoji = get_trend_emoji(signal.trend)
    forecast_emoji = get_forecast_emoji(signal.forecast)

    price_change = signal.price_last - signal.price_start
    price_change_percent = (price_change / signal.price_start) * 100
    price_change_str = f"{'+' if price_change > 0 else '-'}${abs(price_change):.2f} ({'+' if price_change_percent > 0 else '-'}{abs(price_change_percent):.2f}%)"

    general_logger.info(
        f"Форматирование сигнала: {signal.name}, Количество отправок: {signal.count_sends}, Статус: {status}"
    )

    return (
        f"{trend_emoji} {status}: {signal.name} {translate_trend(signal.trend).upper()} Точность: {signal.accuracy}\n"
        f"Начало: {format_date(signal.date_start)} Цена: ${signal.price_start:.2f}\n"
        f"Текущая: {format_date(signal.date_last)} Цена: ${signal.price_last:.2f}\n"
        f"Изменение цены: {price_change_str}\n"
        f"Прогноз: {forecast_emoji} {translate_forecast(signal.forecast).capitalize()}"
    )

def format_closed_signal_message(signal):
    trend_emoji = get_trend_emoji(signal.trend)

    price_change = signal.price_end - signal.price_start
    price_change_percent = (price_change / signal.price_start) * 100
    price_change_str = f"{'+' if price_change > 0 else '-'}${abs(price_change):.2f} ({'+' if price_change_percent > 0 else '-'}{abs(price_change_percent):.2f}%)"

    return (
        f"❌ Закрытый сигнал: {signal.name} {trend_emoji} {translate_trend(signal.trend).upper()}\n"
        f"Начало: {format_date(signal.date_start)} Цена: ${signal.price_start:.2f}\n"
        f"Окончание: {format_date(signal.date_end)} Цена: ${signal.price_end:.2f}\n"
        f"Изменение цены: {price_change_str}\n"
        f"Общая продолжительность: {calculate_time_difference(signal.date_start, signal.date_end)}"
    )

def format_signals_table(signals):
    formatted_signals = []

    for signal in signals:
        price_end = f"${signal[9]:.2f}" if signal[9] is not None else "N/A"
        formatted_signal = (
            f"ID: {signal[0]}\n"
            f"Название: {signal[1]}\n"
            f"Тренд: {translate_trend(signal[2])}\n"
            f"Дата начала: {signal[3]}\n"
            f"Последняя дата: {signal[4]}\n"
            f"Точность: {signal[5]}\n"
            f"Дата окончания: {signal[6]}\n"
            f"Начальная цена: ${signal[7]:.2f}\n"
            f"Последняя цена: ${signal[8]:.2f}\n"
            f"Цена при закрытии: {price_end}\n"
            f"Количество отправок: {signal[10]}\n"
            f"Отмечено: {signal[11]}\n"
            f"Прогноз: {translate_forecast(signal[12])}\n"
            "----------------------"
        )
        formatted_signals.append(formatted_signal)

    return "\n".join(formatted_signals)

def get_trend_emoji(trend):
    trend_emojis = {
        "bullish": "🐂",
        "bearish": "🐻",
        "neutral": "➡️",
        "sideways": "↔️",
        "overbought": "🔥",
        "oversold": "🧊",
        "short_term_bullish": "📈",
        "short_term_bearish": "📉",
    }
    return trend_emojis.get(trend.lower(), "⚪️")

def get_forecast_emoji(forecast):
    forecast_emojis = {
        "upward": "🚀",
        "downward": "🔻",
        "stable": "➖"
    }
    return forecast_emojis.get(forecast.lower(), "❓")

def translate_trend(trend):
    trend_translations = {
        "bullish": "бычий",
        "bearish": "медвежий",
        "neutral": "нейтральный",
        "sideways": "боковой",
        "overbought": "перекупленность",
        "oversold": "перепроданность",
        "short_term_bullish": "краткосрочный бычий",
        "short_term_bearish": "краткосрочный медвежий",
    }
    return trend_translations.get(trend.lower(), trend)

def translate_forecast(forecast):
    forecast_translations = {
        "upward": "восходящий",
        "downward": "нисходящий",
        "stable": "стабильный"
    }
    return forecast_translations.get(forecast.lower(), forecast)
--------------------------------------------------------------------------------
Path: /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/utils/chart_generator.py
File Name: chart_generator.py
Code:
import mplfinance as mpf
import pandas as pd
import numpy as np
from datetime import datetime, timedelta
import matplotlib.pyplot as plt
import io
from services.trend_analyzer import determine_trend, generate_forecast

def generate_chart(ohlcv_data, trend, signal_start_date=None, signal_end_date=None):
    # Преобразование данных в DataFrame и установка индекса по временной метке
    df = pd.DataFrame(ohlcv_data, columns=['timestamp', 'open', 'high', 'low', 'close', 'volume'])
    df['timestamp'] = pd.to_datetime(df['timestamp'], unit='ms')
    df.set_index('timestamp', inplace=True)

    if len(df) < 48:
        raise ValueError("Недостаточно данных для вычисления индикаторов")

    # Расчет технических индикаторов
    df['MA20'] = df['close'].rolling(window=20).mean()
    df['MA50'] = df['close'].rolling(window=50).mean()
    df['EMA20'] = df['close'].ewm(span=20, adjust=False).mean()
    df['BB_upper'] = df['MA20'] + 2 * df['close'].rolling(window=20).std()
    df['BB_lower'] = df['MA20'] - 2 * df['close'].rolling(window=20).std()

    trend = determine_trend(df)
    forecast = generate_forecast(df)

    # Настройка цветов для графика
    mc = mpf.make_marketcolors(up='g', down='r', inherit=True)
    s = mpf.make_mpf_style(marketcolors=mc)

    apds = []

    # Добавление индикаторов на график
    if not df['MA20'].isnull().all():
        apds.append(mpf.make_addplot(df['MA20'], color='blue', width=1))
    if not df['MA50'].isnull().all():
        apds.append(mpf.make_addplot(df['MA50'], color='red', width=1))
    if not df['EMA20'].isnull().all():
        apds.append(mpf.make_addplot(df['EMA20'], color='purple', width=1))
    if not df['BB_upper'].isnull().all():
        apds.append(mpf.make_addplot(df['BB_upper'], color='green', linestyle='--'))
    if not df['BB_lower'].isnull().all():
        apds.append(mpf.make_addplot(df['BB_lower'], color='green', linestyle='--'))

    # Добавление маркера для начала сигнала
    if signal_start_date:
        signal_start = datetime.fromisoformat(signal_start_date)
        if signal_start.tzinfo is not None:
            signal_start = signal_start.replace(tzinfo=None)
        signal_start_index = df.index.get_indexer([signal_start], method='nearest')[0]
        signal_start_series = pd.Series([np.nan] * len(df), index=df.index)
        signal_start_series.iloc[signal_start_index] = df['high'].max() * 1.02
        marker = get_trend_marker(trend)
        apds.append(mpf.make_addplot(signal_start_series, type='scatter', markersize=100, marker=marker['shape'], color=marker['color']))

    # Добавление стрелки прогноза
    forecast_arrow = pd.Series([np.nan] * len(df), index=df.index)
    forecast_arrow.iloc[-1] = df['close'].iloc[-1]
    forecast_color = 'g' if forecast == 'upward' else 'r' if forecast == 'downward' else 'gray'
    apds.append(mpf.make_addplot(forecast_arrow, type='scatter', markersize=200, marker='$→$', color=forecast_color))

    # Построение и сохранение графика
    fig, axes = mpf.plot(df, type='candle', style=s, addplot=apds,
                         title=f'Тренд: {translate_trend(trend).capitalize()}, Прогноз: {translate_forecast(forecast).capitalize()}',
                         ylabel='Цена',
                         datetime_format='%Y-%m-%d %H:%М',
                         figsize=(12, 8),
                         returnfig=True)

    buf = io.BytesIO()
    plt.savefig(buf, format='png', dpi=100, bbox_inches='tight')
    buf.seek(0)
    plt.close(fig)

    return buf

def get_trend_marker(trend):
    markers = {
        'bullish': {'shape': '^', 'color': 'g'},
        'bearish': {'shape': 'v', 'color': 'r'},
        'sideways': {'shape': 'o', 'color': 'gray'},
        'overbought': {'shape': 'd', 'color': 'purple'},
        'oversold': {'shape': 'd', 'color': 'orange'},
        'short_term_bullish': {'shape': '>', 'color': 'lime'},
        'short_term_bearish': {'shape': '<', 'color': 'pink'}
    }
    return markers.get(trend.lower(), {'shape': 'o', 'color': 'gray'})

def translate_trend(trend):
    trend_translations = {
        "bullish": "бычий",
        "bearish": "медвежий",
        "neutral": "нейтральный",
        "sideways": "боковой",
        "overbought": "перекупленность",
        "oversold": "перепроданность",
        "short_term_bullish": "краткосрочный бычий",
        "short_term_bearish": "краткосрочный медвежий",
    }
    return trend_translations.get(trend.lower(), trend)

def translate_forecast(forecast):
    forecast_translations = {
        "upward": "восходящий",
        "downward": "нисходящий",
        "stable": "стабильный"
    }
    return forecast_translations.get(forecast.lower(), forecast)
--------------------------------------------------------------------------------
Error reading /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/utils/__pycache__/message_formatter.cpython-311.pyc: 'utf-8' codec can't decode byte 0xa7 in position 0: invalid start byte
Error reading /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/utils/__pycache__/logger.cpython-311.pyc: 'utf-8' codec can't decode byte 0xa7 in position 0: invalid start byte
Error reading /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/utils/__pycache__/time_utils.cpython-311.pyc: 'utf-8' codec can't decode byte 0xa7 in position 0: invalid start byte
Error reading /Users/mikhailryazanov/PycharmProjects/crypto_trend_bot/utils/__pycache__/chart_generator.cpython-311.pyc: 'utf-8' codec can't decode byte 0xa7 in position 0: invalid start byte